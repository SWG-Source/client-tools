//**********************************************************
// Copyright (c) ©2005, 2006 Sony Online Entertainment Inc.
// All Rights Reserved
//
// Title:		qatool.script
// Version:		Version 4.1
// Description:  	Master QA script.  It will be main script to attach
//		 	To get all other tools to work.  It will be slash
//		 	Command Driven.
//
// Version Changes:	- Added new script tool options
//
// @author       	$Author: Jesse Benjamin
// @version      	$All Revisions:  Jeff Haskell && James Michener
//***********************************************************

/********* Includes ******************************************/
include java.util.HashSet;
include java.util.StringTokenizer;
include java.util.Vector
include library.ai_lib;
include library.anims;
include library.beast_lib;
include library.buff;
include library.cloninglib;
include library.create;
include library.combat;
include library.corpse;
include library.dump;
include library.factions;
include library.gm;
include library.groundquests;
include library.loot;
include library.minigame;
include library.pclib;
include library.qa;
include library.respec;
include library.scheduled_drop;
include library.skill;
include library.skill_template;
include library.space_combat;
include library.space_create;
include library.space_quest;
include library.space_transition;
include library.space_utils;
include library.spawning;
include library.static_item;
include library.sui;
include library.utils;
include library.xp;

/********* TABLES/DATA SOURCES *****************************************/

const string CREATURE_TABLE = "datatables/mob/creatures.iff";
const string SPACE_MOBILE_TABLE = "datatables/space_mobile/space_mobile.iff";
const string MASTER_ITEM_TABLE = "datatables/item/master_item/master_item.iff";
const string ARMOR_STATS_TABLE = "datatables/item/master_item/armor_stats.iff";
const string WEAPON_STATS_TABLE = "datatables/item/master_item/weapon_stats.iff";
const string BUFF_TABLE	= "datatables/buff/buff.iff";
const string SKILL_MOD_TABLE = "datatables/expertise/skill_mod_listing.iff";
const string VET_REWARDS_TABLE = "datatables/veteran_rewards/items.iff";
const string DWB_SPAWN_TABLE = "datatables/spawning/dungeon/death_watch_bunker.iff";
const string CUBE_DATATABLE_1 = "datatables/item/loot_cube/republic_assembly_tool.iff";

/********* CONSTANTS *****************************************/
//ENUMERATE THROUGH SWITCH OPTIONS
const int BADGETOOL_MENUOPTION = 0;
const int BUFFTOOL_MENUOPTION = 1;
const int QACUBE_MENUOPTION = 2;
const int CYBERNETIC_MENUOPTION = 3;
const int DMGTOOL_MENUOPTION = 4;
const int DATAPADTOOL_MENUOPTION = 5;
const int DYNAMIC_LOOTOPTION = 6;
const int XPTOOL_MENUOPTION = 7;
const int FACTIONTOOL_MENUOPTION = 8;
const int INVTOOL_MENUOPTION = 9;
const int MSTRITEMTOOL_MENUOPTION = 10;
const int NGETOOL_MENUOPTION = 11;
const int NPCFINDERTOOL_MENUOPTION = 12;
const int PET_OPTION = 13; //PETS - INCUBATOR ITEMS, LEVELING, FOODS, ETC.
const int PROFESSIONTOOL_MENUOPTION = 14;
const int QUESTTOOL_MENUOPTION = 15;
const int RESOURCETOOL_MENUOPTION = 16;
const int RESOURCE_REWARD_TOOL_MENUOPTION = 17;
const int SCRIPTTOOL_MENUOPTION = 18;
const int SPACETOOL_MENUOPTION = 19;
const int FROGTOOL_MENUOPTION = 20;
const int VETERANREWARD_MENUOPTION = 21;
const int WEAPONS_MENUOPTION = 22;
const int WEARABLESTOOL_MENUOPTION = 23;

const string QATOOL_TITLE = "/QATOOL USAGE";
const string SCRIPT_VAR	= "qatool";
const string TITLE = "QA Tools";
const string PROMPT = "Choose the tool you want to use";
const string VAR_XP_TYPES_LIST = "xp_types.list";
const string VAR_XP_TYPES_NAMES = "xp_types.names";
const string RESOURCE_TOOL_PROMPT = "This Tool will automatically spawn the space resources selected into the tester inventory.";
const string RESOURCE_TOOL_TITLE = "Resource Reward Tool";
const string RESOURCE_REWARD_TOOL_TITLE = "QA Resource Reward Tool"; //QA Reward Resource Tool
const string RESOURCE_REWARD_TOOL_PROMPT = "This tool allows testers to get resources through the Vet Reward Resource script";
const string SCRIPT_TOOL_TITLE = "QA SCRIPT TOOL";
const string SCRIPT_TOOL_PROMPT = "This tool allows the tester to view, attach and detach common QA scripts. \n\n CURRENT ATTACHED SCRIPTS:\n";
const string DATAPAD_TOOL_TITLE = "QA DATAPAD TOOL";
const string DATAPAD_TOOL_PROMPT = "This tool allows the tester to view, warp, export and import into the datapad";
const string ITEM_TOOL_TITLE = "QA MASTER ITEM TOOL";
const string ITEM_TOOL_PROMPT = "This tool allows the tester to find items such as reward armor and weapons.";
const string NGE_TOOL_TITLE = "QA NGE TOOL";
const string NGE_TOOL_PROMPT = "This tool allows the tester to attain a Respec item in their inventory.\n\nPlease select a number that will represent the level that the player character will respec to (Example: 61).";
const string PROFESSION_TOOL_TITLE = "QA PROFESSION ASSISTANT";
const string PROFESSION_TOOL_PROMPT = "This tool allows the tester to research accurate profession data without having to create a new character or force a profession change.";
const string NPCFINDER_TITLE = "NPC/Mob Finder";
const string DAMAGE_TOOL_PROMPT = "Give The amount you want to damage the target for.  This tool will cause damage in the amount you specify.  ARMOR AND OTHER MITIGATION WILL NOT BE CONSIDERED.  Use the Mitigation Tool to test Mitigation.";
const string DAMAGE_TOOL_TITLE = "DAMAGE AMOUNT";
const string MITIGATION_TOOL_PROMPT = "SELECT AN ATTACK LOCATION.\n\r\n\rThe mitigation tool tests armor mitigation based on the attacker weapon.  No actual damage is performed on the target.  Damage and mitigation is simulated using the current mitigation system (without elemental damage).  When the test is conducted a report will be exported to your client directory.";
const string MITIGATION_TOOL_TITLE = "MITIGATION TOOL";
const string QAHELPER_SCRIPTVAR = "qahelper";
const string OBJECT_FINDER_TITLE = "OBJECT FINDER";
const string DAMAGE_PID_SCRIPTVAR = "doDamage.pid";
const string DAMAGE_SCRIPTVAR = "doDamageVar";
const string HEAL_PID_SCRIPTVAR = "healDamage.pid";
const string HEAL_SCRIPTVAR = "healDamageVar";
const string HEAL_TOOL_PROMPT = "Give the amount you want to heal the target for.  This tool will heal in the amount you specify as long as it doesn't exceed the target's maximum health.";
const string HEAL_TOOL_TITLE = "HEAL AMOUNT";
const string SPECMEPOPUP = "Example: /qatool spec smu 22 rebsf bone pis.\n\nProfession:\n\nsmu\tSmuggler\nbou OR bh\tBounty Hunter\noff\t\tOfficer\ncom\tCommando\njed OR for\tForce Sensitive\nmed\tMedic\nspy\tSpy\n\n\nLevel:\n\n<any number between 1 - 90>\tHas to be a number!\n\nFaction (optional argument):\n\n<empty>\tfaction unchanged\nrebsf\tRebel Special Forces\nrebcm\tRebel Combatant\nrebol\tRebel On Leave\nimpsf\tImperial Special Forces\nimpcm\tImperial Combatant\nimpol\tImperial On Leave\nneu\tNeutral\n\n\nArmor (optional argument):\n\n<empty>\tno armor\nbone\tbasicbone armor\nsmuggler\troadmap basic only\nofficer\troadmap basic only\ncommando\troadmap basic only\nbh\troadmap basic only\nmedic\troadmap basic only\nspy\troadmap basic only\nassault_agi\nassault_sta\nassault_con\nassault_pre\nassault_lck\nbattle_agi\nbattle_sta\nbattle_con\nbattle_pre\nbattle_lck\nrecon_agi\nrecon_sta\nrecon_con\nrecon_pre\nrecon_lck\nassault_borvo\nmandalorian_imperial_white\nmandalorian_rebel_white\nmandalorian_imperial_black\nmandalorian_rebel_black\nmandalorian_imperial_red\nmandalorian_rebel_red\nmandalorian_imperial_blue\nmandalorian_rebel_blue\nmandalorian_imperial_green\nmandalorian_rebel_green\nrobe\tall Jedi robes\n\nWeapons (optional argument):\n<empty>\tno weapons\npis\t\tAll Pistols\nrif\t\tAll Rifles\ncar\t\tAll Carbines\nuna\tAll Unarmed\none\tAll One Handed\ntwo\tAll Two Handed\npol\t\tAll Polearms";
const string BUFF_TOOL_PROMPT = "Select Spacial Attack or Buff to be performed on your test character.\n\nTo remove all buffs use the command:\n\n/qatool buff clear";
const string BUFF_TOOL_TITLE = "Special Attack & Buff Tool";
const string QUEST_TOOL_TITLE = "QA Quest Tool";
const string QUEST_TOOL_PROMPT = "Select a Quest or menu item.\n\n(A) Active Quest\n(C) Completed Quest";
const string DYNAMIC_DESCRIPTION = "This tool allows a tester to spawn armor, clothing and weapons based on a selected level.  The items spawned resemble what a player would find on a mob in-game as random loot.";
const string CHU_GON_DAR_TITLE = "Chu-Gon Dar Cube Tool";
const string CHU_GON_DAR_PROMPT = "This tool allows you to quickly obtain items needed to create the items listed below.\n**If you do not have a Cube, one will be created for you.**\n\nSelect an item to create.";
const string DNA_PROMPT = "Pet Options\nChoose a category to continue.";
const string DNA_TITLE = "QA DNA Tool";

const float MINIMUM_FINDER_RADIUS_FLOAT = 10000000f;

const string_id	NEW_CITY_STRUCTURE_SUBJECT = new string_id( "city/city", "new_city_structure_subject" );
const string_id	NEW_CITY_STRUCTURE_BODY	= new string_id( "city/city", "new_city_structure_body" );

//QA TOOL PROMPT
const string[] QATOOLPROMPT = {
	" Format: /qatool <command>",
	" qabadge -- Assigns and revokes badges",
	" qawearables -- spawns clothing into your inventory",
	" buff -- provides a list of in game buffs that can be applied to the tester (also /qatool buff <buffString>)",
	" qainv -- Inventory manipulation functions",
	" qafaction -- Faction manipulation functions ",
	" qaxp - Experience tool.  Allows tester to attain expereince based on current profession.",
	"* (command driven tool) qabag -- Creates the QA bag into your inventory ",
	" qange -- Allows the tester to receive a respec token.",
	" frog -- Allows the tester to spawn character builder terminals directly into the tester inventory.",
	" qaquest -- QA version of a quest tool.  Should provide tester with a list of current quests that are yet to be completed. Allows tester to complete ground and space quests.",
	" qaprofession -- Tester can use this tool to research stats, roadmap and other data. A report can be created based off of the tool data.",
	"* (command driven tool) qalootlogger <Creature Name> <number of iterations> -- Spawns the supplied creature specified number of times and loots it, default is 25",
	" spacetool -- Allows the tester to use tools specific to Space. Also known as the JTL Tool.",
	"* (command driven tool) groundmobsearch -- Allows the tester to search the creature table ",
	"* (command driven tool) groundmoblevel <level number> -- Allows the tester to search the creature table by creature level",
	"* (command driven tool) groundmobplanet <null | planet> -- Allows the tester to search the creature table by planet",
	"* (command driven tool) spacemobsearch -- Allows the tester to search the space mobile table",
	" qaresource -- Allows the tester to spawn different types of resources ",
	" qadatapad - Allows the tester to manipulate datapad data",
	" qascript - Allows the tester to attach or detach common QA scripts without memorizing the script string",
	"* (command driven tool) lootnamesearch - Allows the tester to search for a Static Loot/Reward item by the title of the object (ex. Basic Pistol)",
	"* (command driven tool) lootcodesearch - Allows the tester to search for a Static Loot/Reward item by the staticItem code string (ex. weapon_pistol_02_01)",
	" qaitem - Allows the tester to attain armor and weapons. Also known as the Master Item Tool.",
	"* (command driven tool) kill <target>- Allows the tester to kill another tester (or themself) depending on the current target",
	"* (command driven tool) suicide - Allows the tester to kill themself instantly.",
	"* (command driven tool) spawnitem <itemCodeString> - Allows the tester to spawn a static item into their inventory.",
	" damage <mobTarget or playerTarget> - Allows the tester to damage the health of a target without entering combat with the mobile or player.",
	"* (command driven tool) heal <mobTarget or playerTarget> - Allows the tester to heal the health of a mobile or player target.",
	"* (command driven tool) aistop <mobTarget> - Allows the tester to stop a mobile so it doesn't walk around or wander off.  Once attacked, the mobile will defend itself.",
	"* (command driven tool) aifreeze <mobTarget> - Allows the tester to stop a mobile so it doesn't move even if damaged by combat.  The mobile will not attempt to fight back.",
	" npcFinder (or findNPC) - Allows the tester to look for specific mobs within the server boundaries of their current position.",
	"* (command driven tool) string [code/identifying_the_string]:string_id - Example: /qaTool string [conversation/tatooine_espa_watto]:s_106",
	"* (command driven tool) targetData - Gives tester a popup window with a target's data to include scripts, stats, scriptvars, etc. The popup itself can be edited meaning you can copy or cut from the popup to the chat UI or other applications.",
	"* (command driven tool) helper <creatureName> - Gives tester a creature with additional functionality.  Tester can instruct the test creature to carry out specific instructions in order to assist the tester in attaining a structured combat test case.",
	"* (command driven tool) objFinder <script.string.argument | template/name.iff> - Lists all objects, that have the specified template or script attached, within the server boundary in which the tester currently resides.",
	"* (command driven tool) revokepilot - Removes the test character's Pilot profession completely.",
	"* (command driven tool) spec - Allows tester to instantly change profession, level, faction, armor and weapons. Example: /qatool spec smu 22 rebsf bone pis",
	"* (command driven tool) gmr - Restores health on test character (self only).",
	"* (command driven tool) multi - Allows for multiple spawning of a static item using 2 arguments.  Example: /qatool multi item_restuss_imperial_commendation_02_01 2000",
	"* (command driven tool) entertaineritems - Spawns all entertainer instraments into tester inventory.",
	"* (command driven tool) serialize - Command that allows a crafter to simulate items from a crate.  To use this tool, create two or more of the same item and then /qatool serialize <OID> of the object to be serialized.",
	" vetreward -- Allows tester to spawn veteran rewards rapidly.",
	" qacybernetic -- Allows testers to install/uninstall/repair cybernetics without the need to find the correct NPC.",
	" qaweapon -- Allows testers to spawn weapons that have a set damage amount instead of a damage range.  This is useful in testing various special abilities and armor mitigation.",
	"* (command driven tool) questdump - Exports a text file of all test character completed/active quests to the client root directory.",
	" qa_cube -- Allows testers to obtain components needed to create items using the Chu-Gon Dar Cube.",
	"* (command driven tool) eggspawn - Forces a Yellow Spawner Egg (crown) to spawn its mobile(s) immediately.  Mobile selected is random.",
	" weather -- Allows testers to change weather locally, on their client to test effects of the environment when weather is used.",
	"* (command driven tool) spam - Pass the amount of emails you want to receive to spam your own character with emails from the email server.",
	"* (command driven tool) glow - Issues the test character a blue glowie ability Icon regardless of profession. Allows for testing Blue Glow character model.",
	"* (command driven tool) olditem - Gives tester immediate access to some of the older loot or quest items that may or may not work.",
	" qarewardresource -- Allows testers to quickly access the Resource Reward Deed interface.  From there, testers can spawn resources needed for crafting.",
	" qadna -- Creates valid DNA samples for testers.",
	" fish [n] -- Succesfully catches a fish. Optional parameter [n] = 1-100. Location is the current planet but does not test for valid fishing location.",
	" collectionclickbypass -- Sets scriptvar to allow 1 second clicks on collection items",
	"* (command driven tool) setScriptVar -- Sets a scriptvar on to 0 or a given value. If no current target then scriptvar is set on player.",
	"* (command driven tool) enzyme -- Creates an Enzyme with preset values the mutagen score and the purity score (for example /qatool enzyme 10 15).",
	"* (command driven tool) lyase or qalyase -- Creates an Lyase Enzyme with randomStats set to 11.",
	"* (command driven tool) clearHeroicTimer -- Removes all heroic lockout timers from the character",
	"* (command driven tool) iso or qaiso -- Creates an Isomerase Enzyme with a quality of 90.00.",
	"* (command driven tool) spawnShip <ship spawn string> <number of ships> -- Creates a ship in front of you.(For example: /qat spawnShip awing_tier6 3)",
	" qatcg or tcg - Brings up a menu of options for the SWG Trading Card Game"
};

//THE MAIN QA TOOL MENU SITS IN A DATATABLE. THE REASON FOR THIS IS THAT OTHER TOOLS NEED TO ACCESS THIS MENU WHEN THE BACK BUTTON IS PRESSED
const string[] QATOOL_MAIN_MENU	= dataTableGetStringColumn( "datatables/test/qa_tool_menu.iff", "main_tool" );
const string[] FACTION_TOOL_MENU =
{
	"Join a faction", "Go Covert (Combatant)",
	"Go Overt (Special Forces)",
	"Go On Leave", "Go Neutral",
	"GCW Faction Points",
	"Manipulate NPC Factions",
	"Get Factional HQ's and Supplies"
};
const string[] FS_TOOL_MENU =
{
	"FS Village Intro Quests",
	"FS Village Quests",
	"FS Village Exit Quests"
};
const string[] INVENTORY_TOOL_MENU =
{
	"Delete all in inventory",
	"Fill inventory with Junk"
};
const string[] QUEST_TOOL_MENU =
{
	"Add a ground quest manually",
	"Add a space quest manually",
	"Attain test quests",
	"Bulk Grant/Complete Tool",
	"Bulk Grant Tool"
};
const string[] JTL_TOOL_MENU =
{
	"Ship Loot Components",
	"Mining Components",
	"God Ships",
	"Valid Ship Deeds",
	"Valid Ships With Components",
	"RoTW Quest Ship Deeds",
	"Make Master Imperial Pilot",
	"Make Master Rebel Pilot",
	"Make Master Neutral Pilot",
	"Pilot Quest Tools",
	"Revoke pilot skills"
};
const string[] ENHANCEMENT_TOOL_MENU =
{
	"Armor Enhancement",
	"Clothing Enhancement",
	"Random Enhancement"
};
const string[] XP_TOOL_MENU =
{
	"Revoke non-pilot experience",
	"combat_general",
	"quest_combat",
	"quest_crafting",
	"quest_social",
	"quest_general",
	"prestige_imperial",
	"prestige_rebel",
	"prestige_pilot"
};
const string[] RESOURCE_TOOL_MENU =
{
	"Recycled Resources",
	"Space Resources",
	"Common Resources"
};
//Reward Resource Menu
const string[] REWARD_RESOURCE_MENU =
{
	"Enter Resource Menu"
};

const string[] ITEM_TOOL_MENU =
{
	"Armor",
	"Best Weapons",
	"Get all Certified Weapons",
	"Get Roadmap Items",
	"List Every Item by Category"
};
const string[] SCRIPT_TOOL_MENU	=
{
	"Attach Script",
	"Detach Script"
};
const string[] NGE_TOOL_MENU =
{
	"Make CU Profession",
	"Get Respec Token"
};
const string[] SCRIPT_TOOL_COMMON_SCRIPTS =
{
	"csr.get_resource_crate",
	"working.dantest",
	"player.player_gm",
	"gm.cmd",
	"e3demo.e3_demoer",
	"player.yavin_e3",
	"space.content_tools.missiontest",
	"space.content_tools.content_generation",
	"quest.utility.quest_test",
	"test.ttyson_test",
	"test.qatool",
	"test.qa_enhancements",
	"test.qa_jtl_tools",
	"test.qa_quest_skipper",
	"test.qa_resources",
	"test.qabadge",
	"test.qabuff",
	"test.qafaction",
	"test.qainventory",
	"test.qascript",
	"test.qawearables",
	"test.qaxp",
	"test.qadatapad",
	"test.qaitem",
	"test.qange",
	"test.qaprofession",
	"test.qa_damage",
	"test.qa_helper",
	"test.qa_dynamics",
	"test.qaham",
	"test.qa_resource_reward",
	"test.qadna"
};
const string[] DATAPAD_TOOL_MENU =
{
	"Warp to Waypoints",
	"Export Waypoints"
};
const string[] PROFESSION_TOOL_MENU =
{
	"Abilities Alphabetically",
	"Profession Details",
	"Export Profession Details"
};
const string[] MOB_STRING_FILE_POSSIBILITIES =
{
	"mob/creature_names",
	"npc_name",
	"droid_name",
	"monster_name",
	"npc_spawner_n",
	"theme_park_name",
	"ep3/npc_names"
};
const string[] NPCFINDER_ERR_ARRAY =
{
	"No Mob/NPC Found"
};

//THERE ARE NO MORE HIT LOCATIONS!!
const string[] MITIGATION_HIT_LOCATIONS =
{
	"Body",
	"Head",
	"Right Arm",
	"Left Arm",
	"Right Leg",
	"Left Leg"
};

const string[] WEAPON_DAMAGE_TYPE =
{
	"DAMAGE_NONE",
	"DAMAGE_KINETIC",
	"DAMAGE_ENERGY",
	"DAMAGE_BLAST",
	"DAMAGE_STUN",
	"DAMAGE_RESTRAINT",
	"DAMAGE_ELEMENTAL_HEAT",
	"DAMAGE_ELEMENTAL_COLD",
	"DAMAGE_ELEMENTAL_ACID",
	"DAMAGE_ELEMENTAL_ELECTRICAL",
	"DAMAGE_ENVIRONMENTAL_HEAT",
	"DAMAGE_ENVIRONMENTAL_COLD",
	"DAMAGE_ENVIRONMENTAL_ACID",
	"DAMAGE_ENVIRONMENTAL_ELECTRICAL"
};

const string[] PROFESSION_SKILL_NAMES =
{
	"_phase1_novice",
	"_phase1_02",
	"_phase1_03",
	"_phase1_04",
	"_phase1_05",
	"_phase1_master",
	"_phase2_novice",
	"_phase2_02",
	"_phase2_03",
	"_phase2_04",
	"_phase2_05",
	"_phase2_master",
	"_phase3_novice",
	"_phase3_02",
	"_phase3_03",
	"_phase3_04",
	"_phase3_05",
	"_phase3_master",
	"_phase4_novice",
	"_phase4_02",
	"_phase4_03",
	"_phase4_04",
	"_phase4_05",
	"_phase4_master"
};

const string[] PROFESSION_PREFIX =
{
	"class_smuggler",
	"class_bountyhunter",
	"class_officer",
	"class_commando",
	"class_forcesensitive",
	"class_medic",
	"class_spy"
};

const string[] PET_OPTION_MENU =
{
	"Access DNA Samples",
	"Future Pet Options"
};

const string[][] MISC_SEARCH_MULTIARRAY =
{
	{
		"robe"		//all jedi robes from master item table
	}
	,
	{
		"item_jedi_robe_"
	}
};

const string[][] WEAPON_SEARCH_MULTIARRAY =
{
	{
	"pis",				//All Pistols
	"rif",				//All Rifles
	"car",				//All Carbines
	"una",				//All Unarmed
	"one",				//All One Handed
	"two",				//All Two Handed
	"pol"				//All Polearms
	}
	,
	{
	"weapon_pistol_",
	"weapon_rifle_",
	"weapon_carbine_",
	"weapon_unarmed_",
	"weapon_sword_1h_",
	"weapon_sword_2h_",
	"weapon_polearm_"
	},
};

const string[][] ARMOR_SEARCH_MULTIARRAY =
{
	{
	"bone", 			//basic only
	"smuggler",			//roadmap basic only
	"officer",			//roadmap basic only
	"commando",			//roadmap basic only
	"bh",				//roadmap basic only
	"medic",			//roadmap basic only
	"spy",				//roadmap basic only
	"assault_agi",			//lvl80 advanced
	"assault_sta",			//lvl80 advanced
	"assault_con",			//lvl80 advanced
	"assault_pre",			//lvl80 advanced
	"assault_lck",			//lvl80 advanced
	"battle_agi",			//lvl80 advanced
	"battle_sta",			//lvl80 advanced
	"battle_con",			//lvl80 advanced
	"battle_pre",			//lvl80 advanced
	"battle_lck",			//lvl80 advanced
	"recon_agi",			//lvl80 advanced
	"recon_sta",			//lvl80 advanced
	"recon_con",			//lvl80 advanced
	"recon_pre",			//lvl80 advanced
	"recon_lck",			//lvl80 advanced
	"assault_borvo",		//standard
	"mandalorian_imperial_white",	//advanced
	"mandalorian_rebel_white",	//advanced
	"mandalorian_imperial_black",	//advanced
	"mandalorian_rebel_black",	//advanced
	"mandalorian_imperial_red",	//advanced
	"mandalorian_rebel_red",	//advanced
	"mandalorian_imperial_blue",	//advanced
	"mandalorian_rebel_blue",	//advanced
	"mandalorian_imperial_green",	//advanced
	"mandalorian_rebel_green"	//advanced
	}
	,
	{
	"armor_bone_",
	"armor_smuggler_roadmap_",
	"armor_officer_roadmap_",
	"armor_commando_roadmap_",
	"armor_bounty_hunter_",
	"armor_medic_roadmap_",
	"armor_spy_roadmap_",
	"armor_assault_agi_lvl80_",
	"armor_assault_sta_lvl80_",
	"armor_assault_con_lvl80_",
	"armor_assault_pre_lvl80_",
	"armor_assault_lck_lvl80_",
	"armor_battle_agi_lvl80_",
	"armor_battle_sta_lvl80_",
	"armor_battle_con_lvl80_",
	"armor_battle_pre_lvl80_",
	"armor_battle_lck_lvl80_",
	"armor_recon_agi_lvl80_",
	"armor_recon_sta_lvl80_",
	"armor_recon_con_lvl80_",
	"armor_recon_pre_lvl80_",
	"armor_recon_lck_lvl80_",
	"armor_assault_borvo_acklay_",
	"armor_mandalorian_imperial_white_",
	"armor_mandalorian_rebel_white_",
	"armor_mandalorian_imperial_black_",
	"armor_mandalorian_rebel_black_",
	"armor_mandalorian_imperial_red_",
	"armor_mandalorian_rebel_red_",
	"armor_mandalorian_imperial_blue_",
	"armor_mandalorian_rebel_blue_",
	"armor_mandalorian_imperial_green_",
	"armor_mandalorian_rebel_green_"
	}
};

const string[] ENTERTAINER_ITEMS =
{
	"object/tangible/component/instrument/dual_wave_synthesizer.iff",
	"object/tangible/instrument/bandfill.iff",
	"object/tangible/instrument/fanfar.iff",
	"object/tangible/instrument/fizz.iff",
	"object/tangible/instrument/flute_droopy.iff",
	"object/tangible/instrument/kloo_horn.iff",
	"object/tangible/instrument/mandoviol.iff",
	"object/tangible/instrument/nalargon.iff",
	"object/tangible/instrument/ommni_box.iff",
	"object/tangible/instrument/slitherhorn.iff",
	"object/tangible/instrument/traz.iff",
	"object/tangible/dance_prop/generic_must_prop_baton_01_l.iff",
	"object/tangible/dance_prop/generic_must_prop_baton_01_r.iff",
	"object/tangible/dance_prop/generic_must_prop_baton_02_l.iff",
	"object/tangible/dance_prop/generic_must_prop_baton_02_r.iff",
	"object/tangible/dance_prop/generic_must_prop_baton_03_r.iff",
	"object/tangible/dance_prop/generic_must_prop_baton_04_l.iff",
	"object/tangible/dance_prop/generic_must_prop_baton_04_r.iff",
	"object/tangible/dance_prop/generic_prop_ribbon_spark_r.iff",
	"object/tangible/dance_prop/generic_prop_sparkler_l.iff",
	"object/tangible/dance_prop/prop_double_ribbon_l.iff",
	"object/tangible/dance_prop/prop_double_ribbon_magic_l.iff",
	"object/tangible/dance_prop/prop_double_ribbon_magic_r.iff",
	"object/tangible/dance_prop/prop_double_ribbon_r.iff",
	"object/tangible/dance_prop/prop_double_ribbon_spark_l.iff",
	"object/tangible/dance_prop/prop_double_ribbon_spark_r.iff",
	"object/tangible/dance_prop/prop_glowstick_l.iff",
	"object/tangible/dance_prop/prop_glowstick_r.iff",
	"object/tangible/dance_prop/prop_ribbon_l.iff",
	"object/tangible/dance_prop/prop_ribbon_magic_l.iff",
	"object/tangible/dance_prop/prop_ribbon_magic_r.iff",
	"object/tangible/dance_prop/prop_ribbon_r.iff",
	"object/tangible/dance_prop/prop_ribbon_spark_l.iff",
	"object/tangible/dance_prop/prop_ribbon_spark_r.iff",
	"object/tangible/dance_prop/prop_sparkler_l.iff",
	"object/tangible/dance_prop/prop_sparkler_r.iff",
	"object/tangible/dance_prop/prop_staff_l.iff",
	"object/tangible/dance_prop/prop_staff_r.iff",
	"object/tangible/dance_prop/prop_sword_l.iff",
	"object/tangible/dance_prop/prop_sword_r.iff",
	"object/tangible/dance_prop/prop_torch_l.iff",
	"object/tangible/dance_prop/prop_torch_r.iff"
};

//banks and bazaars will not work when spawned in inventory
const string[] TERMINAL_LIST =
{
	"object/tangible/terminal/terminal_mission_artisan.iff",
	"object/tangible/terminal/terminal_mission_entertainer.iff",
	"object/tangible/terminal/terminal_mission_bounty.iff",
	"object/tangible/terminal/terminal_mission.iff",
	"object/tangible/terminal/terminal_mission_scout.iff"
};

const string[] DATA_SOURCE_MENU_LIST =
{
	"spawn dynamic armor",
	"spawn dynamic clothing",
	"spawn dynamic weapons"
};

const string[] ADD_ON_DATAPAD_MENU =
{
	"FILL WAYPOINTS",
	"CLEAR ALL WAYPOINTS"
};

const string[] CYBER_MENU_LIST =
{
	"Install",
	"Uninstall",
	"Repair"
};

const string[] WEAPON_TYPE =
{
	"Pistol",
	"Carbine",
	"Rifle",
	"Unarmed",
	"1-Handed",
	"2-Handed",
	"Polearm",
	"Heavy Weapon",
	"Flame Thrower"
};

const string[] WEATHER_TYPES =
{
	"Clear",
	"Mild",
	"Heavy",
	"Severe"
};

const string[] CONTRABAND_STRINGS =
{
	"item_smuggler_contraband_01_01",
	"item_smuggler_contraband_01_02",
	"item_smuggler_contraband_01_03",
	"item_smuggler_contraband_01_04",
	"item_smuggler_contraband_01_05",
	"item_smuggler_contraband_02_01",
	"item_smuggler_contraband_02_02",
	"item_smuggler_contraband_02_03",
	"item_smuggler_contraband_02_04",
	"item_smuggler_contraband_02_05",
	"item_smuggler_contraband_03_01",
	"item_smuggler_contraband_03_02",
	"item_smuggler_contraband_03_03",
	"item_smuggler_contraband_03_04",
	"item_smuggler_contraband_03_05",
	"item_smuggler_contraband_04_01",
	"item_smuggler_contraband_04_02",
	"item_smuggler_contraband_04_03",
	"item_smuggler_contraband_04_04",
	"item_smuggler_contraband_04_05",
	"item_smuggler_contraband_05_01",
	"item_smuggler_contraband_05_02",
	"item_smuggler_contraband_05_03",
	"item_smuggler_contraband_05_04",
	"item_smuggler_contraband_05_05"
};

const string[] OLD_ITEM_MENU =
{
	"Old FS Village Rewards",
	"Hero of Tatooine",
	"Death Watch Bunker Loot",
	"Old Skill Buff Items",
	"Crafting Components",
	"Varactyl Egg and Treasure Map",
	"Loot Schematics"
};

const string[] OLD_FS_VILLAGE_ITEMS =
{
	"object/tangible/item/quest/force_sensitive/bacta_tank.iff",
	"object/tangible/wearables/necklace/necklace_ice_pendant.iff",
	"object/tangible/item/quest/force_sensitive/fs_village_bannerpole_s01.iff",
	"object/tangible/item/quest/force_sensitive/fs_sculpture_2.iff",
	"object/tangible/item/quest/force_sensitive/fs_buff_item.iff",
	"object/tangible/loot/quest/force_sensitive/force_crystal.iff",
	"object/tangible/loot/plant_grow/plant_stage_1.iff",
	"object/tangible/loot/plant_grow/plant_stage_2.iff",
	"object/tangible/loot/plant_grow/plant_stage_3.iff",
	"object/tangible/loot/plant_grow/plant_stage_dead.iff",
	"object/tangible/item/plant/force_melon.iff"
};

const string[] HERO_OF_TATOOINE_ITEMS =
{
	"object/tangible/loot/quest/hero_of_tatooine/squill_skull.iff",
	"object/tangible/loot/quest/hero_of_tatooine/mark_altruism.iff",
	"object/tangible/loot/quest/hero_of_tatooine/squill_skull_pile.iff",
	"object/tangible/loot/quest/hero_of_tatooine/squill_skull.iff",
	"object/tangible/loot/quest/hero_of_tatooine/mark_intellect.iff",
	"object/tangible/loot/quest/hero_of_tatooine/mark_honor.iff",
	"object/tangible/loot/quest/hero_of_tatooine/mark_courage.iff"
};

const string[] DEATH_WATCH_BUNKER_ITEMS =
{
	"object/tangible/loot/dungeon/death_watch_bunker/pistol_de10_barrel.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/mining_drill_reward.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/binary_liquid.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/art_crate.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/blood_vial.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/ducted_fan.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/emulsion_protection.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/fuel_dispersion_unit.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/fuel_injector_tank.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/jetpack_base.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/jetpack_stabilizer.iff",
	"object/tangible/loot/tool/usable_datapad.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/viewscreen_s1.iff",
	"object/tangible/loot/dungeon/death_watch_bunker/viewscreen_s2.iff"
};

const string[] OLD_SKILL_BUFF_ITEMS =
{
	"object/tangible/skill_buff/skill_buff_carbine_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_carbine_speed.iff",
	"object/tangible/skill_buff/skill_buff_heavy_weapon_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_heavy_weapon_speed.iff",
	"object/tangible/skill_buff/skill_buff_mask_scent.iff",
	"object/tangible/skill_buff/skill_buff_melee_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_melee_defense.iff",
	"object/tangible/skill_buff/skill_buff_onehandmelee_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_onehandmelee_speed.iff",
	"object/tangible/skill_buff/skill_buff_pistol_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_pistol_speed.iff",
	"object/tangible/skill_buff/skill_buff_polearm_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_polearm_speed.iff",
	"object/tangible/skill_buff/skill_buff_ranged_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_ranged_defense.iff",
	"object/tangible/skill_buff/skill_buff_rifle_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_rifle_speed.iff",
	"object/tangible/skill_buff/skill_buff_thrown_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_thrown_speed.iff",
	"object/tangible/skill_buff/skill_buff_twohandmelee_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_twohandmelee_speed.iff",
	"object/tangible/skill_buff/skill_buff_unarmed_accuracy.iff",
	"object/tangible/skill_buff/skill_buff_unarmed_speed.iff"
};

const string[] CRAFTING_COMPONENTS =
{
	"object/tangible/component/armor/armor_core_assault_advanced.iff",
	"object/tangible/component/armor/armor_core_assault_basic.iff",
	"object/tangible/component/armor/armor_core_battle_advanced.iff",
	"object/tangible/component/armor/armor_core_battle_standard.iff",
	"object/tangible/component/armor/armor_core_recon_advanced.iff",
	"object/tangible/component/armor/bone_fragment_woolamander_harrower.iff",
	"object/tangible/component/armor/hide_gurk_king.iff",
	"object/tangible/component/armor/scale_giant_dune_kimogila.iff",
	"object/tangible/component/chemistry/biologic_effect_controller.iff",
	"object/tangible/component/chemistry/dispersal_mechanism.iff",
	"object/tangible/component/chemistry/infection_amplifier.iff",
	"object/tangible/component/chemistry/janta_blood.iff",
	"object/tangible/component/chemistry/liquid_delivery_suspension.iff",
	"object/tangible/component/chemistry/rancor_bile.iff",
	"object/tangible/component/chemistry/release_mechanism_duration.iff",
	"object/tangible/component/chemistry/resilience_compound.iff",
	"object/tangible/component/chemistry/solid_delivery_shell.iff",
	"object/tangible/component/clothing/clasp_heavy_duty.iff",
	"object/tangible/component/clothing/clothing_treatment_crystalline.iff",
	"object/tangible/component/clothing/leather_heavy_duty.iff",
	"object/tangible/component/munition/kliknick_gland.iff",
	"object/tangible/component/weapon/blaster_power_handler_enhancement_bounty.iff",
	"object/tangible/component/weapon/blaster_power_handler_enhancement_durability.iff",
	"object/tangible/component/weapon/blaster_power_handler_enhancement_max_damage.iff",
	"object/tangible/component/weapon/blaster_power_handler_enhancement_min_damage.iff",
	"object/tangible/component/weapon/blaster_rifle_barrel.iff",
	"object/tangible/component/weapon/projectile_feed_mechanism_enhancement_bounty.iff",
	"object/tangible/component/weapon/projectile_feed_mechanism_enhancement_durability.iff",
	"object/tangible/component/weapon/projectile_feed_mechanism_enhancement_gorax.iff",
	"object/tangible/component/weapon/projectile_feed_mechanism_enhancement_max_damage.iff",
	"object/tangible/component/weapon/projectile_feed_mechanism_enhancement_min_damage.iff",
	"object/tangible/component/weapon/projectile_rifle_barrel.iff",
	"object/tangible/component/weapon/scope_weapon_advanced.iff",
	"object/tangible/component/weapon/stock_advanced.iff",
	"object/tangible/component/weapon/vibro_unit_enhancement_durability.iff",
	"object/tangible/component/weapon/vibro_unit_enhancement_max_damage.iff",
	"object/tangible/component/weapon/vibro_unit_enhancement_min_damage.iff",
	"object/tangible/component/weapon/vibro_unit_enhancement_wounding.iff",
	"object/tangible/loot/quest/ep3/varactyl_egg.iff",
	"object/tangible/treasure_map/treasure_map_base.iff",
	"object/tangible/component/weapon/vibro_unit_nightsister.iff"
};

const string[] VARACTYL_TREASURE_ITEMS =
{
	"object/tangible/loot/quest/ep3/varactyl_egg.iff",
	"object/tangible/treasure_map/treasure_map_base.iff"
};

const string[] LOOT_SCHEMATICS =
{
	"object/tangible/loot/quest/schematic_republic_blaster_quest.iff",
	"object/tangible/loot/quest/2h_sword_scythe_schematic.iff",
	"object/tangible/loot/loot_schematic/agitator_motor_schematic.iff",
	"object/tangible/loot/loot_schematic/assorted_fruit_schematic.iff",
	"object/tangible/loot/loot_schematic/bacta_tank_schematic.iff",
	"object/tangible/loot/loot_schematic/basket_closed_schematic.iff",
	"object/tangible/loot/loot_schematic/bottle_fat_schematic.iff",
	"object/tangible/loot/loot_schematic/bottle_pear_schematic.iff",
	"object/tangible/loot/loot_schematic/bottle_tall_schematic.iff",
	"object/tangible/loot/loot_schematic/bowl_carved_schematic.iff",
	"object/tangible/loot/loot_schematic/bowl_plain_schematic.iff",
	"object/tangible/loot/loot_schematic/bubble_tank_schematic.iff",
	"object/tangible/loot/loot_schematic/cabinet_elegant_schematic.iff",
	"object/tangible/loot/loot_schematic/campfire_schematic.iff",
	"object/tangible/loot/loot_schematic/cantina_chair_schematic.iff",
	"object/tangible/loot/loot_schematic/chair_cafe_schematic.iff",
	"object/tangible/loot/loot_schematic/chemical_recycler_schematic.iff",
	"object/tangible/loot/loot_schematic/command_console_schematic.iff",
	"object/tangible/loot/loot_schematic/corellian_corvette_landspeeder_av21_schematic.iff",
	"object/tangible/loot/loot_schematic/corellian_corvette_rifle_berserker_schematic.iff",
	"object/tangible/loot/loot_schematic/corellian_flagpole_schematic.iff",
	"object/tangible/loot/loot_schematic/couch_blue_schematic.iff",
	"object/tangible/loot/loot_schematic/creature_recycler_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_belt_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_bicep_l_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_bicep_r_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_boots_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_bracer_l_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_bracer_r_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_chest_plate_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_gloves_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_helmet_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_bounty_hunter_leggings_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_drink_mandalorian_wine_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_executioners_hack_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_belt_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_bicep_l_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_bicep_r_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_boots_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_bracer_l_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_bracer_r_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_chest_plate_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_gloves_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_helmet_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_jetpack_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_mandalorian_leggings_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_pistol_de_10_schematic.iff",
	"object/tangible/loot/loot_schematic/death_watch_razor_knuckler_schematic.iff",
	"object/tangible/loot/loot_schematic/diagnostic_screen_schematic.iff",
	"object/tangible/loot/loot_schematic/droid_body_schematic.iff",
	"object/tangible/loot/loot_schematic/droid_head_schematic.iff",
	"object/tangible/loot/loot_schematic/flora_recycler_schematic.iff",
	"object/tangible/loot/loot_schematic/foodcart_schematic.iff",
	"object/tangible/loot/loot_schematic/gambling_table_schematic.iff",
	"object/tangible/loot/loot_schematic/generic_limited_use.iff",
	"object/tangible/loot/loot_schematic/generic_limited_use_flashy.iff",
	"object/tangible/loot/loot_schematic/generic_vehicle.iff",
	"object/tangible/loot/loot_schematic/geonosian_acklay_bone_armor_schematic.iff",
	"object/tangible/loot/loot_schematic/geonosian_acklay_muscle_armor_schematic.iff",
	"object/tangible/loot/loot_schematic/geonosian_reinforcement_core_schematic.iff",
	"object/tangible/loot/loot_schematic/geonosian_sonic_blaster_schematic.iff",
	"object/tangible/loot/loot_schematic/geonosian_sword_core_schematic.iff",
	"object/tangible/loot/loot_schematic/geonosian_tenloss_dxr6_schematic.iff",
	"object/tangible/loot/loot_schematic/hanging_planter_schematic.iff",
	"object/tangible/loot/loot_schematic/metal_recycler_schematic.iff",
	"object/tangible/loot/loot_schematic/microphone_s01_schematic.iff",
	"object/tangible/loot/loot_schematic/microphone_s02_schematic.iff",
	"object/tangible/loot/loot_schematic/ore_recycler_schematic.iff",
	"object/tangible/loot/loot_schematic/park_bench_schematic.iff",
	"object/tangible/loot/loot_schematic/pitcher_full_schematic.iff",
	"object/tangible/loot/loot_schematic/professors_desk_schematic.iff",
	"object/tangible/loot/loot_schematic/radar_screen_schematic.iff",
	"object/tangible/loot/loot_schematic/radio_schematic.iff",
	"object/tangible/loot/loot_schematic/shisa_schematic.iff",
	"object/tangible/loot/loot_schematic/slave_brazier_schematic.iff",
	"object/tangible/loot/loot_schematic/spear_rack_schematic.iff",
	"object/tangible/loot/loot_schematic/speeder_desert_skiff_schematic.iff",
	"object/tangible/loot/loot_schematic/speeder_usv5_schematic.iff",
	"object/tangible/loot/loot_schematic/stove_schematic.iff",
	"object/tangible/loot/loot_schematic/streetlamp_schematic.iff",
	"object/tangible/loot/loot_schematic/stuffed_fish_schematic.iff",
	"object/tangible/loot/loot_schematic/table_coffee_modern_schematic.iff",
	"object/tangible/loot/loot_schematic/tanning_hide_s01_schematic.iff",
	"object/tangible/loot/loot_schematic/tanning_hide_s02_schematic.iff",
	"object/tangible/loot/loot_schematic/tatooine_tapestry_schematic.iff",
	"object/tangible/loot/loot_schematic/technical_console_s01_schematic.iff",
	"object/tangible/loot/loot_schematic/technical_console_s02_schematic.iff",
	"object/tangible/loot/loot_schematic/throwpillow_schematic.iff",
	"object/tangible/loot/loot_schematic/trandoshan_hunter_rifle_schematic.iff",
	"object/tangible/loot/loot_schematic/tumble_blender_schematic.iff",
	"object/tangible/loot/loot_schematic/utensils_schematic.iff"
};

const string[] TCG_MENU =
{
	"Generate Drop",
	"TCG Info Flag",
	"TCG Always Drop",
	"Card Cluster Information",
	"Promotional Items Cluster Info",
	"Reinitialize TCG Information (warning! this resets everything!)"
};

/********* Triggers ******************************************/
trigger OnAttach()
{
	if(isGod(self))
	{
		if(getGodLevel(self) < 10)
		{
			detachScript(self, "test.qatool");
			sendSystemMessage(self, "You do not have the appropriate access level to use this script.", null);
		}
		else
		{
			//sendSystemMessageTestingOnly(self, "Scripts attached.");

			attachScript(self, "test.qabuff");
			attachScript(self, "test.qawearables");
			attachScript(self, "test.qa_quest_skipper");
			attachScript(self, "test.qabadge");
			attachScript(self, "test.qainventory");
			attachScript(self, "test.qafaction");
			attachScript(self, "test.qaxp");
			attachScript(self, "test.qa_jtl_tools");
			attachScript(self, "test.qa_resources");
			attachScript(self, "test.qascript");
			attachScript(self, "test.qadatapad");
			attachScript(self, "test.qaitem");
			attachScript(self, "test.qange");
			attachScript(self, "test.qaprofession");
			attachScript(self, "test.qa_damage");
			attachScript(self, "test.qa_helper");
			attachScript(self, "test.qa_dynamic");
			attachScript(self, "test.qa_cybernetic");
			attachScript(self, "test.qaweapon");
			attachScript(self, "test.qa_cube");
			attachScript(self, "test.qa_resource_reward"); // veteran reward resource tool
			attachScript(self, "test.qadna");

			grantSkill(self, "swg_dev");  // swg dev tag -
			sendSystemMessageTestingOnly(self, "You can access the \"SWG Developer\" title by opening your Community options.");

		}
	}
	else
	{
		detachScript(self, "test.qatool");
	}
	return SCRIPT_CONTINUE;
}

trigger OnDetach()
{
	//sendSystemMessageTestingOnly(self, "Scripts detached.");
	detachScript(self, "test.qabuff");
	detachScript(self, "test.qafstool");
	detachScript(self, "test.qawearables");
	detachScript(self, "test.qa_quest_skipper");
	detachScript(self, "test.qacraftable_loot_spawner");
	detachScript(self, "test.qabadge");
	detachScript(self, "test.qainventory");
	detachScript(self, "test.qafaction");
	detachScript(self, "test.qaxp");
	detachScript(self, "test.qa_jtl_tools");
	detachScript(self, "test.qa_enhancements");
	detachScript(self, "test.qa_resources");
	detachScript(self, "test.qascript");
	detachScript(self, "test.qadatapad");
	detachScript(self, "test.qaitem");
	detachScript(self, "test.qange");
	detachScript(self, "test.mitigation");
	detachScript(self, "test.qa_damage");
	detachScript(self, "test.qaprofession");
	detachScript(self, "test.qa_helper");
	detachScript(self, "test.qa_dynamic");
	detachScript(self, "test.qa_cybernetic");
	detachScript(self, "test.qaweapon");
	detachScript(self, "test.qa_cube");
	detachScript(self, "test.qa_resource_reward");// veteran reward resource tool
	detachScript(self, "test.qadna");
	revokeSkillSilent(self, "swg_dev");

	return SCRIPT_CONTINUE;
}

messageHandler vetRewardOptionHandler()
{
	if(isGod(self))
	{
		//sendSystemMessageTestingOnly(self, "vetRewardOptionHandler");

		if(utils.hasScriptVar(self, "vetreward.pid"))
		{
			//sendSystemMessageTestingOnly(self, "vetRewardOptionHandler2");
			qa.checkParams(params, "vetreward");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);
			//sendSystemMessageTestingOnly(self, "vetRewardOptionHandler3");

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "vetreward.allTemplates" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{

				string previousSelection = previousMainMenuArray[idx];
				//sendSystemMessageTestingOnly(self, previousSelection);

				qa.templateObjectSpawner(self, previousSelection);

				string[] allRewardTemplates = dataTableGetStringColumn(VET_REWARDS_TABLE, "Object Template");
				Arrays.sort(allRewardTemplates);
				qa.refreshMenu(self, "The list below shows veteran rewards available", "Vet Reward Tool", allRewardTemplates, "vetRewardOptionHandler",true, "vetreward.pid", "vetreward.allTemplates");

			}
		}
	}
	return SCRIPT_CONTINUE;
}

/********* Command Handlers **********************************/

commandHandler cmdQaTool()
{
	if(isGod(self))
	{
		StringTokenizer st = new java.util.StringTokenizer(params);
		int tokens = st.countTokens();
		string command = "";
		if (st.hasMoreTokens())
			command = st.nextToken();

		utils.setScriptVar(self, SCRIPT_VAR+".toolMainMenu", QATOOL_MAIN_MENU);
		utils.setScriptVar(self, SCRIPT_VAR+".title", TITLE);
		utils.setScriptVar(self, SCRIPT_VAR+".prompt", PROMPT);

		if(command == "")
		{
			qa.refreshMenu( self, PROMPT, TITLE, QATOOL_MAIN_MENU, "toolMainMenu", true, SCRIPT_VAR+".pid");
			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("setscriptvar"))
		{
			qaSetScriptVar(self, st);
			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("collectionclickbypass"))
		{
			cleanAllScriptVars(self);
			qaEnableCollectionClickBypass(self, st, "none");
			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("fish") || toLower(command).equals("fishing") || toLower(command).equals("qafish"))
		{
			//qatool fish	(catches a fish)
			//qatool fish 100 (catches 100 fish)

			cleanAllScriptVars(self);
			qaFishing(self, st, "none");
			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("testtreasure") || toLower(command).equals("treasuretest"))
		{
			if (!st.hasMoreTokens())
			{
				sendSystemMessageTestingOnly(self, "Usage: /qatool testtreasure treasure/treasure_1_10 or /qatool testtreasure treasure/treasure_11_20, etc.");
				return SCRIPT_CONTINUE;
			}
			else
			{
				string lootTable = st.nextToken();
				//string treasureLevel = st.nextToken();
				if(lootTable == null || lootTable == "")
				{
					sendSystemMessageTestingOnly(self, "Usage: /qatool testtreasure treasure/treasure_1_10 or /qatool testtreasure treasure/treasure_11_20, etc.");
					return SCRIPT_CONTINUE;
				}
				int tableMaxLevel = lootTable.lastIndexOf("_") + 1;
				if(tableMaxLevel < 0)
				{
					sendSystemMessageTestingOnly(self, "Usage: /qatool testtreasure treasure/treasure_1_10 or /qatool testtreasure treasure/treasure_11_20, etc.");
					return SCRIPT_CONTINUE;
				}

				string treasureLevel = lootTable.substring(tableMaxLevel);
				int intTreasureLevel = utils.stringToInt(treasureLevel);
				if(intTreasureLevel < 10 || intTreasureLevel > 90)
				{
					sendSystemMessageTestingOnly(self, "Usage: /qatool testtreasure treasure/treasure_1_10 or /qatool testtreasure treasure/treasure_11_20, etc.");
					return SCRIPT_CONTINUE;
				}

				location treasureLoc = getLocation(self);
				if(treasureLoc == null)
					return SCRIPT_CONTINUE;
				obj_id treasureChest = createObject("object/tangible/container/drum/treasure_drum.iff", treasureLoc);
				if(!isValidId(treasureChest) && !exists(treasureChest))
					return SCRIPT_CONTINUE;
				boolean success = loot.makeLootInContainer(treasureChest, lootTable, 6, intTreasureLevel);
				if(!success)
				{
					sendSystemMessageTestingOnly(self, "Text export failed.");
					return SCRIPT_CONTINUE;
				}
				obj_id contents[] = getContents(treasureChest);
				string listcontents = "";
				if (contents.length > 0)
				{
					for (int i = 0; i < contents.length; i++)
					{
						listcontents += "(" +contents[i] + ")" + getTemplateName(contents[i]) + "\r";
					}
				}
				if(listcontents != "")
					saveTextOnClient(self, "treasure" + treasureChest + ".txt", listcontents);

				dictionary treasureDictionary = new dictionary();
				treasureDictionary.put("object", treasureChest);
				messageTo(self, "qaDestroyObject", treasureDictionary, 600, false);

			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("olditems") || toLower(command).equals("olditem"))
		{
			if (OLD_ITEM_MENU.length > 0)
			{
				qa.refreshMenu(self, "Select a old item category.", "Old Item Spawner. DO NOT BUG ITEMS SPAWNED WITH THIS TOOL!!! DO NOT BUG ITEMS SPAWNED WITH THIS TOOL!!! DO NOT BUG ITEMS SPAWNED WITH THIS TOOL!!! ", OLD_ITEM_MENU, "oldItemMenuHandler",true, "oldItem.pid", "oldItem.menu");
			}
			return SCRIPT_CONTINUE;
		}

		else if (toLower(command).equals("glow"))
		{
			grantCommand(self, "blueGlowie");
			return SCRIPT_OVERRIDE;
		}

		else if (toLower(command).equals("emailspam") || toLower(command).equals("spamemail") || toLower(command).equals("spam"))
		{
			emailSpamFunction(self, st);
			return SCRIPT_OVERRIDE;
		}

		else if (toLower(command).equals("terminal"))
		{
			for(int i = 0; i < TERMINAL_LIST.length; i++)
			{
				obj_id terminalId = qa.templateObjectSpawner(self, TERMINAL_LIST[i], true);
			}
			sendSystemMessageTestingOnly(self, "Terminals Spawned.");

			return SCRIPT_OVERRIDE;
		}

		else if (toLower(command).equals("eggspawn") || toLower(command).equals("eggspawner") || toLower(command).equals("spawnegg") || toLower(command).equals("spawn"))
		{
			qa.forceEggSpawn(self);
			return SCRIPT_OVERRIDE;
		}

		else if (toLower(command).equals("weather"))
		{
			qa.refreshMenu(self, "Select weather type.", "Weather Tool", WEATHER_TYPES, "msgHandleWeatherSelection", true, "weather.pid", "weather.list" );
			return SCRIPT_OVERRIDE;
		}

		else if (toLower(command).equals("qaquestdump") || toLower(command).equals("questdump"))
		{
			//Function to dump all quest data to the client
			saveAllCurrentQuestData(self);
			return SCRIPT_OVERRIDE;
		}

		else if(toLower(command).equals("vetrewards") || toLower(command).equals("vetreward"))
		{
			string[] allRewardTemplates = dataTableGetStringColumn(VET_REWARDS_TABLE, "Object Template");
			Arrays.sort(allRewardTemplates);

			if (allRewardTemplates.length > 0)
			{
				qa.refreshMenu(self, "The list below shows veteran rewards available", "Vet Reward Tool", allRewardTemplates, "vetRewardOptionHandler",true, "vetreward.pid", "vetreward.allTemplates");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("serialize"))
		{
			try
			{
				string serialCommand = st.nextToken();
				if(serialCommand != "" || serialCommand != null)
				{
					obj_id item = utils.stringToObjId(serialCommand);
					if(!isIdValid(item))
					{
						sendSystemMessageTestingOnly(self, "To serialize an item you need to specify a valid OID.");
						return SCRIPT_CONTINUE;
					}
					else
					{
						setCraftedId(item, utils.getInventoryContainer(self));
						setCrafter(item, self);
						sendSystemMessageTestingOnly(self, "Item " + item + " has been serialized.");
					}
				}
			}
			catch(Exception e)
			{
				sendSystemMessageTestingOnly(self, "You need to specify the object Id of the object you want to be serialized.");
				sendSystemMessageTestingOnly(self, "/qatool serialize <OID>");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("entertaineritems"))
		{
			for(int i = 0; i < ENTERTAINER_ITEMS.length; i++)
			{
				qa.templateObjectSpawner(self, ENTERTAINER_ITEMS[i]);
			}

			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("skills") || toLower(command).equals("skillmods") || toLower(command).equals("allskillmods"))
		{
			getAllSkillMods(self);
			return SCRIPT_CONTINUE;
		}

		//to be added later for reseting expertise
		else if(toLower(command).equals("resetexpertise") || toLower(command).equals("resetexpertises"))
		{
			//reset the expertise
			utils.fullExpertiseReset(self, true);
			grantSkill(self, "expertise");
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("buff") || toLower(command).equals("qabuff"))
		{
			int stringCount = st.countTokens();
			string[] allBuffs = dataTableGetStringColumn(BUFF_TABLE, "NAME");
			Arrays.sort(allBuffs);

			if(stringCount == 1)
			{
				string buffArg = st.nextToken();
				if(buffArg == "remove" || buffArg == "removebuff" || buffArg == "clear")
				{
					buff.removeAllBuffs(self);
					sendSystemMessageTestingOnly(self, "Buffs cleared.");
				}
				else
				{
					boolean foundBuff = false;
					for(int i = 0; i < allBuffs.length; i++)
					{
						if (allBuffs[i] == buffArg)
						{
							string buffName = qa.getClientBuffName(self, buffArg);
							if(buffName != "null")
							{
								qa.applyBuffOption(self, buffArg, buffName);
								foundBuff = true;
							}
							break;
						}
					}
					if(!foundBuff)
					{
						sendSystemMessageTestingOnly(self, "Either the Buff or the Buff name was not found.");
					}
				}
			}
			else
			{
				utils.setScriptVar(self, "qabuff.buffMenu", allBuffs);
				qa.refreshMenu (self, BUFF_TOOL_PROMPT, BUFF_TOOL_TITLE, allBuffs, "buffOptionHandler", "qabuff.pid", sui.OK_CANCEL_REFRESH );
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qaquest"))
		{
			try
			{
				string[] allQuests = qa.getAllQuests(self);
				string[] combinedMenu = new string[allQuests.length + QUEST_TOOL_MENU.length];
				System.arraycopy(allQuests, 0, combinedMenu, 0, allQuests.length);
				System.arraycopy(QUEST_TOOL_MENU, 0, combinedMenu, allQuests.length, QUEST_TOOL_MENU.length);

				qa.refreshMenu(self, QUEST_TOOL_PROMPT, QUEST_TOOL_TITLE, combinedMenu, "handleMainMenuOptions", true, "qaquest.pid", "qaquest.qaquestMenu");
			}
			catch(Exception e)
			{
				qa.refreshMenu(self, QUEST_TOOL_PROMPT + "\n\nNo quests found on character", QUEST_TOOL_TITLE, QUEST_TOOL_MENU, "handleMainMenuOptions", true, "qaquest.pid", "qaquest.qaquestMenu");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("smugglingquest"))
		{
			string questLevel = "1";

			int stringCount = st.countTokens();

			if(stringCount == 1)
			{
				questLevel = st.nextToken();

				int num = utils.stringToInt(questLevel);

				if(num < 1 || num > 5)
				{
					return SCRIPT_CONTINUE;
				}
			}

			groundquests.requestGrantQuest(self, "quest/smuggle_illicit_" + questLevel, true);
			int questCrc = groundquests.getQuestIdFromString("quest/smuggle_illicit_" + questLevel);
			int taskId = 10;

			dictionary qparams = new dictionary();
			qparams.put("questCrc", questCrc);
			qparams.put("taskId", taskId);

			String baseObjVar = groundquests.setBaseObjVar(self, "spawn", questGetQuestName(questCrc), taskId);

			setObjVar(self, baseObjVar + "." + "playedTimeEnd", 0);

			messageTo(self, "messageStartQuestSpawn", qparams, 3, true);

			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("smugglermodule"))
		{
			obj_id module = utils.getStaticItemInInventory(self, "item_reward_modify_pistol_01_01");

			if(isIdValid(module))
			{
				incrementCount(module, 100);
			}
			else
			{
				static_item.createNewItemFunction("item_reward_modify_pistol_01_01", self);
				module = utils.getStaticItemInInventory(self, "item_reward_modify_pistol_01_01");
				incrementCount(module, 99);
			}
		}

		else if(toLower(command).equals("contraband") || toLower(command).equals("contrabandspawner"))
		{
			int stringCount = st.countTokens();
			if(stringCount == 1)
			{
				string stringNumber = st.nextToken();
				int intNumber = utils.stringToInt(stringNumber);
				//sendSystemMessageTestingOnly(self, "intNumber" + intNumber);
				//sendSystemMessageTestingOnly(self, "CONTRABAND_STRINGS.length" + CONTRABAND_STRINGS.length);
				if (intNumber > 0 && intNumber < 11)
				{
					for (int i = 0; i < CONTRABAND_STRINGS.length; i++)
					{
						//sendSystemMessageTestingOnly(self, "CONTRABAND_STRINGS[i] " + CONTRABAND_STRINGS[i]);
						mulipleStaticSpawn(self, CONTRABAND_STRINGS[i], stringNumber, true);
					}
				}
				else
				{
					sendSystemMessageTestingOnly(self, "The tool requires the following usage to function: /qatool contraband <integer between 1 - 10> ");
				}
			}
			else
			{
				sendSystemMessageTestingOnly(self, "The tool requires the following usage to function: /qatool contraband <integer between 1 - 10> ");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("multi")  || toLower(command).equals("multispawn") || toLower(command).equals("repeat")  || toLower(command).equals("repeatspawn"))
		{
			int stringCount = st.countTokens();
			if(stringCount == 2)
			{
				string spawnString = st.nextToken();
				string intNumber = st.nextToken();
				//sendSystemMessageTestingOnly(self, "Working...");
				boolean spawningComplete = mulipleStaticSpawn(self, spawnString, intNumber, true);
				if(!spawningComplete)
				{
					sendSystemMessageTestingOnly(self, "The tool requires the following usage to function: /qatool mutli <static_item_spawn_string> <integer> ");
				}
			}
			else
			{
				sendSystemMessageTestingOnly(self, "The tool requires the following usage to function: /qatool mutli <static_item_spawn_string> <integer> ");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("spec") || toLower(command).equals("specme"))
		{
			//sendSystemMessageTestingOnly(self, "test worked: ");
			boolean successMsg = specTester(self, st);
			if(!successMsg)
			{
				sendSystemMessageTestingOnly(self, "***The tool failed in part or in full.  Make sure your arguments are spelled correctly and try again.***");
				return SCRIPT_CONTINUE;
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("enzyme") || toLower(command).equals("qaenzyme"))
		{
			//sendSystemMessageTestingOnly(self, "test worked: ");
			boolean successMsg = createEnzyme(self, st);
			if(!successMsg)
			{
				sendSystemMessageTestingOnly(self, "***The tool failed in part or in full.  Make sure your arguments are spelled correctly and try again.***");
				return SCRIPT_CONTINUE;
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("lyase") || toLower(command).equals("qalyase"))
		{
			//sendSystemMessageTestingOnly(self, "test worked: ");
			boolean successMsg = createLyase(self);
			if(!successMsg)
			{
				sendSystemMessageTestingOnly(self, "***The tool failed in part or in full.  Make sure your arguments are spelled correctly and try again.***");
				return SCRIPT_CONTINUE;
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("clearheroictimer"))
		{
			boolean successMsg = clearHeroicTimer(self);
			if(!successMsg)
			{
				//sendSystemMessageTestingOnly(self, "***The tool failed in part or in full.  Make sure your arguments are spelled correctly and try again.***");
				return SCRIPT_CONTINUE;
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("iso") || toLower(command).equals("qaiso"))
		{
			//sendSystemMessageTestingOnly(self, "test worked: ");
			boolean successMsg = createIsomerase(self);
			if(!successMsg)
			{
				sendSystemMessageTestingOnly(self, "***The tool failed in part or in full.  Make sure your arguments are spelled correctly and try again.***");
				return SCRIPT_CONTINUE;
			}
			return SCRIPT_CONTINUE;
		}


		else if(toLower(command).equals("revokepilot") || toLower(command).equals("pilotrevoke"))
		{
			qa.revokePilotingSkills(self);
			sendSystemMessageTestingOnly(self, "Pilot Skills revoked");
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qange"))
		{
			qa.createInputBox (self, NGE_TOOL_PROMPT, NGE_TOOL_TITLE, "handleGiveRespecItem", "qange.pid");
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qa_cube") || toLower(command).equals("qacube"))
		{
			qaCubeMenu(self);
		}

		//FIND A GROUND MOB OR NPC WITHIN A SPECIFIC RADIUS AROUND TESTER
		else if(toLower(command).equals("objfinder") || toLower(command).equals("findobj") || toLower(command).equals("objectfinder") || toLower(command).equals("findobject"))
		{
			objectFinderFunction(self, st);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("gmr") || toLower(command).equals("gmrevive"))
		{
			healShockWound(self, getShockWound(self));
			setAttrib(self, HEALTH, getMaxAttrib(self, HEALTH));
			sendSystemMessageTestingOnly(self, "gmr used on self");
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("helper") || toLower(command).equals("qahelper") || toLower(command).equals("aihelper"))
		{
			if(getGodLevel(self) >= 10)
			{
				makeHelper(self, st);
				CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has spawned " + st + " as a Helper Mobile.  This creature can be given specific commands like a pet and is used for combat testing.  The creature is spawned using the QA Helper Tool.");
			}
			else
			{
				sendSystemMessage(self, "You do not have the appropriate access level to use this tool.", null);
			}
		}

		else if(toLower(command).equals("qalootloggerdwb") || toLower(command).equals("dwblootlogger") || toLower(command).equals("lootloggerdwb"))
		{
			cleanAllScriptVars(self);
			lootLoggerTool(self, st, "theme_park.dungeon.death_watch_bunker.death_watch_death");
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("logger") || toLower(command).equals("lootlogger") || toLower(command).equals("qalootlogger"))
		{
			//qatool qalootlogger som_kenobi_dark_jedi_boss 40
			cleanAllScriptVars(self);
			lootLoggerTool(self, st, "none");
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("targetdata") || toLower(command).equals("target") || toLower(command).equals("dumptarget") || toLower(command).equals("dump"))
		{
			targetDataToolFunction(self, st);
			return SCRIPT_CONTINUE;
		}

		//Damage a player or mob without aggro or weapon use
		else if(toLower(command).equals("damagemob") || toLower(command).equals("damage") || toLower(command).equals("damageplayer")  || toLower(command).equals("damageself"))
		{
			qa.damageMobTool(self);
			return SCRIPT_CONTINUE;
		}

		//heal a player or mob without aggro or weapon use
		else if(toLower(command).equals("healmob") || toLower(command).equals("heal") || toLower(command).equals("healplayer"))
		{
			qa.healMobTool(self);
			return SCRIPT_CONTINUE;
		}

		//FIND A GROUND MOB OR NPC WITHIN A SPECIFIC RADIUS AROUND TESTER
		else if(toLower(command).equals("npcname") || toLower(command).equals("mobfinder") || toLower(command).equals("npcfinder") || toLower(command).equals("findnpc"))
		{
			sendSystemMessageTestingOnly(self, "Collecting list of Mobs and NPCs. Please wait.");
			npcFinderFunction(self, st);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("string") || toLower(command).equals("verifystring") || toLower(command).equals("stringcode") || toLower(command).equals("validatestring") )
		{
			string argString = "";

			if(st.hasMoreTokens())
			{
				int stringCount = st.countTokens();
				argString = st.nextToken();

				if(stringCount == 1)
				{
					string retrievedString = parseArgumentRetrieveString(self, argString);
					sui.msgbox(self, self, retrievedString, sui.OK_ONLY, QATOOL_TITLE, "noHandler");

				}
				else if(stringCount > 1)
				{
					sendSystemMessageTestingOnly(self, "The String ID must not contain any spaces.");
					sendSystemMessageTestingOnly(self, "Example: /qaTool string [conversation/tatooine_espa_watto]:s_106");
					return SCRIPT_CONTINUE;
				}
				else
				{
					sendSystemMessageTestingOnly(self, "The proper format for this command is: /qaTool string [code/identifying_the_string]:string_id ");
					sendSystemMessageTestingOnly(self, "Example: /qaTool string [conversation/tatooine_espa_watto]:s_106 ");
					return SCRIPT_CONTINUE;
				}
			}
			else
			{
				sendSystemMessageTestingOnly(self, "The proper format for this command is: /qaTool string [code/identifying_the_string]:string_id ");
				sendSystemMessageTestingOnly(self, "Example: /qaTool string [conversation/tatooine_espa_watto]:s_106 ");
				return SCRIPT_CONTINUE;
			}
		}

		else if(toLower(command).equals("qaprofession"))
		{
			utils.setScriptVar(self, "qaprofession.mainMenu", PROFESSION_TOOL_MENU);
			qa.refreshMenu (self, PROFESSION_TOOL_PROMPT, PROFESSION_TOOL_TITLE, PROFESSION_TOOL_MENU, "handleMainMenuOptions", "qaprofession.pid", sui.OK_CANCEL_REFRESH);
 			return SCRIPT_CONTINUE;
 		}

		else if(toLower(command).equals("qaweapon"))
		{
			qa.refreshMenu(self, "-Weapon Type Select Menu-\nChoose the type of weapon you wish to use for testing.", "QA Test Weapon Tool", WEAPON_TYPE, "handleWeaponTypeOptions", "qaweapon.pid", "qaweapon.weaponTypeMenu", sui.OK_CANCEL_REFRESH);
		 	return SCRIPT_CONTINUE;
 		}

		else if(toLower(command).equals("qaitem"))
		{
			utils.setScriptVar(self, "qaitem.mainMenu", ITEM_TOOL_MENU);
			qa.refreshMenu (self, ITEM_TOOL_PROMPT, ITEM_TOOL_TITLE, ITEM_TOOL_MENU, "handleMainMenuOptions", "qaitem.pid", sui.OK_CANCEL_REFRESH);
 			return SCRIPT_CONTINUE;
 		}

		else if(toLower(command).equals("qadatapad"))
		{
			toolWarpMenu(self);
 			return SCRIPT_CONTINUE;
 		}

		else if(toLower(command).equals("qascript"))
		{
			utils.setScriptVar(self, "qascript.mainMenu", SCRIPT_TOOL_MENU);
			//DYNAMIC PROMPT BUILDER FUNCTION
			string toolPrompt = scriptToolPromptMaker( self );
			qa.refreshMenu(self, toolPrompt, SCRIPT_TOOL_TITLE, SCRIPT_TOOL_MENU, "handleMainMenuOptions", "qascript.pid", sui.OK_CANCEL_REFRESH);
			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("qabadge"))
		{
			// Create a String array that has all badge types in it, with no duplications
			Vector vectorMenuArray = new Vector();
			vectorMenuArray.addElement("*Add All Badges*");
			vectorMenuArray.addElement("*Remove All Badges*");

			string[] badgePages = getAllCollectionPagesInBook("badge_book");
			if ((badgePages != null) && (badgePages.length > 0))
			{
				for (int i = 0; i < badgePages.length; ++i)
				{
					if (!badgePages[i].equals("bdg_accumulation"))
						vectorMenuArray.addElement(badgePages[i]);
				}
			}

			String[] badgeMenuArray = new String[vectorMenuArray.size()];
			vectorMenuArray.toArray(badgeMenuArray);

			utils.setScriptVar(self, "qabadge.mainMenu", badgeMenuArray);

			if (badgeMenuArray.length < 1)
				sendSystemMessageTestingOnly(self, "Badge UI creation failed.");

			utils.setScriptVar(self, "qabadge.mainMenu", badgeMenuArray);
			qa.refreshMenu(self, "Choose the Badge", "Badge Granter", badgeMenuArray, "mainMenuOptions", "qabadge.pid", sui.OK_CANCEL_REFRESH);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qawearables"))
		{
			string[] wearableMenuArray = qa.populateArray (self, "wearable_specie", "datatables/test/qa_wearables.iff");
			utils.setScriptVar(self, "qawearable.mainMenu", wearableMenuArray);
			qa.refreshMenu(self, "Choose the species", "Wearables Spawner", wearableMenuArray, "wearableTypeOptionSelect", "qawearable.pid", sui.OK_CANCEL_REFRESH);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qainv") || toLower(command).equals("inventory") || toLower(command).equals("qainventory"))
		{
			qa.refreshMenu(self, PROMPT, TITLE, INVENTORY_TOOL_MENU, "mainMenuOptions", "qainv.pid", sui.OK_CANCEL_REFRESH);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qafaction"))
		{
			qa.refreshMenu(self, PROMPT, TITLE, FACTION_TOOL_MENU, "mainMenuOptions", "qafac.pid", sui.OK_CANCEL_REFRESH);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qabag"))
		{
			obj_id inventory = utils.getInventoryContainer(self);
			obj_id[] invAndEquip = getInventoryAndEquipment(self);
			boolean hasBag = false;
			for(int i = 0; i < invAndEquip.length; i++)
			{
				string templateName = getTemplateName(invAndEquip[i]);
				if(templateName == "object/tangible/test/qabag.iff")
					hasBag = true;
				//sendSystemMessageTestingOnly(self, templateName);
			}
			if(hasBag == false)
			{
				createObjectInInventoryAllowOverload("object/tangible/test/qabag.iff", self);
				sendSystemMessageTestingOnly(self, "QA Bag Granted");
				return SCRIPT_CONTINUE;
			}
			else
			{
				sendSystemMessageTestingOnly(self, "You already have the QA bag");
				return SCRIPT_CONTINUE;
			}
		}

		else if(toLower(command).equals("qaxp"))
		{
			qa.refreshMenu(self, "Select the xp type...", "Beta XP Dispenser", XP_TOOL_MENU, "handleXpOptions", "qaxp.pid", sui.OK_CANCEL_REFRESH);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qadynamic"))
		{
			qa.refreshMenu(self, DYNAMIC_DESCRIPTION, "Dynamic Loot Spawner", DATA_SOURCE_MENU_LIST, "handleMainOptions", "qadynamic.pid", "qadynamic.dynamicMainMenu", sui.OK_CANCEL_REFRESH);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qajtl") || toLower(command).equals("spacetool"))
		{
			utils.setScriptVar( self, "qajtl.mainMenu", JTL_TOOL_MENU );
			qa.refreshMenu ( self, "Tool for JTL specific testing needs.", "QA JTL TOOL", JTL_TOOL_MENU, "mainMenuOptions", false, "qajtl.pid", "qajtl.mainMenu" );
		}

		else if(toLower(command).equals("qaresource") || toLower(command).equals("qaresources"))
		{
			utils.setScriptVar(self, "resource.mainMenu", RESOURCE_TOOL_MENU);
			qa.refreshMenu(self, RESOURCE_TOOL_PROMPT, RESOURCE_TOOL_TITLE, RESOURCE_TOOL_MENU, "startingMenuOptions", "resource.pid", sui.OK_CANCEL_REFRESH);
		}

		else if(toLower(command).equals("qarewardresource") || toLower(command).equals("qarewardresources"))
		{
			qa.refreshMenu(self, RESOURCE_REWARD_TOOL_PROMPT, RESOURCE_REWARD_TOOL_TITLE, REWARD_RESOURCE_MENU, "handleQATool", "qarewardresource.pid", "qarewardresource.mainMenu", sui.OK_CANCEL);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("groundmoblevel") || toLower(command).equals("groundlevelmob"))
		{
			if(isSpaceScene())
			{
				sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
			}
			else
			{
				//sendSystemMessageTestingOnly(self, "Ground Mobile Level Search Test +.");
				string argumentString = null;
				if(st.hasMoreTokens())
				{
					argumentString = st.nextToken();
					HashSet foundCreatures = new HashSet();
					int mobLevel = utils.stringToInt (argumentString);

					int[] arrayOfAllCreatures = dataTableGetIntColumn( CREATURE_TABLE, "BaseLevel" );
					int creatureArraySize = arrayOfAllCreatures.length;

					for(int i = 0; i < creatureArraySize; i++)
					{
						if( arrayOfAllCreatures[i] == mobLevel )
						{
							foundCreatures.add(dataTableGetString(CREATURE_TABLE, i, "creatureName"));
						}
					}
					if(foundCreatures.size() > 0)
					{
						string[] ArrayOfFoundCreatures = new string[foundCreatures.size()];
						foundCreatures.toArray(ArrayOfFoundCreatures);
						Arrays.sort(ArrayOfFoundCreatures);

						qa.refreshMenu ( self, "List of creatures that are level "+mobLevel+".", "QA GROUND MOB SEARCH TOOL", ArrayOfFoundCreatures, "groundMobSearchOptions", true, "groundMobSearch.pid", "groundMobSearch.creaturesFound" );
					}
					else
					{
						sendSystemMessageTestingOnly(self, "The Search String you entered was not found");
						cleanAllScriptVars(self);
						return SCRIPT_CONTINUE;
					}
				}
				else
				{
					sendSystemMessageTestingOnly(self, "A level number is needed for this tool to work.  Example '/qatool groundmoblevel 2'");
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
				}
			}
		}
		else if(toLower(command).equals("groundmobplanet") || toLower(command).equals("groundplanetmob"))
		{
			if(isSpaceScene())
			{
				sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
			}
			else
			{
				//sendSystemMessageTestingOnly(self, "Ground Planet Mob Test.");
				string argumentString = null;
				HashSet planetHash = new HashSet();
				string[] arrayOfLocations = dataTableGetStringColumn( CREATURE_TABLE, "where" );

				if(st.hasMoreTokens())
				{
					argumentString = toLower( st.nextToken() );
					//sendSystemMessageTestingOnly(self, "Arguement String = "+argumentString);
					//MAKE AN ARRAY OF THE ENTIRE CREATURE NAME COL
					string[] arrayOfAllCreatures = dataTableGetStringColumn( CREATURE_TABLE, "creatureName" );

					//GET THE LENGTH OF THE ARRAY FOR THE LOOP
					int arrayOfLocationsSize = arrayOfLocations.length;

					for(int x = 0; x < arrayOfLocationsSize; x++)
					{
						//sendSystemMessageTestingOnly(self, ""+arrayOfLocations[x]+"hello");
						if(arrayOfLocations[x] == argumentString)
						{
							//IF THE LIST IS OF THE PLANET STRING, ADD THE CREATURE NAME TO HASHSET
							planetHash.add(arrayOfAllCreatures[x]);
						}
					}
					if(planetHash.size() > 0)
					{
						string[] ArrayOfFoundCreatures = new string[planetHash.size()];
						planetHash.toArray(ArrayOfFoundCreatures);
						Arrays.sort(ArrayOfFoundCreatures);
						qa.refreshMenu ( self, "List of found creatures.", "QA GROUND MOB SEARCH TOOL", ArrayOfFoundCreatures, "groundMobSearchOptions", true, "groundMobSearch.pid", "groundMobSearch.creaturesFound" );
					}
					else
					{
						sendSystemMessageTestingOnly(self, "The planet string you entered was not found");
						cleanAllScriptVars(self);
						return SCRIPT_CONTINUE;
					}
				}
				else
				{
					//Get a list of all planet locations

					//string[] arrayOfLocations = dataTableGetStringColumn( CREATURE_TABLE, "where" );
					int arrayOfLocationsSize = arrayOfLocations.length;
					for(int i = 0; i < arrayOfLocationsSize; i++)
					{
						if(arrayOfLocations[i] == "")
						{
							planetHash.add("no_location_listed");
						}
						else
						{
							planetHash.add(toLower(arrayOfLocations[i]));
						}
					}
				}
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("groundmobsearch") || toLower(command).equals("groundsearchmob"))
		{
			if(isSpaceScene())
			{
				sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
			}
			else
			{
				string argumentString = null;
				if(st.hasMoreTokens())
				{
					argumentString = st.nextToken();
					HashSet foundCreatures = new HashSet();

					string[] arrayOfAllCreatures = dataTableGetStringColumn( CREATURE_TABLE, "creatureName" );
					int creatureArraySize = arrayOfAllCreatures.length;

					for(int i = 0; i < creatureArraySize; i++)
					{
						if( arrayOfAllCreatures[i].indexOf(argumentString) > -1 )
						{
							foundCreatures.add(arrayOfAllCreatures[i]);
						}
					}
					if(foundCreatures.size() > 0)
					{
						string[] ArrayOfFoundCreatures = new string[foundCreatures.size()];
						foundCreatures.toArray(ArrayOfFoundCreatures);
						Arrays.sort(ArrayOfFoundCreatures);

						qa.refreshMenu ( self, "List of found creatures.", "QA GROUND MOB SEARCH TOOL", ArrayOfFoundCreatures, "groundMobSearchOptions", true, "groundMobSearch.pid", "groundMobSearch.creaturesFound" );
					}
					else
					{
						sendSystemMessageTestingOnly(self, "The Search String you entered was not found");
						cleanAllScriptVars(self);
						return SCRIPT_CONTINUE;
					}
				}
				else
				{
					sendSystemMessageTestingOnly(self, "Format: /qatool groundmobsearch <creature name or partial name> ");
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
				}
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("spacemobsearch"))
		{
			if (isSpaceScene())
			{
				//sendSystemMessageTestingOnly(self, "spacemobsearch used");
				string argumentString = null;
				if(st.hasMoreTokens())
				{
					argumentString = st.nextToken();
					HashSet foundCreatures = new HashSet();

					string[] arrayOfAllCreatures = dataTableGetStringColumn(SPACE_MOBILE_TABLE, "strIndex");
					int creatureArraySize = arrayOfAllCreatures.length;

					for(int i = 0; i < creatureArraySize; i++)
					{
						if(arrayOfAllCreatures[i].indexOf(argumentString) > -1)
						{
							foundCreatures.add(arrayOfAllCreatures[i]);
						}
					}
					if(foundCreatures.size() > 0)
					{
						string[] ArrayOfFoundCreatures = new string[foundCreatures.size()];
						foundCreatures.toArray(ArrayOfFoundCreatures);
						Arrays.sort(ArrayOfFoundCreatures);

						qa.refreshMenu ( self, "List of space mobiles found.", "QA SPACE MOB SEARCH TOOL", ArrayOfFoundCreatures, "spaceMobSearchOptions", true, "spaceMobSearch.pid", "spaceMobSearch.mobsFound" );
					}
					else
					{
						sendSystemMessageTestingOnly(self, "The Search String you entered was not found");
						cleanAllScriptVars(self);
						return SCRIPT_CONTINUE;
					}
				}
				else
				{
					sendSystemMessageTestingOnly(self, "Format: /qatool spacemobsearch <possible enemy ship name>");
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
				}
			}
			else
			{
				sendSystemMessageTestingOnly(self, "You need to be in space to use this tool.");
			}
			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("qafrog") || toLower(command).equals("frog"))
		{
			giveTesterAFrog(self);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("lootsearch") || toLower(command).equals("lootnamesearch"))
		{
			string argumentString = null;
			if(st.hasMoreTokens())
			{
				argumentString = st.nextToken();
				//sendSystemMessageTestingOnly(self, "lootnamesearch initiated.");
				searchStaticLoot(self, argumentString, "string");
			}
			else
			{
				sendSystemMessageTestingOnly(self, "You need to type a search string. \nExample: /qaTool lootnamesearch pistol");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("lootstringsearch") || toLower(command).equals("lootcodesearch"))
		{
			string argumentString = null;
			if(st.hasMoreTokens())
			{
				argumentString = st.nextToken();
				searchStaticLoot(self, argumentString, "codestring");
			}
			else
			{
				sendSystemMessageTestingOnly(self, "You need to type a search string. \nExample: /qaTool lootcodesearch weapon_pistol");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("spawnitem"))
		{
			string argumentString = null;
			if(st.hasMoreTokens())
			{
				argumentString = st.nextToken();
				qa.spawnStaticItemInInventory (self, argumentString, "none");
			}
			else
			{
				sendSystemMessageTestingOnly(self, "You need to type a code string. \nExample: /qaTool item weapon_pistol_02_02.\n\n  If you don't know the code string to spawn something use one of the following tools: /qatool lootnamesearch <searchString> or /qatool lootcodesearch <searchString>");
			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("kill") || toLower(command).equals("killplayer"))
		{
			string override = null;
			if (st.hasMoreTokens())
			{
				override = st.nextToken();
			}

			obj_id objKillTarget = qaGetTarget(self, override);

			int commandKillResult = commandKill(self, objKillTarget);

			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("suicide"))
		{
			sendSystemMessageTestingOnly(self, "Killing self");
			setPosture(self, POSTURE_INCAPACITATED);
			pclib.coupDeGrace(self, self, true, true);
		}

		else if(toLower(command).equals("aistop"))
		{
			obj_id stopTarget = qa.findTarget(self);
			if (isValidId(stopTarget) && isMob(stopTarget))
			{
				ai_lib.setDefaultCalmBehavior(stopTarget, ai_lib.BEHAVIOR_SENTINEL);
				sendSystemMessageTestingOnly(self, "target(" + stopTarget + ") STOPPED at location.  The target WILL defend itself.");
				CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has stopped (" + stopTarget + ") " + utils.getStringName(stopTarget) + " using the aiStop command.");
			}
			else
			{
				sendSystemMessageTestingOnly(self, "target empty or invalid");

			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("aifreeze"))
		{
			obj_id stopTarget = qa.findTarget(self);
			if (isValidId(stopTarget) && isMob(stopTarget))
			{
				ai_lib.setDefaultCalmBehavior(stopTarget, ai_lib.BEHAVIOR_SENTINEL);
				detachScript(stopTarget, "ai.creature_combat");
				sendSystemMessageTestingOnly(self, "target(" + stopTarget + ") STOPPED at location.  The target will NOT defend itself.");
				CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has frozen (" + stopTarget + ") " + utils.getStringName(stopTarget) + " using the aiFreeze command.");
			}
			else
			{
				sendSystemMessageTestingOnly(self, "target empty or invalid");

			}
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("qadna"))
		{
			qa.refreshMenu(self, DNA_PROMPT, DNA_TITLE, PET_OPTION_MENU, "handlePetOptionsTool", "qadna.pid", sui.OK_CANCEL_REFRESH);
		}
		else if(toLower(command).equals("breakcloning"))
		{
			location playerLoc = getLocation(self);

			string planetName = playerLoc.area;

			if(planetName == null)
			{
				return SCRIPT_CONTINUE;
			}

			obj_id planet = getPlanetByName(planetName);

			if(!isIdValid(planet))
			{
				return SCRIPT_CONTINUE;
			}

			float x = playerLoc.x;
			float z = playerLoc.z;

			obj_id container = getTopMostContainer(self);
			location worldLoc = getWorldLocation(container);
			string area = getBuildoutAreaName(worldLoc.x, worldLoc.z);

			if(area == null)
			{
				area = "";
			}

			resizeable obj_id[]   idList        = utils.getResizeableObjIdArrayScriptVar(planet, cloninglib.VAR_PLANET_CLONE_ID);
			resizeable string[]   nameList      = utils.getResizeableStringArrayScriptVar(planet, cloninglib.VAR_PLANET_CLONE_NAME);

			if(idList.length == nameList.length)
			{
				idList.add(self);

				utils.setScriptVar(planet, cloninglib.VAR_PLANET_CLONE_ID, idList);

				sendSystemMessageTestingOnly(self, "Cloning planet lists broken for " + planetName);
			}
			else
			{
				sendSystemMessageTestingOnly(self, "Cloning planet lists are already invalid.");
			}

			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("qaexportbackpack"))
		{
			cleanAllScriptVars(self);
			qaExportBackpackContents(self);
			return SCRIPT_CONTINUE;
		}
		else if(toLower(command).equals("qatcg") || toLower(command).equals("tcg"))
		{
			qaTCGMenu(self);
			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("spawnship") || toLower(command).equals("qaspawnship"))
		{
		
			if(!isSpaceScene())
			{
				sendSystemMessage(self, "You must be in space to use this tool", null);
				return SCRIPT_CONTINUE;
			}
		
			transform gloc = getTransform_o2w(space_transition.getContainingShip(self));
			float dist = 200.f;
			vector n = gloc.getLocalFrameK_p().normalize().multiply( dist ); // Project a point out in front of us.
			gloc = gloc.move_p( n );

			string targetShipType = "blacksun_bomber_s03_tier5";
			int numShips = 1;

			if(st.hasMoreTokens())
			{
				targetShipType = st.nextToken();

				if(st.hasMoreTokens())
				{
					string nextToken = st.nextToken();
					int ns = Integer.parseInt(nextToken);
					if(ns > 1)
					{
						numShips = ns;
					}
				}
			}

			for (int i=0; i<numShips; i++ )
			{		

				obj_id targetShip = space_create.createShipHyperspace(targetShipType, gloc);
				sendSystemMessage(self, "Spawned ship - OID: "+targetShip, null);
			}

			return SCRIPT_CONTINUE;
		}

		else if(toLower(command).equals("?"))
		{
			//build the prompt
			string allHelpData = "";
			Arrays.sort(QATOOLPROMPT);

			for (int i = 0; i < QATOOLPROMPT.length; i++)
			{
					allHelpData = allHelpData + QATOOLPROMPT[i] + "\r\n\t";
			}
			saveTextOnClient( self, "commandUsage.txt", allHelpData );
			sui.msgbox( self, self, allHelpData, sui.OK_ONLY, QATOOL_TITLE, "noHandler" );
			return SCRIPT_CONTINUE;
		}

		else
		{
			sendSystemMessageTestingOnly(self, "No such QA Tool Command.  Please check your spelling");
		}

		return SCRIPT_CONTINUE;
	}
	return SCRIPT_CONTINUE;
}

//------------------------------------------------------------------------------------
//  MESSAGE HANDLERS FOR THIS SCRIPT
//------------------------------------------------------------------------------------

messageHandler oldItemMenuHandler()
{
	if(isGod(self))
	{
		if(utils.hasScriptVar( self, "oldItem.pid"))
		{
			qa.checkParams(params, "oldItem");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "oldItem.menu" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{
				string previousSelection = previousMainMenuArray[idx];
				if(previousSelection == "No Mob/NPC Found")
				{
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
				}
				else
				{
					if (previousSelection == OLD_ITEM_MENU[0])
					{
						for (int i = 0; i < OLD_FS_VILLAGE_ITEMS.length; i++)
						{
							if (OLD_FS_VILLAGE_ITEMS[i] != "object/tangible/item/quest/force_sensitive/fs_buff_item.iff")
							{
								qa.templateObjectSpawner(self, OLD_FS_VILLAGE_ITEMS[i]);
							}
							else
							{
								obj_id inventoryContainer = utils.getInventoryContainer(self);
								obj_id buffItem = createObject(OLD_FS_VILLAGE_ITEMS[i], inventoryContainer, "");
								if (isValidId(buffItem))
								{
									setObjVar (buffItem,"item.time.reuse_time",259200);
									setObjVar (buffItem,"item.buff.type",0);
									setObjVar (buffItem,"item.buff.value",2000);
									setObjVar (buffItem,"item.buff.duration",7200);
									sendSystemMessageTestingOnly(self, "Item Issued.");
									CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has spawned (" + OLD_FS_VILLAGE_ITEMS[i] + ") using a QA Tool or command.");
								}
							}
						}
					}
					if (previousSelection == OLD_ITEM_MENU[1])
					{
						for (int i = 0; i < HERO_OF_TATOOINE_ITEMS.length; i++)
						{
							qa.templateObjectSpawner(self, HERO_OF_TATOOINE_ITEMS[i]);
						}
					}
					if (previousSelection == OLD_ITEM_MENU[2])
					{
						for (int i = 0; i < DEATH_WATCH_BUNKER_ITEMS.length; i++)
						{
							qa.templateObjectSpawner(self, DEATH_WATCH_BUNKER_ITEMS[i]);
						}
					}
					if (previousSelection == OLD_ITEM_MENU[3])
					{
						for (int i = 0; i < OLD_SKILL_BUFF_ITEMS.length; i++)
						{
							qa.templateObjectSpawner(self, OLD_SKILL_BUFF_ITEMS[i]);
						}
					}
					if (previousSelection == OLD_ITEM_MENU[4])
					{
						for (int i = 0; i < CRAFTING_COMPONENTS.length; i++)
						{
							qa.templateObjectSpawner(self, CRAFTING_COMPONENTS[i]);
						}
					}
					if (previousSelection == OLD_ITEM_MENU[5])
					{
						for (int i = 0; i < VARACTYL_TREASURE_ITEMS.length; i++)
						{
							qa.templateObjectSpawner(self, VARACTYL_TREASURE_ITEMS[i]);
						}
					}
					if (previousSelection == OLD_ITEM_MENU[6])
					{
						obj_id myBag = getObjectInSlot(self, "back");
						obj_id testerInventoryId = utils.getInventoryContainer(self);
						if (!isValidId(myBag) && isValidId(testerInventoryId))
						{
							qa.findOrCreateAndEquipQABag(self, testerInventoryId, false);
							myBag = getObjectInSlot(self, "back");

							//This checks to make sure items are placed in the QA Bag

							for (int i = 0; i < LOOT_SCHEMATICS.length; i++)
							{
								//putInOverloaded(qa.templateObjectSpawner(self, LOOT_SCHEMATICS[i], false), myBag);
								obj_id itemId = qa.templateObjectSpawner(self, LOOT_SCHEMATICS[i], false);
								putInOverloaded(itemId, myBag);
							}
						}
						else
						{
							sendSystemMessageTestingOnly(self, "Delete or drop your Current QA Bag for this tool.");
						}
					}
					if (previousSelection == null)
					{
						sendSystemMessageTestingOnly(self, "Menu Selection Failed.");
						qa.refreshMenu(self, "Select a old item category.", "Old Item Spawner", OLD_ITEM_MENU, "oldItemMenuHandler",true, "oldItem.pid", "oldItem.menu");
					}
					qa.refreshMenu(self, "Select a old item category. DO NOT BUG ITEMS SPAWNED WITH THIS TOOL! DO NOT BUG ITEMS SPAWNED WITH THIS TOOL! DO NOT BUG ITEMS SPAWNED WITH THIS TOOL!", "Old Item Spawner", OLD_ITEM_MENU, "oldItemMenuHandler",true, "oldItem.pid", "oldItem.menu");
				}
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler msgHandleWeatherSelection()
{
	if(isGod(self))
	{
		if(utils.hasScriptVar( self, "weather.pid"))
		{
			qa.checkParams(params, "weather");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "weather.list" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{
				string previousSelection = previousMainMenuArray[idx];
				if(previousSelection == "No Mob/NPC Found")
				{
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
				}
				else
				{
					if (previousSelection =="Clear")
					{
						setWeather(self, 0);
					}
					else if (previousSelection =="Mild")
					{
						setWeather(self, 1);
					}
					else if (previousSelection =="Heavy")
					{
						setWeather(self, 2);
					}
					else if (previousSelection =="Severe")
					{
						setWeather(self, 3);
					}
					else
					{
						sendSystemMessageTestingOnly(self, "Selection Failed.");
						qa.refreshMenu(self, "Select weather type.", "Weather Tool", WEATHER_TYPES, "msgHandleWeatherSelection", true, "weather.pid", "weather.list" );
					}
				}
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler npcFinderHandler()
{
	if(isGod(self))
	{
		if(utils.hasScriptVar( self, "npcFinder.pid"))
		{
			qa.checkParams(params, "npcFinder");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "npcFinder.allMobStrings" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{
				string previousSelection = previousMainMenuArray[idx];
				if(previousSelection == "No Mob/NPC Found")
				{
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
				}
				else
				{
					parseThenWarpTester(self, previousSelection);
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
				}
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler objectFinderHandler()
{
	if (isGod(self))
	{
		if(utils.hasScriptVar( self, "objFinder.pid"))
		{
			qa.checkParams(params, "npcFinder");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "objFinder.objStrings" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{
				string previousSelection = previousMainMenuArray[idx];
				parseThenWarpTester(self, previousSelection);
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;

			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler qaLootThem()
{

  	boolean isQaBackpackScriptAttached = hasScript(self, "test.qabackpack");

  	if (!isQaBackpackScriptAttached)
  	{
  		attachScript(self, "test.qabackpack");
  	}

	obj_id myMob = params.getObjId("myMob");
	obj_id myBag = params.getObjId("myBag");

	obj_id testerInventoryId = params.getObjId("testerInventoryId");

	checkMobContents(self, myMob);
	corpse.lootAICorpse(self, myMob);

  	if (!isQaBackpackScriptAttached)
  	{
  		detachScript(self, "test.qabackpack");
  	}


	return SCRIPT_CONTINUE;
}

messageHandler qaSaveData()
{
	string exportText = params.getString("exportData");
	try
	{
		obj_id myBag = params.getObjId("myBag");
		if (isValidId(myBag))
		{
			string mobContentsByRow = utils.getStringScriptVar(self, "lootLogger.mobContents");
			boolean contentsExported = exportTextBagContents(self, myBag, exportText, mobContentsByRow);
		}
	}
	catch (Exception e)
	{
		//the user deleted the QA Bag before the dump was created.  This causes java to crash.
	}

	messageTo(self, "cleanAllScriptVars", null, 2.0f, true);
	return SCRIPT_CONTINUE;
}

messageHandler qaDestroyMob ()
{
	obj_id myMob = params.getObjId("myMob");
	//obj_id myBag = params.getObjId("myBag");
	obj_id testerInventoryId = params.getObjId("testerInventoryId");
	destroyObject(myMob);
	qa.findOrCreateAndEquipQABag(self, testerInventoryId , false);
	return SCRIPT_CONTINUE;
}

messageHandler qaDestroyObject ()
{
	obj_id myMob = params.getObjId("object");
	destroyObject(myMob);
	return SCRIPT_CONTINUE;
}

messageHandler cleanAllScriptVars()
{
	cleanAllScriptVars(self);
	return SCRIPT_CONTINUE;
}

messageHandler groundMobSearchOptions()
{
	if(isGod(self))
	{
		if(utils.hasScriptVar( self, "groundMobSearch.pid"))
		{
			qa.checkParams(params, "groundMobSearch");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "groundMobSearch.creaturesFound" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{
				string previousSelection = previousMainMenuArray[idx];
				spawnGroundMob(self, previousSelection);
				obj_id target = utils.stringToObjId(previousSelection);
				CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has spawned (" + target + ") " + utils.getStringName(target) + " using a QA Tool SUI Menu.");

				qa.refreshMenu (self, "List of found creatures.", "QA MOB SEARCH TOOL", previousMainMenuArray, "groundMobSearchOptions", true, "groundMobSearch.pid", "groundMobSearch.creaturesFound");
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler spaceMobSearchOptions()
{
	if(isGod(self))
	{
		if (utils.hasScriptVar( self, "spaceMobSearch.pid"))
		{
			qa.checkParams(params, "spaceMobSearch");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "spaceMobSearch.mobsFound" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{
				string previousSelection = previousMainMenuArray[idx];

				obj_id objTest = space_transition.getContainingShip(self);
				obj_id objShip = null;
				if(isIdValid(objTest))
				{
					objShip = space_create.createShip(previousSelection, getTransform_o2p(objTest));
				}
				else
				{
					objShip = space_create.createShip(previousSelection, getTransform_o2p(self));

				}

				if(!isIdValid(objShip))
				{
					sendSystemMessageTestingOnly(self, "Tool failed to spawn enemy mobile");
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;

				}
				else
				{
					sendSystemMessageTestingOnly(self, "Made ship of type "+previousSelection+" object id is: "+objShip);
					qa.refreshMenu (self, "List of space mobiles found.", "QA SPACE MOB SEARCH TOOL", previousMainMenuArray, "spaceMobSearchOptions", true, "spaceMobSearch.pid", "spaceMobSearch.mobsFound");
					CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has spawned (" + objShip + ") " + utils.getStringName(objShip) + " using a QA Tool SUI Menu.");
				}
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler toolMainMenu()
{
	if(isGod(self))
	{
		if(utils.hasScriptVar( self, SCRIPT_VAR+".pid"))
		{
			//For use with functions looking for one or more tokens.  Pass the funciton null token.
			string s = "";
			StringTokenizer st = new StringTokenizer(s);

			qa.checkParams(params, SCRIPT_VAR);
			obj_id player = sui.getPlayerId(params);
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);
			utils.setScriptVar(player, SCRIPT_VAR+".toolMainMenu", QATOOL_MAIN_MENU);
			utils.setScriptVar(player, SCRIPT_VAR+".title", TITLE);
			utils.setScriptVar(player, SCRIPT_VAR+".prompt", PROMPT);

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}

			switch (idx)
			{
				case BADGETOOL_MENUOPTION: //Badge tool
					// Create a String array that has all badge types in it, with no duplications
					Vector vectorMenuArray = new Vector();
					vectorMenuArray.addElement("*Add All Badges*");
					vectorMenuArray.addElement("*Remove All Badges*");

					string[] badgeCategories = getAllCollectionSlotCategoriesInBook("badge_book");
					if ((badgeCategories != null) && (badgeCategories.length > 0))
					{
						for (int i = 0; i < badgeCategories.length; ++i)
						{
							if (badgeCategories[i] != "accumulation")
								vectorMenuArray.addElement(badgeCategories[i]);
						}
					}

					String[] badgeMenuArray = new String[vectorMenuArray.size()];
					vectorMenuArray.toArray(badgeMenuArray);

					utils.setScriptVar(player, "qabadge.mainMenu", badgeMenuArray);

					if (badgeMenuArray.length < 1)
						sendSystemMessageTestingOnly(self, "Badge UI creation failed.");

					utils.setScriptVar(self, "qabadge.mainMenu", badgeMenuArray);
					qa.refreshMenu(player, "Choose the Badge", "Badge Granter", badgeMenuArray, "mainMenuOptions", "qabadge.pid", sui.OK_CANCEL_REFRESH);
					break;
				case BUFFTOOL_MENUOPTION: //Buff Tool
					string[] allBuffs = dataTableGetStringColumn(BUFF_TABLE, "NAME");
					Arrays.sort(allBuffs);

					utils.setScriptVar(self, "qabuff.buffMenu", allBuffs);
					qa.refreshMenu (self, BUFF_TOOL_PROMPT, BUFF_TOOL_TITLE, allBuffs, "buffOptionHandler", "qabuff.pid", sui.OK_CANCEL_REFRESH );
					break;
				case QACUBE_MENUOPTION: //CHU-GON DAR CUBE TOOL
					qaCubeMenu(player);
					break;
				case CYBERNETIC_MENUOPTION: //Cybernetic Tool
					qa.refreshMenu(player, "- Cybernetic Install Menu -\nSelect Install, Uninstall or Repair.", "Cybernetic Tool", CYBER_MENU_LIST, "handleChoice", "qacybernetic.pid", "qacybernetic.CyberMainMenu", sui.OK_CANCEL_REFRESH);
					break;
				case DMGTOOL_MENUOPTION: //Damage Tool
					qa.damageMobTool(self);
					break;
				case DATAPADTOOL_MENUOPTION: //Datapad Tool
					toolWarpMenu(self);
					break;
				case DYNAMIC_LOOTOPTION: //Dynamic Loot Spawner
					qa.refreshMenu(self, DYNAMIC_DESCRIPTION, "Dynamic Loot Spawner", DATA_SOURCE_MENU_LIST, "handleMainOptions", "qadynamic.pid", "qadynamic.dynamicMainMenu", sui.OK_CANCEL_REFRESH);
					break;
				case XPTOOL_MENUOPTION: //XP
					qa.refreshMenu(player, "Select the xp type...", "Beta XP Dispenser", XP_TOOL_MENU, "handleXpOptions", "qaxp.pid", sui.OK_CANCEL_REFRESH);
					break;
				case FACTIONTOOL_MENUOPTION: //Faction
					qa.refreshMenu(player, PROMPT, TITLE, FACTION_TOOL_MENU, "mainMenuOptions", "qafac.pid", sui.OK_CANCEL_REFRESH);
					break;
				case INVTOOL_MENUOPTION: //Inventory
					qa.refreshMenu(self, PROMPT, TITLE, INVENTORY_TOOL_MENU, "mainMenuOptions", "qainv.pid", sui.OK_CANCEL_REFRESH);
					break;
				case MSTRITEMTOOL_MENUOPTION: //MASTER ITEM TOOL
					utils.setScriptVar( self, "qaitem.mainMenu", ITEM_TOOL_MENU );
					qa.refreshMenu(self, ITEM_TOOL_PROMPT, ITEM_TOOL_TITLE, ITEM_TOOL_MENU, "handleMainMenuOptions", "qaitem.pid", sui.OK_CANCEL_REFRESH);
					break;
				case NGETOOL_MENUOPTION: //NGE TOOL
					qa.createInputBox (player, NGE_TOOL_PROMPT, NGE_TOOL_TITLE, "handleGiveRespecItem", "qange.pid");
					break;
				case NPCFINDERTOOL_MENUOPTION: //NPC FINDER TOOL
					npcFinderFunction(self, st);
					break;
				case PET_OPTION: //Pet Options - incubator items, DNA samples, Food, etc.
					qa.refreshMenu(self, DNA_PROMPT, DNA_TITLE, PET_OPTION_MENU, "handlePetOptionsTool", "qadna.pid", sui.OK_CANCEL_REFRESH);
					break;
				case PROFESSIONTOOL_MENUOPTION: //PROFESSION TOOL
					utils.setScriptVar( self, "qaprofession.mainMenu", PROFESSION_TOOL_MENU );
					qa.refreshMenu ( self, PROFESSION_TOOL_PROMPT, PROFESSION_TOOL_TITLE, PROFESSION_TOOL_MENU, "handleMainMenuOptions", "qaprofession.pid", sui.OK_CANCEL_REFRESH);
					break;
				case QUESTTOOL_MENUOPTION: //quest tool
					try
					{
						string[] allQuests = qa.getAllQuests(self);
						string[] combinedMenu = new string[allQuests.length + QUEST_TOOL_MENU.length];
						System.arraycopy(allQuests, 0, combinedMenu, 0, allQuests.length);
						System.arraycopy(QUEST_TOOL_MENU, 0, combinedMenu, allQuests.length, QUEST_TOOL_MENU.length);
						qa.refreshMenu(self, QUEST_TOOL_PROMPT, QUEST_TOOL_TITLE, combinedMenu, "handleMainMenuOptions", true, "qaquest.pid", "qaquest.qaquestMenu");
					}
					catch(Exception e)
					{
						qa.refreshMenu(self, QUEST_TOOL_PROMPT + "\n\nNo quests found on character", QUEST_TOOL_TITLE, QUEST_TOOL_MENU, "handleMainMenuOptions", true, "qaquest.pid", "qaquest.qaquestMenu");
					}
					break;
				case RESOURCETOOL_MENUOPTION: //Rescource tool
					utils.setScriptVar(player, "resource.mainMenu", RESOURCE_TOOL_MENU);
					qa.refreshMenu(player, RESOURCE_TOOL_PROMPT, "QA Resource Tool", RESOURCE_TOOL_MENU, "startingMenuOptions", "resource.pid", sui.OK_CANCEL_REFRESH);
					break;
				case RESOURCE_REWARD_TOOL_MENUOPTION:
					qa.refreshMenu(self, RESOURCE_REWARD_TOOL_PROMPT, RESOURCE_REWARD_TOOL_TITLE, REWARD_RESOURCE_MENU, "handleQATool", "qarewardresource.pid", "qarewardresource.mainMenu",sui.OK_CANCEL);
					break;
				case SCRIPTTOOL_MENUOPTION: //SCRIPT TOOL
					utils.setScriptVar(player, "qascript.mainMenu", SCRIPT_TOOL_MENU);
					//DYNAMIC PROMPT BUILDER FUNCTION
					string toolPrompt = scriptToolPromptMaker( player );
					qa.refreshMenu(player, toolPrompt, SCRIPT_TOOL_TITLE, SCRIPT_TOOL_MENU, "handleMainMenuOptions", "qascript.pid", sui.OK_CANCEL_REFRESH);
					break;
				case SPACETOOL_MENUOPTION: //JTL SPACE
					utils.setScriptVar( self, "qajtl.mainMenu", JTL_TOOL_MENU );
					qa.refreshMenu ( player, "Tool for JTL specific testing needs.", "QA JTL TOOL", JTL_TOOL_MENU, "mainMenuOptions", "qajtl.pid", sui.OK_CANCEL_REFRESH );
					break;
				case FROGTOOL_MENUOPTION: //FROGS
					giveTesterAFrog( self );
					break;
				case VETERANREWARD_MENUOPTION: //Veteran Reward
					string[] allRewardTemplates = dataTableGetStringColumn(VET_REWARDS_TABLE, "Object Template");
					Arrays.sort(allRewardTemplates);

					if (allRewardTemplates.length > 0)
					{
						qa.refreshMenu(self, "The list below shows veteran rewards available", "Vet Reward Tool", allRewardTemplates, "vetRewardOptionHandler",true, "vetreward.pid", "vetreward.allTemplates");
					}
					break;
				case WEAPONS_MENUOPTION:
					qa.refreshMenu(player, "-Weapon Type Select Menu-\nChoose the type of weapon you wish to use for testing.", "QA Test Weapon Tool", WEAPON_TYPE, "handleWeaponTypeOptions", "qaweapon.pid", "qaweapon.weaponTypeMenu", sui.OK_CANCEL_REFRESH);
					break;
				case WEARABLESTOOL_MENUOPTION: //wearables tool
					string[] wearableMenuArray = qa.populateArray (player, "wearable_specie", "datatables/test/qa_wearables.iff");
					utils.setScriptVar(player, "qawearable.mainMenu", wearableMenuArray);
					qa.refreshMenu(player, "Choose the species", "Wearables Spawner", wearableMenuArray, "wearableTypeOptionSelect", "qawearable.pid", sui.OK_CANCEL_REFRESH);
					break;

				default:
					cleanAllScriptVars(self);
					return SCRIPT_CONTINUE;
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler handleItemSearchOptions()
{
	if(isGod(self))
	{
		if(utils.hasScriptVar( self, "itemSearch.pid"))
		{
			qa.checkParams(params, "itemSearch");
			int idx = sui.getListboxSelectedRow(params);
			int btn = sui.getIntButtonPressed(params);

			string previousMainMenuArray[] = utils.getStringArrayScriptVar( self, "itemSearch.foundStrings" );
			string listOfRowNumbers[] = utils.getStringArrayScriptVar( self, "itemSearch.foundRows" );
			string listOfAllItems[] = utils.getStringArrayScriptVar( self, "itemSearch.allItems" );

			if(btn == sui.BP_CANCEL)
			{
				cleanAllScriptVars(self);
				return SCRIPT_CONTINUE;
			}
			else
			{
				int selectedRow = utils.stringToInt(listOfRowNumbers[idx]);
				string selectedItem = listOfAllItems[selectedRow];
				qa.spawnStaticItemInInventory(self, selectedItem, "none");
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler exportFile()
{
	//Get the button pressed, if it is OK run the functions
	//If 1, just remove the scriptVar Tree
	int btn = sui.getIntButtonPressed(params);
	if (btn == 0)
	{
		obj_id target = utils.stringToObjId(utils.getStringScriptVar(self, "export.lookAtTarget"));
		//Get a dump without color codes

		string fileData = qa.qaTargetDump(self, target, false);
		string objName = getName(target);
		string title = "";

			title = "targetDump" + target;

		saveTextOnClient(self, title+".txt", fileData);
	}

	cleanAllScriptVars(self);

	return SCRIPT_CONTINUE;

}

messageHandler animateForceDestruction()
{
	if(isGod(self))
	{
		doAnimationAction (self, anims.PLAYER_FORCE_DESTRUCTION);
	}
	return SCRIPT_CONTINUE;
}

messageHandler runLootLoggerIncrement()
{
	int iterationInt= params.getInt("iterationInt");
	string scriptString = params.getString("scriptString");
	string creatureName = params.getString("myName");
	int successInt = lootLoggerMain(self, iterationInt, creatureName, scriptString);
	return SCRIPT_CONTINUE;
}

/************ FUNCTIONS *******************************************/
void cleanAllScriptVars(obj_id player)
{
	//sendSystemMessageTestingOnly(player, "removing all scriptvars!");
	utils.removeScriptVarTree(player,"qascript");
	utils.removeScriptVarTree(player,"qacraftableloot");
	utils.removeScriptVarTree(player,"qawearable");
	utils.removeScriptVarTree(player,"qabadge");
	utils.removeScriptVarTree(player,"qaquest");
	utils.removeScriptVarTree(player,"qabuff");
	utils.removeScriptVarTree(player,"qafac");
	utils.removeScriptVarTree(player,"qajtl");
	utils.removeScriptVarTree(player,"qainv");
	utils.removeScriptVarTree(player,"qaxp");
	utils.removeScriptVarTree(player,"qaGem");
	utils.removeScriptVarTree(player,"qascript");
	utils.removeScriptVarTree(player,"qange");
	utils.removeScriptVarTree(player,"qaprofession");
	utils.removeScriptVarTree(player,"npcFinder");
	utils.removeScriptVarTree(player,"doDamage");
	utils.removeScriptVarTree(player,"doDamageVar");
	utils.removeScriptVarTree(player,"export");
	utils.removeScriptVarTree(player,"itemSearch");
	utils.removeScriptVarTree(player,"qatool");
	utils.removeScriptVarTree(player,"lootLogger");
	utils.removeScriptVarTree(player,"mitigation");
	utils.removeScriptVarTree(player,"mitigationPid");
	utils.removeScriptVarTree(player,"qahelper_record");
	utils.removeScriptVarTree(player,"qahelper");
	utils.removeScriptVarTree(player,"qa_helper");
	utils.removeScriptVarTree(player,"objFinder");
	utils.removeScriptVarTree(player,"qaitem");
	utils.removeScriptVarTree(player,"qacybernetic");
	utils.removeScriptVarTree(player,"qadynamic");
	utils.removeScriptVarTree(player,"weather");
	utils.removeScriptVarTree(player,"oldItem");
	utils.removeScriptVarTree(player,SCRIPT_VAR);
}

void parseThenWarpTester(obj_id self, string previousSelection)
{
	if(previousSelection.indexOf(" ") > 0)
	{
		int objOidStart = previousSelection.indexOf("( ")+2;
		int objOidEnd = previousSelection.length()-2;
		obj_id objOID = utils.stringToObjId(previousSelection.substring(objOidStart, objOidEnd));
		if(isIdValid(objOID))
		{
			location objLocation = getLocation(objOID);
			warpPlayer(self, objLocation.area, objLocation.x, objLocation.y, objLocation.z, objLocation.cell, objLocation.x, objLocation.y, objLocation.z);
			CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has warped to (" + objOID + ") " + utils.getStringName(objOID) + " at location " + objLocation.area + " "  + objLocation.x + " "  + objLocation.y + " "  + objLocation.z + " "  + objLocation.cell + " "  + objLocation.x + " "  + objLocation.y + " "  + objLocation.z + " using a QA Tool.");
		}
		else
		{
			sendSystemMessageTestingOnly(self, "The tool failed to attain the correct location and warp the test character.  Notify the Tool Team!");
		}
	}
	else
	{
		try
		{
			obj_id objectId = utils.stringToObjId(previousSelection);
			location objLocation = getLocation(objectId);
			warpPlayer(self, objLocation.area, objLocation.x, objLocation.y, objLocation.z, objLocation.cell, objLocation.x, objLocation.y, objLocation.z);
			CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has warped to (" + objectId + ") " + utils.getStringName(objectId) + " at location " + objLocation.area + " "  + objLocation.x + " "  + objLocation.y + " "  + objLocation.z + " "  + objLocation.cell + " "  + objLocation.x + " "  + objLocation.y + " "  + objLocation.z + " using a QA Tool.");
		}
		catch(Exception e)
		{
			sendSystemMessageTestingOnly(self, "Failed to create an object Id. " + e);
		}
	}
}

void giveTesterAFrog (obj_id self)
{
	obj_id inventory = utils.getInventoryContainer(self);
	if (getVolumeFree(inventory) <= 0)
	{
		sendSystemMessageTestingOnly(self, "Your Inventory is Full, please make room and try again.");
	}
	else
	{
		createObject("object/tangible/terminal/terminal_character_builder.iff", inventory, "");
		createObject("object/tangible/terminal/terminal_kashyyyk_content.iff", inventory, "");
		sendSystemMessageTestingOnly(self, "Frog Tools Issued.");
		qa.refreshMenu( self, PROMPT, TITLE, QATOOL_MAIN_MENU, "toolMainMenu", true, SCRIPT_VAR+".pid");
	}
}
void initializeXpTool(obj_id self)
{
	string[] xpTypes = xp.getXpTypes(self);
	if((xpTypes != null) && (xpTypes.length > 0))
	{
		setXpTypesScriptVar(self, xpTypes);
	}
}

void setXpTypesScriptVar(obj_id self, string[] varData)
{
	if((varData == null) || (varData.length == 0))
	{
		debugSpeakMsg(self, "setXpTypesVar: passed bad string array!");
		return;
	}

	utils.setBatchScriptVar(self, VAR_XP_TYPES_LIST, varData);

	string[] xpNames = new string[varData.length];
	for(int i = 0; i < varData.length; i++)
		xpNames[i] = "@exp_n:" + varData[i];

	utils.setBatchScriptVar(self, VAR_XP_TYPES_NAMES, xpNames);
}

void spawnGroundMob (obj_id player, string stringIndex)
{
	//spawn the creature
	obj_id target = qa.findTarget(player);
	if(isIdValid(target) == false)
	{
		//IF NO TARGET EXISTS, TARGET IS TESTER
		target = player;
	}
	create.createCreature(stringIndex, getLocation(target), true);
	sendSystemMessageTestingOnly(player, "Mobile spawned at location targeted.");
}

//BUILDS THE DYNAMIC TOOL PROMPT FOR THE SCRIPT TOOL
string scriptToolPromptMaker(obj_id player)
{
	string scriptList = getCharacterScriptsPrompt( player );
	return SCRIPT_TOOL_PROMPT+scriptList;
}

void qaCubeMenu(obj_id player)
{
	getNamesArray(player);
	if(utils.hasScriptVar(player, "qa_cube.codeStringArray") && utils.hasScriptVar(player, "qa_cube.showNamesArray"))
	{
		string[] showNamesArray = utils.getStringArrayScriptVar(player, "qa_cube.showNamesArray");
		qa.refreshMenu(player, CHU_GON_DAR_PROMPT, CHU_GON_DAR_TITLE, showNamesArray, "handleChuGonOptions", "qa_cube.pid", "qa_cube.ChuGonMainMenu", sui.OK_CANCEL_REFRESH);
	}
	else
	{
		sendSystemMessageTestingOnly(player, "An error has occurred, please try again.");
	}
}

//THIS FUNCTION ACTUALLY CREATES THE LIST OF SCRIPTS ATTACHED TO THE CHARACTER SPECIFICALLY FOR THE TOOL PROMPT
string getCharacterScriptsPrompt(obj_id player)
{
	string strScripts = "";
	string[] scriptArray = filterCharacterScripts(player);
	for(int i = 0; i < scriptArray.length; i++)
	{
		if(scriptArray[i].startsWith("test."))
		{
			strScripts+=scriptArray[i]+"\r\n";
		}
		else
		{
			for(int s = 0; s < SCRIPT_TOOL_COMMON_SCRIPTS.length; s++)
			{
				if(scriptArray[i] == SCRIPT_TOOL_COMMON_SCRIPTS[s])
				{
					strScripts+=scriptArray[i]+"\r\n";
				}
			}
		}
	}

	return strScripts;
}

string[] filterCharacterScripts (obj_id player)
{
	string strScripts = "";
	string[] scriptArray = getScriptList(player);
	HashSet theSet = new HashSet();

	for(int i = 0; i < scriptArray.length; i++)
	{
		string script = scriptArray[i];
		if(script.indexOf("script.") > -1)
		{
			script = script.substring(7);
			theSet.add(script);
		}
	}

	string[] menuArray = new string[theSet.size()];
	theSet.toArray(menuArray);
	Arrays.sort(menuArray);
	return menuArray;
}

void searchStaticLoot(obj_id self, string argumentString, string searchType)
{
	Vector foundItemRowNumbers = new Vector();
	Vector finalListOfCombinedItems = new Vector();

	//GRABS THE ENTIRE COL OF THE DATATABLE
	string[] arrayOfAllStaticItemsInDatatable = dataTableGetStringColumn( MASTER_ITEM_TABLE, "name" );

	//USED TO MAKE A NEW ARRAY WITH THE ACTUAL STRINGS OF THE ITEMS
	string[] arrayOfAllItems = new string[arrayOfAllStaticItemsInDatatable.length];

	for(int i = 0; i < arrayOfAllStaticItemsInDatatable.length; i++)
	{
		arrayOfAllItems[i] = localize(new string_id( "static_item_n", arrayOfAllStaticItemsInDatatable[i]));

		if(searchType == "string")
		{
			if(arrayOfAllItems[i] != null && !arrayOfAllItems[i].equals(""))
			{
				if(toLower(arrayOfAllItems[i]).indexOf(toLower(argumentString)) > -1 )
				{
					foundItemRowNumbers.add(""+i);
					finalListOfCombinedItems.add(arrayOfAllItems[i]+"\t ( "+arrayOfAllStaticItemsInDatatable[i]+" )");
				}
			}
			else
			{
				dictionary troubleRow = dataTableGetRow(MASTER_ITEM_TABLE, i);
				sendSystemMessageTestingOnly(self, "Code String Found: "+troubleRow.getString("name"));
				sendSystemMessageTestingOnly(self, "This tool cannot be used until this code string is fixed");
			}
		}
		else
		{
			if(toLower(arrayOfAllStaticItemsInDatatable[i]).indexOf(toLower(argumentString)) > -1)
			{
				foundItemRowNumbers.add(""+i);
				finalListOfCombinedItems.add(arrayOfAllItems[i]+"\t ( "+arrayOfAllStaticItemsInDatatable[i]+" )");
			}
		}
	}

	string[] arrayOfFoundRowNumbers = new string[foundItemRowNumbers.size()];
	foundItemRowNumbers.toArray(arrayOfFoundRowNumbers);

	string[] arrayOfCombinedStrings = new string[finalListOfCombinedItems.size()];
	finalListOfCombinedItems.toArray(arrayOfCombinedStrings);

	if(arrayOfFoundRowNumbers.length > 0)
	{
		utils.setScriptVar(self, "itemSearch.foundRows", arrayOfFoundRowNumbers);
		utils.setScriptVar(self, "itemSearch.allItems", arrayOfAllStaticItemsInDatatable);
		qa.refreshMenu(self, "List of found items.", "QA STATIC ITEM SEARCH TOOL", arrayOfCombinedStrings, "handleItemSearchOptions", true, "itemSearch.pid", "itemSearch.foundStrings" );
	}
	else
	{
		sendSystemMessageTestingOnly(self, "The Search String you entered was not found");
		cleanAllScriptVars(self);
	}
}

obj_id[] filterOIDsForMob(obj_id self, obj_id[] allOIDs)
{
	if(allOIDs.length > -1)
	{
		resizeable obj_id[] allMobObj_IDs = new obj_id[0];

		for(int i = 0; i < allOIDs.length; i++)
		{
			//Make sure the object is a Mobile
			if(isMob(allOIDs[i]) && !isPlayer(allOIDs[i]))
			{
				utils.addElement(allMobObj_IDs, allOIDs[i]);
			}
		}
		return allMobObj_IDs;
	}
	return null;
}

obj_id[] getMobList(obj_id self, location testerLoc, float range)
{
	obj_id[] allMobsCreditKills = getAllObjectsWithScript(testerLoc, range, "systems.combat.credit_for_kills");
	obj_id[] allMobsAi = getAllObjectsWithScript(testerLoc, range, "ai.ai");
	obj_id[] allMobsCombat = getAllObjectsWithScript(testerLoc, range, "systems.combat.combat_actions");

	HashSet combinedMobArrays = new HashSet();

	//sendSystemMessageTestingOnly(self, "Arrays created.  Hashset created.");
	if(allMobsCreditKills.length > -1)
	{
		for(int i = 0; i < allMobsCreditKills.length; i++)
		{
			combinedMobArrays.add("" + allMobsCreditKills[i]);
		}
	}
	if(allMobsAi.length > -1)
	{
		for(int i = 0; i < allMobsAi.length; i++)
		{
			combinedMobArrays.add("" + allMobsAi[i]);
		}
	}
	if(allMobsCombat.length > -1)
	{
		for(int i = 0; i < allMobsCombat.length; i++)
		{
			combinedMobArrays.add("" + allMobsCombat[i]);
		}
	}
	if(combinedMobArrays.size() > 0)
	{

		string[] allMobOidsAsStrings = new string[combinedMobArrays.size()];
		obj_id[] allMobOids = new obj_id[combinedMobArrays.size()];
		combinedMobArrays.toArray(allMobOidsAsStrings);
		//Sorting the arrays doesn't seem to do much
		//Arrays.sort(allMobOidsAsStrings);

		for(int i = 0; i < allMobOidsAsStrings.length; i++)
		{
			allMobOids[i] = utils.stringToObjId(allMobOidsAsStrings[i]);
		}

		if(isValidId(allMobOids[0]))
		{
			return allMobOids;
		}
	}
	return null;
}

string[] getMobMenu(obj_id self, obj_id[] allMobOIDs, string searchString)
{
	if(allMobOIDs.length > -1)
	{
		resizeable string[] mobMenu = new string[0];
		resizeable string[] nullMobCodes = new string[0];

		for(int i = 0; i < allMobOIDs.length; i++)
		{
			string codeString = getCreatureName(allMobOIDs[i]);
			string localizedString = localize(new string_id("mob/creature_names", codeString));
			if (localizedString == null)
			{
				//sendSystemMessageTestingOnly(self, "null found "+i);
				//localizedString = codeString;
				localizedString = getEncodedName(allMobOIDs[i]);
			}
			if (searchString == "none")
			{
				utils.addElement(mobMenu, localizedString + "  ( " + allMobOIDs[i] + " )");
			}
			else if (searchString != "none" && searchString.length() > 2)
			{
				string lowerCaseMobile = toLower(localizedString);

				//sendSystemMessageTestingOnly(self, "lowerCaseMobile "+lowerCaseMobile);

				string lowerSearchString = toLower(searchString);
				if (lowerCaseMobile.indexOf(lowerSearchString) >= 0 || lowerCaseMobile == lowerSearchString)
				{
					utils.addElement(mobMenu, localizedString + "  ( " + allMobOIDs[i] + " )");

				}
			}
			else if (searchString != "none" && searchString.length() <= 2)
			{
				sendSystemMessageTestingOnly(self, "The mobile name must be at least 3 characters long");
				break;
			}
			else
			{
				sendSystemMessageTestingOnly(self, "There was a problem with your search string.");
				break;
			}
		}
		if(mobMenu.length > 0)
		{
			//since the allMobStrings is a Vector and not an array

			string[] arrayStrings = new string[mobMenu.size()];
			mobMenu.toArray(arrayStrings);
			Arrays.sort(arrayStrings);

			return arrayStrings;
		}
		else
		{
			sendSystemMessageTestingOnly(self, "No Mobiles found.");
		}
	}
	else
	{
		sendSystemMessageTestingOnly(self, "No Mobiles found in vicinity!");
	}
	return null;
}

string parseArgumentRetrieveString(obj_id self, string argString)
{
	if(argString.indexOf("[") == 0)
	{
		int dirEnd = argString.indexOf("]");

		string stringDir = argString.substring(1, dirEnd);
		//sendSystemMessageTestingOnly(self, "stringDir: " + stringDir);

		string stringName = argString.substring(dirEnd + 2, argString.length());
		//sendSystemMessageTestingOnly(self, "stringName: " + stringName);

		string localizedString = localize(new string_id(stringDir, stringName));
		//sendSystemMessageTestingOnly(self, "localizedString: " + localizedString);
		if(localizedString != null)
		{
			return localizedString;
		}

		return "The string ID was either incorrect or was deleted.  Review the string data you are passing to the tool and make sure it is correct.";
	}
	else
	{
		return "The string ID must contain braces. Example: [conversation/tatooine_espa_watto]:s_106 ";
	}
}

//Mitigation Tool main function
void mitigationToolFunction(obj_id self, obj_id lookAtTarget)
{
	if(isIdValid(lookAtTarget))
	{
		if(isPlayer(lookAtTarget) || isMob(lookAtTarget))
		{
			obj_id objWeapon = getCurrentWeapon(self);
			if(isIdValid(objWeapon))
			{
				weapon_data newWpnData = getWeaponData(objWeapon);

				utils.setScriptVar(self, "mitigation.lookAtTarget", ""+lookAtTarget);
				utils.setScriptVar(self, "mitigation.objWeapon", ""+objWeapon);
				utils.setScriptVar(self, "mitigation.minDamage", newWpnData.minDamage);
				utils.setScriptVar(self, "mitigation.maxDamage", newWpnData.maxDamage);


				//Build Damage Menu for future SUI
				string[] dmgMenu = new string[3];
				dmgMenu[0] = "Do Minimum Damage ( " + newWpnData.minDamage + " )";
				dmgMenu[1] = "Do Maximum Damage ( " + newWpnData.maxDamage + " )";
				dmgMenu[2] = "Do Random Damage";

				utils.setScriptVar(self, "mitigation.dmgMenu", dmgMenu);

				qa.refreshMenu(self, MITIGATION_TOOL_PROMPT, MITIGATION_TOOL_TITLE, MITIGATION_HIT_LOCATIONS, "handleAttackLocationOptions", true, "mitigationPid.pid", "mitigation.hitLocationMenu" );
			}
			else
			{
				sendSystemMessageTestingOnly(self, "Equip a weapon before attempting to use this tool.");
			}
		}
		else
		{
			sendSystemMessageTestingOnly(self, "You must have a valid mob or player targeted.");
		}
	}
	else
	{
		sendSystemMessageTestingOnly(self, "You must have a valid mob or player targeted.");
	}
}

//NPC Finder Tool main function
void npcFinderFunction(obj_id self, StringTokenizer st)
{
	if(isSpaceScene())
	{
		sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
	}
	else
	{
		if(st.hasMoreTokens())
		{
			string argumentString = st.nextToken();
			obj_id[] allMobOids = getMobList(self, getLocation(self), MINIMUM_FINDER_RADIUS_FLOAT);
			//sendSystemMessageTestingOnly(self, "allMobOids.length "+allMobOids.length);
			if (allMobOids != null)
			{
				obj_id[] allMobsWithNames = filterOIDsForMob(self, allMobOids);
				//sendSystemMessageTestingOnly(self, "allMobsWithNames.length "+allMobsWithNames.length);
				if(allMobsWithNames.length > -1)
				{
					string[] mobMenu = getMobMenu(self, allMobsWithNames, argumentString);
					//sendSystemMessageTestingOnly(self, "allMobsWithNames.length "+mobMenu.length);
					if(mobMenu != null && mobMenu.length > -1)
					{
						obj_id[] allFoundMobOids = getMobList(self, getLocation(self), MINIMUM_FINDER_RADIUS_FLOAT);
						if (allMobOids != null)
						{
							obj_id[] allFoundMobsWithNames = filterOIDsForMob(self, allFoundMobOids);
							if(allFoundMobsWithNames.length > -1)
							{
								string[] foundMobMenu = getMobMenu(self, allFoundMobsWithNames, argumentString);
								if(foundMobMenu != null && foundMobMenu.length > -1)
								{
									string promptAppend = "\n\r\n\rTotal Mobs Found within range of " + MINIMUM_FINDER_RADIUS_FLOAT + " = " + allFoundMobsWithNames.length + "\n\rTotal Returned =" + foundMobMenu.length;
									qa.refreshMenu(self, "List of Mobs/NPCs: " + promptAppend + "\n\r\n\rThis Tool is NOT 100% accurate.  Do not write defects because you cannot find NPCs using this tool.", NPCFINDER_TITLE, foundMobMenu, "npcFinderHandler",true, "npcFinder.pid", "npcFinder.allMobStrings" );
								}
								else
								{
									string promptAppend = "\n\r\n\rTotal Mobs Found within range of " + MINIMUM_FINDER_RADIUS_FLOAT + " = " + allFoundMobsWithNames.length + "\n\rTotal Returned = NOTHING";
									qa.refreshMenu(self, "List of Mobs/NPCs: " + promptAppend + "\n\r\n\rThis Tool is NOT 100% accurate.  Do not write defects because you cannot find NPCs using this tool.", NPCFINDER_TITLE, NPCFINDER_ERR_ARRAY, "npcFinderHandler",true, "npcFinder.pid", "npcFinder.allMobStrings");
								}
							}
						}
					}
				}
			}
		}
		else
		{
			obj_id[] allMobOids = getMobList(self, getLocation(self), MINIMUM_FINDER_RADIUS_FLOAT);
			if (allMobOids != null)
			{
				obj_id[] allMobsWithNames = filterOIDsForMob(self, allMobOids);
				if(allMobsWithNames.length > -1)
				{
					string[] mobMenu = getMobMenu(self, allMobsWithNames, "none");
					if(mobMenu != null && mobMenu.length > -1)
					{
						string promptAppend = "\n\r\n\rTotal Mobs Found within range of " + MINIMUM_FINDER_RADIUS_FLOAT + " = " + allMobsWithNames.length + "\n\rTotal Returned =" + mobMenu.length;
						qa.refreshMenu(self, "List of Mobs/NPCs: " + promptAppend + "\n\r\n\rThis Tool is NOT 100% accurate.  Do not write defects because you cannot find NPCs using this tool.", NPCFINDER_TITLE, mobMenu, "npcFinderHandler",true, "npcFinder.pid", "npcFinder.allMobStrings" );
					}
					else
					{
						string promptAppend = "\n\r\n\rTotal Mobs Found within range of " + MINIMUM_FINDER_RADIUS_FLOAT + " = " + allMobsWithNames.length + "\n\rTotal Returned = NOTHING";
						qa.refreshMenu(self, "List of Mobs/NPCs: " + promptAppend + "\n\r\n\rThis Tool is NOT 100% accurate.  Do not write defects because you cannot find NPCs using this tool.", NPCFINDER_TITLE, NPCFINDER_ERR_ARRAY, "npcFinderHandler",true, "npcFinder.pid", "npcFinder.allMobStrings");
					}
				}
			}
		}
	}
}

//Target Data Tool main function
void targetDataToolFunction(obj_id self, StringTokenizer st)
{
	obj_id lookAtTarget = qa.findTarget(self);

	if(st.hasMoreTokens())
	{
		string argumentString = st.nextToken();
		lookAtTarget = utils.stringToObjId(argumentString);
		if (isValidId(lookAtTarget))
		{
			string combinedString = qa.qaTargetDump(self, lookAtTarget, true);

			//Set scriptVars in case the tester needs a dump later
			string objIdString = ""+lookAtTarget;
			utils.setScriptVar(self, "export.lookAtTarget", objIdString);
			qa.createCustomUI(self, combinedString);
		}
		else
		{
			sendSystemMessageTestingOnly(self, "Invalid Object Id passed to tool.  Try again.");
		}
	}
	else
	{
		if(!isIdValid(lookAtTarget))
		{
				sendSystemMessageTestingOnly(self, "You need to have something targeted to use this command");
		}
		else if(isIdValid(lookAtTarget))
		{
			string combinedString = qa.qaTargetDump(self, lookAtTarget, true);

			//Set scriptVars in case the tester needs a dump later
			string objIdString = ""+lookAtTarget;
			utils.setScriptVar(self, "export.lookAtTarget", objIdString);
			qa.createCustomUI(self, combinedString);
		}
		else
		{
			sendSystemMessageTestingOnly(self, "you must have a valid target to use this command.");
		}
	}
}

void lootLoggerTool(obj_id self, StringTokenizer st, string scriptString)
{
	string myName = null;
	if(st.hasMoreTokens())
	{
		myName = st.nextToken();

		int dwbSpawnerRow = -1;
		int creatureRowNumber = -1;
		boolean continueSpawnTool = false;

		//validation that the creature exists
		if (scriptString == "none")
		{
			creatureRowNumber = dataTableSearchColumnForString(myName, "creatureName", CREATURE_TABLE);
			if(creatureRowNumber > -1)
				continueSpawnTool = true;
		}
		else
		{
			//DWB Spawn List comparison ---- put in more conditions as the need arises
			dwbSpawnerRow = dataTableSearchColumnForString(myName, "spawns", DWB_SPAWN_TABLE);
			creatureRowNumber = dataTableSearchColumnForString(myName, "creatureName", CREATURE_TABLE);
			if(dwbSpawnerRow > -1 && creatureRowNumber > -1)
				continueSpawnTool = true;
		}

		if(continueSpawnTool)
		{
			obj_id testerInventoryId = utils.getInventoryContainer(self);
			obj_id[] testerInventoryContents = getContents(testerInventoryId);
			obj_id myBag = getObjectInSlot(self, "back");

			boolean contentsEmpty = false;
			boolean qaBagContentsEmpty = false;

			int iteration = 0;

			if(st.hasMoreTokens())
			{
				iteration = Integer.parseInt(st.nextToken());
			}
			else
			{
				iteration = 25;
			}

			if(iteration > 100)
			{
				iteration = 100;
				sendSystemMessageTestingOnly(self, "You cannot spawn more than 100!!!");
			}
			if(iteration < 1)
			{
				iteration = 1;
				sendSystemMessageTestingOnly(self, "You cannot spawn less than 1!!!");
			}

			if (iteration <= 100)
			{
				//Give tester bag now.
				qa.findOrCreateAndEquipQABag(self, testerInventoryId, false);
				myBag = getObjectInSlot(self, "back");
				if (isIdValid(myBag))
				{
					//figure out how many times you want to loop through the amount
					//by dividing by 10
					int loopAmountInt = iteration / 10;
					//find remainder if any
					int remainderInt = iteration % 10;

					dictionary incrementDict = new dictionary();

					//ScriptString is used for the DWB spawns
					incrementDict.put("scriptString", scriptString);
					//This is the Mobile's name that has already been checked/found in the creatures table
					incrementDict.put("myName", myName);

					if (loopAmountInt >= 1)
					{
						for(int i = 0; i < loopAmountInt; i++)
						{
							try
							{
								incrementDict.put("iterationInt", 10);
								messageTo(self, "runLootLoggerIncrement", incrementDict, 5, true);
							}
							catch (Exception e)
							{
								sendSystemMessageTestingOnly(self, "Interrupted! " + e);
							}
						}
					}
					if (remainderInt >= 1)
					{
						incrementDict.put("iterationInt", remainderInt);
						messageTo(self, "runLootLoggerIncrement", incrementDict, 5, true);
					}


					dictionary exportDataFile = new dictionary();
					string tabFileCols = "THIS TOOL IS NOT 100% ACCURATE.\n\n";
					tabFileCols += "Number of "+myName+"'s spawned was "+iteration+"\n";
					tabFileCols += "#\tLoot Template String\tStatic Item String\n";
					exportDataFile.put("exportData", tabFileCols);
					exportDataFile.put("myBag", myBag);

					messageTo(self, "qaSaveData", exportDataFile, 15, true);
				}
			}

		}
		else
		{
			if (scriptString == "none")
				sendSystemMessageTestingOnly(self,"Invalid creature name. Please check your spelling and try again.");

			sendSystemMessageTestingOnly(self,"Invalid dungeon creature name. Please make sure the creature you are spawning is spawned in the dungeon and also can be found in the creature table.");
		}
	}
	else
	{
		sendSystemMessageTestingOnly(self, "Format: /qatool qaspawner <Creature Name> <number of iterations>");
		cleanAllScriptVars(self);
	}
}

//Loot Logger Tool main function
//This function could be run repeatedly in on test if the amount of mobiles spawned is over 10
int lootLoggerMain(obj_id self, int iteration, string creatureSpawned, string scriptString)
{
	int returnInt = 0;
	if (iteration > 0)
	{
		obj_id testerInventoryId = utils.getInventoryContainer(self);

		qa.findOrCreateAndEquipQABag(self, testerInventoryId, false);
		obj_id myBag = getObjectInSlot(self, "back");
		dictionary loggerDictionary = new dictionary();
		loggerDictionary.put("myBag", myBag);
		loggerDictionary.put("testerInventoryId", testerInventoryId);

		for(int i = 0; i < iteration; i++)
		{
			obj_id myMob = create.createCreature(creatureSpawned, getLocation(self), true);
			if (scriptString != "none")
			{
				setObjVar(myMob, "mom", self);
				setObjVar(myMob, "spawn_number", 1);
				attachScript(myMob, scriptString);
			}


			int commandKillMobResult = commandKillMob(self, myMob);

			loggerDictionary.put("myMob", myMob);

			//Message that calls a function after the designated delay and passes the dictionary
			messageTo(self, "qaLootThem", loggerDictionary, 1, true);
			messageTo(self, "qaDestroyMob", loggerDictionary, 2, true);

			returnInt ++;
		}
	}
	return returnInt;
}

string[] retrieveMobileContents(obj_id self, string mobContentsByRow)
{
	if(mobContentsByRow != null && mobContentsByRow != "")
	{
		string[] mobileContentsList = split(mobContentsByRow, '-');

		string[] returnedMoblileList = new string[mobileContentsList.length];
		if (mobileContentsList != null && mobileContentsList.length > 0)
		{
			for (int i = 0; i < mobileContentsList.length; i++)
			{
				 string tempString = mobileContentsList[i].replace('-', ' ');
				 returnedMoblileList[i] = tempString.trim();
			}
		}
		return returnedMoblileList;
	}
	return null;
}

boolean exportTextBagContents (obj_id self, obj_id myBag, string exportString, string mobContentsByRow)
{
	if (isIdValid(myBag))
	{

		obj_id[] qaBagInventoryContents = getContents(myBag);
		if (qaBagInventoryContents.length > 0)
		{

			for (int i = 0; i < qaBagInventoryContents.length; i++)
			{
				if (exportString == "")
				{
					exportString = "\tEquipped Backpack Contents.\n\n";
					exportString += "#\tLoot Template String\tStatic Item String\tObject ID\n";
				}

				exportString += " " + (i+1) + "\t" + getTemplateName(qaBagInventoryContents[i]) + "\t" + getStaticItemName(qaBagInventoryContents[i]) + "\t" + qaBagInventoryContents[i] + "\n";
			}

			if (mobContentsByRow != null && mobContentsByRow != "")
			{
				string[] mobileContents = retrieveMobileContents(self, mobContentsByRow);
				if (mobileContents != null && mobileContents.length > 0)
				{
					exportString += "\n\n\nContents of each mobile creature before looting.\n";
					exportString += "#\t(OID)Item Template\n";
					int u = 1;

					string combinedString = "";
					for (int z = 0; z < mobileContents.length; z++)
					{

						if (mobileContents[z] != null && mobileContents[z] != "")
						{
							string eachItemList[] = split(mobileContents[z], ',');

							if (eachItemList != null && eachItemList.length > 0)
							{

								for (int n = 0; n < eachItemList.length; n++)
								{

									string contentsString = eachItemList[n].replace(',', ' ');
									contentsString = contentsString.trim();

									if (contentsString != "" && contentsString != null)
									{
										combinedString += contentsString + ",";
										contentsString = "";
									}
								}
							}
						}
						if (combinedString != "")
						{
							exportString += " " + u + "\t" + combinedString + "\n";
							u ++;
						}
						combinedString = "";
					}
					u = 0;
				}
			}

			saveTextOnClient(self, "qaDataExport" + getServerFrame() + ".tab", exportString);
			return true;
		}
		else
		{
			sendSystemMessageTestingOnly(self,"No items were looted!");
		}
	}
	return false;
}


void makeHelper(obj_id self, StringTokenizer st)
{
	if(st.hasMoreTokens())
	{
		string argumentString = st.nextToken();
		if(argumentString != "")
		{
			int creatureRowNumber = dataTableSearchColumnForString(argumentString, "creatureName", CREATURE_TABLE);
			if(creatureRowNumber > -1)
			{
				obj_id helperMob = create.createCreature(argumentString, getLocation(self), true);
				attachScript(helperMob, "test.qa_ai_helper_attach");
				sendSystemMessageTestingOnly(self,"Helper Created.  Use radial menu.");
				dictionary creatureRow = dataTableGetRow (CREATURE_TABLE, creatureRowNumber);
				utils.setScriptVar(self, QAHELPER_SCRIPTVAR+".creatureDictionary", creatureRow);
			}
			else
			{
				sendSystemMessageTestingOnly(self,"Creature name invalid.");
			}
		}
	}
}

//BUILDS THE WARP MENU
void toolWarpMenu(obj_id self)
{
	obj_id[] waypointArray = qa.getAllValidWaypoints(self);
	string[] waypointMenu = qa.getMenuList(self, waypointArray, "waypoint menu");
	if (waypointMenu.length > 0)
	{
		location[] waypointWarpLocations = qa.getLocationList(self, waypointArray);
		utils.setScriptVar( self, "qadatapad.warpPoints", waypointWarpLocations );
		string[] combinedMenu = new string[waypointMenu.length + ADD_ON_DATAPAD_MENU.length];
		System.arraycopy(waypointMenu, 0, combinedMenu, 0, waypointMenu.length);
		System.arraycopy(ADD_ON_DATAPAD_MENU, 0, combinedMenu, waypointMenu.length, ADD_ON_DATAPAD_MENU.length);

		qa.refreshMenu(self, DATAPAD_TOOL_PROMPT, DATAPAD_TOOL_TITLE, combinedMenu, "handleWarpScriptOptions", "qadatapad.pid", "qadatapad.warpMenu", sui.OK_CANCEL_REFRESH);
	}
	else
	{
		qa.refreshMenu(self, DATAPAD_TOOL_PROMPT, DATAPAD_TOOL_TITLE, ADD_ON_DATAPAD_MENU, "handleWarpScriptOptions", "qadatapad.pid", "qadatapad.warpMenu", sui.OK_CANCEL_REFRESH);
	}
}

//Object Finder Tool main function
//This is a temp or incomplete funciton
void objectFinderFunction(obj_id self, StringTokenizer st)
{
	if(isSpaceScene())
	{
		sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
	}
	else
	{
		string scriptStrArg = "";

		if(st.hasMoreTokens())
		{
			int stringCount = st.countTokens();
			if(stringCount == 1)
			{
				scriptStrArg = st.nextToken();
				//sendSystemMessageTestingOnly(self, "test worked: " + scriptStrArg);
				string searchType = "";
				if(scriptStrArg.indexOf(".") > -1 && scriptStrArg.indexOf(".iff") == -1)
				{
					searchType = "script";
				}
				else if(scriptStrArg.indexOf("/") > -1 && scriptStrArg.indexOf(".iff") > -1)
				{
					searchType = "template";
				}

				if(searchType != "")
				{
					//sendSystemMessageTestingOnly(self, "Moving to list");
					listObjectsFound(self, scriptStrArg, searchType);
				}
				else
				{
					sendSystemMessageTestingOnly(self, "The tool could not figure out what type of object you were searching for.  Check the string argument");
					cleanAllScriptVars(self);

				}
			}
			if(stringCount > 1)
			{
				sendSystemMessageTestingOnly(self, "The tool only accepts one argument (a script string) without spaces.  Example: /qatool findobj npc.random_quest.quest_setup");
				cleanAllScriptVars(self);
			}
		}
		else
		{
			sendSystemMessageTestingOnly(self, "The Tool requires you to specify the template of the object or the script attached to the object.");
			sendSystemMessageTestingOnly(self, "Example: /qatool findobj object/creature/player/human_male.iff");
			sendSystemMessageTestingOnly(self, "Example: /qatool findobj npc.random_quest.quest_setup");
			sendSystemMessageTestingOnly(self, "If successful, the tool will return a list of objects with the pattern specified by the tester.");
			cleanAllScriptVars(self);
		}
	}
}

//This is a temporary function that exports a list of Mobs that have a specific script attached
void listObjectsFound(obj_id self, string attributeString, string searchType)
{
	if(attributeString.length() > 0)
	{
		if(searchType == "script")
		{
			//sendSystemMessageTestingOnly(self, "one argument of length greater than 0 recieved.");
			obj_id[] allScriptObjectsRadius = getAllObjectsWithScript(getLocation(self), 10000000f, attributeString);
			if(allScriptObjectsRadius.length > 0)
			{
				//sendSystemMessageTestingOnly(self, allObjectsRadius.length + " Objects with that Script found.");
				string[] scriptObjMenu = getObjMenu(self, allScriptObjectsRadius);

				string scriptDynamicPrompt = "Script searched for: " + attributeString + "\n";
				scriptDynamicPrompt += "Found " + scriptObjMenu.length + " objects.\n\nSelect any object below to warp to it's location.";
				qa.refreshMenu (self, scriptDynamicPrompt, OBJECT_FINDER_TITLE, scriptObjMenu, "objectFinderHandler", true, "objFinder.pid", "objFinder.objStrings");
			}
			else
			{
				sendSystemMessageTestingOnly(self, "No objects with that Script were found.");
				cleanAllScriptVars(self);
			}
		}
		else if(searchType == "template")
		{
			obj_id[] allTemplateObjectsRadius = getAllObjectsWithTemplate(getLocation(self), 10000000f, attributeString);
			if(allTemplateObjectsRadius.length > -1)
			{
				string[] templateObjMenu = getObjMenu(self, allTemplateObjectsRadius);

				string templateDynamicPrompt = "Template searched for: " + attributeString + "\n";

				if(templateObjMenu.length >= 1)
				{
					templateDynamicPrompt += "Found " + templateObjMenu.length + " objects.\n\nSelect any object below to warp to it's location.";
					qa.refreshMenu (self, templateDynamicPrompt, OBJECT_FINDER_TITLE, templateObjMenu, "objectFinderHandler", true, "objFinder.pid", "objFinder.objStrings");
				}
				else
				{
					Vector convertOidToString = new Vector();
					for(int i = 0; i < allTemplateObjectsRadius.length; i++)
					{
						utils.addElement(convertOidToString, ""+allTemplateObjectsRadius[i]);

					}
					if(convertOidToString.size() >= 1)
					{
						string[] oidList = new string[convertOidToString.size()];
						convertOidToString.toArray(oidList);
						templateDynamicPrompt += "Found " + oidList.length + " objects.\nTEMPLATE LOOK UP FAILED! Showing OIDs only.\n\nSelect any OID below to warp to it's location.";

						qa.refreshMenu(self, templateDynamicPrompt, OBJECT_FINDER_TITLE, oidList, "objectFinderHandler", true, "objFinder.pid", "objFinder.objStrings");
					}
				}
			}
			else
			{
				sendSystemMessageTestingOnly(self, "No objects with that Template were found. Make sure you include the entire object template to include the '.iff'.  Leave out the 'shared'.  If the tool still fails, try searching for the script attached to the object.");
				cleanAllScriptVars(self);
			}
		}
		else
		{
			sendSystemMessageTestingOnly(self, "The tool did not know what type of object you were searching for.  Inform the tool team.");
			cleanAllScriptVars(self);
		}
	}
}

//This is a temporary function that exports a list of Objects that have a specific script attached

string[] getObjMenu(obj_id self, obj_id[] allObjOIDs)
{
	if(allObjOIDs.length > 0)
	{
		//sendSystemMessageTestingOnly(self, "allObjOIDs.length " + allObjOIDs.length);
		resizeable string[] objMenu = new string[0];

		for(int i = 0; i < allObjOIDs.length; i++)
		{
			string encodeString = getEncodedName(allObjOIDs[i]);
			//sendSystemMessageTestingOnly(self, ""+encodeString);
			if (encodeString.length() > 0)
			{
				utils.addElement(objMenu, encodeString + "  ( " + allObjOIDs[i] + " )");
			}
		}

		if(objMenu.length > -1)
		{
			string[] arrayStrings = new string[objMenu.size()];
			objMenu.toArray(arrayStrings);
			Arrays.sort(arrayStrings);

			return arrayStrings;
		}
	}
	else
	{
		sendSystemMessageTestingOnly(self, "The function didn't receive a list of objects.  Make sure the spelling of the template is correct.  Report problems to the tool team.");
		cleanAllScriptVars(self);
	}
	return null;
}

//SPEC TOOL START

//Specs Tester Character to have specific 'template' of profession, armor, weapon, faction, etc.
boolean specTester(obj_id self, StringTokenizer st)
{
	if(isSpaceScene())
	{
		sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
	}
	else
	{
		string professionStr = "";
		int levelInt = 1;
		int testerLevel = 0;
		string factionStr = "neu";
		string armorStr = "none";
		string weaponStr = "none";
		obj_id testerInventoryId = utils.getInventoryContainer(self);

		if(st.hasMoreTokens())
		{
			professionStr = st.nextToken();
			if(professionStr == "?")
			{
				sui.msgbox(self, self, SPECMEPOPUP, sui.OK_ONLY, QATOOL_TITLE, "noHandler" );
				return true;
			}
			else
			{
				int stringCount = st.countTokens();
				//sendSystemMessageTestingOnly(self, "stringCount: "+stringCount);
				if(stringCount > 0 && stringCount <= 4)
				{
					if(professionStr != "")
					{
						try
						{
							levelInt = Integer.parseInt(st.nextToken());
						}
						catch(Exception e)
						{
							sendSystemMessageTestingOnly(self, "You failed to specify a profession level.");
							return false;
						}

						if(levelInt > 90)
						{
							sendSystemMessageTestingOnly(self, "90th Level is max.");
							return false;
						}
						//Example: /qatool spec smu 22 rebsf recon pistol.

						string[] roadmapList = gm.getRoadmapList();
						string professionCodeString = validateProfession(self, professionStr, roadmapList);
						if(professionCodeString != "ERROR")
						{
							int currentCombatXp = getExperiencePoints(self, "combat_general");
							grantExperiencePoints(self, "combat_general", -currentCombatXp);
							skill.recalcPlayerPools(self, true);

							qa.revokeAllSkills(self);
							string[] professionAndNoviceSkill = split(professionCodeString, '-');

							setSkillTemplate(self, professionAndNoviceSkill[0]);
							string professionPrefix = professionAndNoviceSkill[1];

							for(int i = 0; i < 24; i++)
							{
								testerLevel = getLevel(self);
								if(levelInt > testerLevel)
								{
									skill.grantSkillToPlayer(self, professionPrefix+PROFESSION_SKILL_NAMES[i]);
								}
								else
								{
									break;
								}
							}
							if(st.hasMoreTokens())
							{
								factionStr = st.nextToken();
								if(factionStr != "none")
								{
									boolean factionSuccess = attainCorrectFaction(self, factionStr);
									if(!factionSuccess)
										return false;
									boolean factionStatusSuccess = attainCorrectFactionStatus(self, factionStr);
									if(!factionStatusSuccess)
									{
										return false;
									}
								}
								if(st.hasMoreTokens())
								{
									armorStr = st.nextToken();
									if(armorStr != "none")
									{
										boolean miscItem = false;
										int miscIndex = -1;
										for(int i = 0; i < MISC_SEARCH_MULTIARRAY[0].length; i++)
										{
											if(MISC_SEARCH_MULTIARRAY[0][i].indexOf(armorStr) == 0)
											{
												miscItem = true;
												miscIndex = i;
											}
										}

										if(!miscItem)
										{
											boolean allArmorSpawned = spawnItems(self, armorStr, ARMOR_SEARCH_MULTIARRAY, ARMOR_STATS_TABLE);
											if(allArmorSpawned)
											{
												sendSystemMessageTestingOnly(self, "Armor spawned without error.");
												qa.findOrCreateAndEquipQABag(self, testerInventoryId, true);
											}
										}
										else
										{
											boolean miscItemSpawned = spawnItems(self, armorStr, MISC_SEARCH_MULTIARRAY, MASTER_ITEM_TABLE);
											if(miscItemSpawned)
											{
												sendSystemMessageTestingOnly(self, "Items spawned without error.");
												qa.findOrCreateAndEquipQABag(self, testerInventoryId, true);
											}
											else
											{
												return false;
											}
										}
									}
								}
								if(st.hasMoreTokens())
								{
									weaponStr = st.nextToken();
									if(weaponStr != "none")
									{
										boolean allWeaponsSpawned = spawnItems(self, weaponStr, WEAPON_SEARCH_MULTIARRAY, WEAPON_STATS_TABLE);
										if(allWeaponsSpawned)
										{
											sendSystemMessageTestingOnly(self, "Weapons spawned without error.");
											qa.findOrCreateAndEquipQABag(self, testerInventoryId, true);
											return true;
										}
									}
								}
								else
								{
									//the tester did not specify any additional args
									return true;
								}
								if(armorStr == "none" && weaponStr == "none")
								{
									//sendSystemMessageTestingOnly(self, "Armor & Weapon argument null.");
									return true;
								}

							}
							else
							{
								//the tester did not need the faction, armor or weapon options
								return true;
							}
						}
					}
				}
			}
		}
	}
	sendSystemMessageTestingOnly(self, "***There was a problem trying to implement all tool arguments***");
	return false;
}

boolean spawnItems(obj_id self, string searchString, string[][] arrayOfArrays, string datatableName)
{
	if(searchString != "")
	{
		string searchSpawnString = "";
		for(int m = 0; m < arrayOfArrays[0].length; m++)
		{
			if(arrayOfArrays[0][m].indexOf(searchString) == 0)
			{
				//sendSystemMessageTestingOnly(self, "Found item in list " + arrayOfArrays[0][m]);
				searchSpawnString = arrayOfArrays[1][m];
				//sendSystemMessageTestingOnly(self, "Searching for " + arrayOfArrays[1][m]);
			}
		}
		//sendSystemMessageTestingOnly(self, "item searchSpawnString: " + searchSpawnString);
		if(searchSpawnString != "")
		{
			//get a list of row numbers for ea armor piece to spawn later
			Vector itemRowList = new Vector();
			Vector itemSpawnStringList = new Vector();
			string[] itemSpawnStrListArray = dataTableGetStringColumn(datatableName,"name");

			if(itemSpawnStrListArray.length > 0)
			{
				//sendSystemMessageTestingOnly(self, "itemSpawnStrListArray.length: " + itemSpawnStrListArray.length);

				for(int x = 0; x < itemSpawnStrListArray.length; x++)
				{
					if(itemSpawnStrListArray[x].indexOf(searchSpawnString) == 0)
					{
						utils.addElement(itemRowList, ""+x);
					}
				}
				//sendSystemMessageTestingOnly(self, "itemRowList.size(): " + itemRowList.size());

				if(itemRowList.size() > -1)
				{
					//toArray will work with string only - convert back to int later
					string[] allItemRows = new string[itemRowList.size()];
					itemRowList.toArray(allItemRows);
					string itemString = "";

					for(int j = 0; j < allItemRows.length; j++)
					{
						itemString =  dataTableGetString(datatableName, utils.stringToInt(allItemRows[j]), "name");
						utils.addElement(itemSpawnStringList, itemString);
					}

					if(itemSpawnStringList.size() > -1)
					{
						string[] allStrings = new string[itemSpawnStringList.size()];
						itemSpawnStringList.toArray(allStrings);
						//sendSystemMessageTestingOnly(self, "allStrings.length: " + allStrings.length);
						if(allStrings.length > 0)
						{
							for(int z = 0; z < allStrings.length; z++)
							{
								qa.spawnStaticItemInInventory(self, allStrings[z], "none");
							}
						}
						return true;
					}
				}
			}
		}
	}
	return false;
}

boolean attainCorrectFactionStatus(obj_id self, string factionStr)
{
	if(factionStr != "")
	{
		if(factionStr.indexOf("sf") == 3)
		{
			if(factions.isRebel(self) || factions.isImperial(self))
			{
				setObjVar(self, "intChangingFactionStatus", 1);
				factions.goOvert(self);
				return true;
			}
		}
		else if(factionStr.indexOf("cm") == 3)
		{
			if(factions.isRebel(self) || factions.isImperial(self))
			{
				setObjVar(self, "intChangingFactionStatus", 1);
				factions.goCovert(self);
				return true;
			}
		}
		else if(factionStr.indexOf("ol") == 3)
		{
			if(factions.isRebel(self) || factions.isImperial(self))
			{
				setObjVar(self, "intChangingFactionStatus", 1);
				factions.goOnLeave(self);
				return true;
			}
		}
		else
		{
			if(factions.isNeutral(self))
			{
				sendSystemMessageTestingOnly(self, "Neutral");
				return true;
			}
			sendSystemMessageTestingOnly(self, "Failure Neutral");
		}
	}
	return false;
}

boolean attainCorrectFaction(obj_id self, string factionStr)
{
	if(factionStr != "")
	{
		string fullFactionName = "";
		if(factionStr.indexOf("reb") == 0)
		{
			fullFactionName = factions.FACTION_REBEL;
		}
		else if(factionStr.indexOf("imp") == 0)
		{
			fullFactionName = factions.FACTION_IMPERIAL;
		}
		else if(factionStr.indexOf("neu") == 0)
		{
			fullFactionName = factions.FACTION_NEUTRAL;
		}
		else
		{
			sendSystemMessageTestingOnly(self, "Unknown faction. Setting faction to Neutral.");
			fullFactionName = factions.FACTION_NEUTRAL;
		}

		if(fullFactionName != "")
		{
			int factionNum = factions.getFactionNumber(fullFactionName);
			int factionHashCode = dataTableGetInt(factions.FACTION_TABLE, factionNum, "pvpFaction");
			pvpSetAlignedFaction(self, factionHashCode);
			return true;
		}
	}
	return false;
}

string validateProfession(obj_id self, string professionStr, string[] roadmapList)
{
	if(professionStr != "" && roadmapList.length > 0)
	{
		string professionCodeStr = "";
		professionStr = toLower(professionStr);
		if(professionStr.indexOf("smu") > -1)
		{
			professionCodeStr = roadmapList[0] + "-" + PROFESSION_PREFIX[0];
		}
		else if(professionStr.indexOf("bou") > -1 || professionStr == "bh")
		{
			professionCodeStr = roadmapList[1] + "-" + PROFESSION_PREFIX[1];
		}
		else if(professionStr.indexOf("off") > -1)
		{
			professionCodeStr = roadmapList[2] + "-" + PROFESSION_PREFIX[2];
		}
		else if(professionStr.indexOf("com") > -1)
		{
			professionCodeStr = roadmapList[3] + "-" + PROFESSION_PREFIX[3];
		}
		else if(professionStr.indexOf("jed") > -1 || professionStr.indexOf("for") > -1)
		{
			professionCodeStr = roadmapList[4] + "-" + PROFESSION_PREFIX[4];
		}
		else if(professionStr.indexOf("med") > -1)
		{
			professionCodeStr = roadmapList[5] + "-" + PROFESSION_PREFIX[5];
		}
		else if(professionStr.indexOf("spy") > -1)
		{
			professionCodeStr = roadmapList[6] + "-" + PROFESSION_PREFIX[6];
		}
		else
		{
			professionCodeStr = "ERROR";
		}
		if(professionCodeStr != "")
		{
			return professionCodeStr;
		}
		else
		{
			professionCodeStr = "ERROR";
		}
	}

	return "ERROR";
}

boolean earnProfessionLevel(obj_id self)
{
	string skillName = getWorkingSkill(self);

	dictionary xpReqs = getSkillPrerequisiteExperience(skillName);
	if (xpReqs == null || xpReqs.isEmpty())
	{
		sendSystemMessageTestingOnly(self, "Current working skill is invalid.");
	}

	java.util.Enumeration e = xpReqs.keys();
	string xpType = (string)(e.nextElement());
	int xpCost = xpReqs.getInt(xpType);
	int curXP = getExperiencePoints(self, xpType);
	if(curXP < xpCost)
	{
		grantExperiencePoints(self, xpType, xpCost - curXP);
	}
	skill_template.earnWorkingSkill(self);
	return true;
}

//SPEC TOOL END

boolean mulipleStaticSpawn(obj_id self, string spawnString, string intNumber, boolean silent)
{
	if(spawnString != "" && intNumber != "")
	{
		obj_id inv = utils.getInventoryContainer(self);
		if(isIdValid(inv))
		{
			obj_id[] objContents = utils.getContents(inv, true);
			if(objContents.length >= 80)
			{
				sendSystemMessageTestingOnly(self, "Empty your inventory before trying to spawn more items");
			}
			else
			{
				int loopInt = utils.stringToInt(intNumber);
				if(loopInt != -1)
				{
					//spawnStaticItemInInventory(obj_id self, string staticItemString, string altMessage, boolean silent)
					obj_id itemSpawned = qa.spawnStaticItemInInventory(self, spawnString, "none", true);
					if(isIdNull(itemSpawned))
					{
						sendSystemMessageTestingOnly(self, "Bad Spawn String.");
						return false;
					}
					else
					{
						for(int x = 0; x < loopInt-1; x++)
						{
							static_item.createNewItemFunction(spawnString, inv);
						}
					}
				}
				else
				{
					sendSystemMessageTestingOnly(self, "The tool requires the following usage to function: /qatool mutli <static_item_spawn_string> <integer> ");
					return false;
				}
			}
		}
		else
		{
			sendSystemMessageTestingOnly(self, "inventory id failed.");
			return false;
		}
	}
	else
	{
		sendSystemMessageTestingOnly(self, "The tool requires the following usage to function: /qatool mutli <static_item_spawn_string> <integer> ");
		return false;
	}
	if (!silent)
		sendSystemMessageTestingOnly(self, "Done.");
	return true;
}

//retrieves a current level of skill mods from the skill table
void getAllSkillMods(obj_id self)
{
	string[] allSkillModsList = dataTableGetStringColumn(SKILL_MOD_TABLE, "skill_mod");
	if(allSkillModsList.length > -1)
	{
		string combinedString = "This is a current list of all valid combat profession skill mods in SWG:\n\n";

		for(int x = 0; x < allSkillModsList.length; x++)
		{
			//"stat_n", located at data/sku.0/sys.shared/built/game/string/en/stat_n.stf
			combinedString +=  localize(new string_id( "stat_n", allSkillModsList[x])) + "\t\t\t" + allSkillModsList[x] + "\n";

		}
		if(combinedString != "")
		{
			sui.msgbox(self, self, combinedString, sui.OK_ONLY, "Skill Mods", "noHandler" );

		}
	}
}

void saveAllCurrentQuestData(obj_id self)
{
	try
	{
		string allQuestData = "";
		string[] allQuests = qa.getAllQuests(self);
		if (allQuests.length > 0)
		{
			for (int i = 0; i < allQuests.length; i++)
			{
				allQuestData += allQuests[i] + "\r";
			}
			saveTextOnClient(self, "questData.txt", allQuestData);
		}
	}
	catch (Exception e)
	{
		sendSystemMessageTestingOnly(self, "Unable to dump quest data due to internal exception or because the test character has no quests.");
	}
}

void setWeather(obj_id self, int weatherSelected)
{
	setWeatherData(weatherSelected, 0.01f, 0.01f);
	messageTo(self, "animateForceDestruction", null, 9.0f, true);
}

void getNamesArray(obj_id player)
{
	string[] codeStringArray = dataTableGetStringColumn(CUBE_DATATABLE_1, "finalTemplate");
	string[] showNamesArray = new string[codeStringArray.length];
	for(int i = 0; i < codeStringArray.length; i++)
	{
		if(codeStringArray[i].endsWith(".iff"))
		{
			//Get the indexOf the last "/"
			int idxSlash = codeStringArray[i].lastIndexOf("/") + 1;
			//Get the index of the last "."
			int idxPeriod = codeStringArray[i].lastIndexOf(".");
			//Place our findings in the string "lookup"
			string lookUp = codeStringArray[i].substring(idxSlash, idxPeriod) + "_n";
			//sendSystemMessageTestingOnly(player, lookUp);

			showNamesArray[i] = localize(new string_id("som/som_item", lookUp));
		}
		else
		{
			showNamesArray[i] = localize(new string_id("static_item_n", codeStringArray[i]));
		}
		showNamesArray[i] = showNamesArray[i] + ": (" + codeStringArray[i] + ")";
	}
	utils.setScriptVar(player, "qa_cube.codeStringArray", codeStringArray);
	utils.setScriptVar(player, "qa_cube.showNamesArray", showNamesArray);
}

void emailSpamFunction(obj_id self, StringTokenizer st)
{
	int spamAmount = 0;
	if(st.hasMoreTokens())
	{
		try
		{
			spamAmount = Integer.parseInt(st.nextToken());
		}
		catch(Exception e)
		{
			sendSystemMessageTestingOnly(self, "You failed to specify the amount of spam.");
		}
		if (spamAmount > 0)
		{
			for(int i = 0; i < spamAmount; i++)
			{
				utils.sendMail(NEW_CITY_STRUCTURE_SUBJECT, NEW_CITY_STRUCTURE_BODY, self, getName(self));
			}
			sendSystemMessageTestingOnly(self, "Spamming completed.");
		}
		else
		{
			sendSystemMessageTestingOnly(self, "You failed to specify the amount of spam.");
		}
	}
	else
	{
		sendSystemMessageTestingOnly(self, "You failed to specify the amount of spam.");
	}
}

void checkMobContents(obj_id self, obj_id mobile)
{
	string previousMobileContents = "";
	if(utils.hasScriptVar(self, "lootLogger.mobContents"))
	{
		previousMobileContents = utils.getStringScriptVar(self, "lootLogger.mobContents");
	}
	else
	{
		utils.setScriptVar(self, "lootLogger.mobContents", "");
	}
	if (isValidId(mobile))
	{
		obj_id mobileInv = utils.getInventoryContainer(mobile);
		obj_id contents[] = getContents(mobileInv);
		string mobileContentsExport = "";

		if (contents.length > 0)
		{
			for (int i = 0; i < contents.length; i++)
			{
				mobileContentsExport += "(" +contents[i] + ")" + getTemplateName(contents[i]) + ",";
			}

			string combinedContentsString = previousMobileContents + "-" + mobileContentsExport;
			utils.setScriptVar(self, "lootLogger.mobContents", combinedContentsString);
		}
	}
}

void qaFishing(obj_id self, StringTokenizer st, string scriptString)
{

	string myName = null;

	boolean continueFishing = true;

	location here = getLocation(self);

	if (!minigame.isLocationFishable(here))
	{
		sendSystemMessageTestingOnly(self, "You must be within 2 meters of fishable water and facing it to start fishing.");

		return;
	}


	if(continueFishing)
	{

		int iteration = 0;

		if(st.hasMoreTokens())
		{
			iteration = Integer.parseInt(st.nextToken());
		}
		else
		{
			iteration = 1;
		}

		if(iteration > 100)
		{
			iteration = 100;
			sendSystemMessageTestingOnly(self, "Catch limit = 1 to 100");
		}
		if(iteration < 1)
		{
			iteration = 1;
			sendSystemMessageTestingOnly(self, "Catch limit = 1 to 100");
		}

		if (iteration <= 100)
		{

			for(int i = 0; i < iteration; i++)
			{
				obj_id myCatch = minigame.spawnFishingFish(self, here);
			}

		}

	}

}

void qaEnableCollectionClickBypass(obj_id self, StringTokenizer st, string scriptString)
{
	utils.setScriptVar(self, "collection.qa.clickBypass", 0);
	sendSystemMessageTestingOnly(self, "Collection Click Bypass Enabled. Logout to reset to normal collecting.");
}


int qaSetScriptVar(obj_id self, StringTokenizer st)
{

	if (st.hasMoreTokens())

	{
		string scriptVarName = st.nextToken();
		string scriptVarValue = "0";

		if(st.hasMoreTokens())
		{
			scriptVarValue = st.nextToken();
		}

		obj_id target = qaGetTarget(self);

		if (isIdValid(target))
		{
			target = self;
		}

		utils.setScriptVar(target, scriptVarName, utils.stringToInt(scriptVarValue));

		debugSpeakMsg(self, "Scriptvar " + scriptVarName + " = " + scriptVarValue + " set on OID " + target);

		return SCRIPT_CONTINUE;
	}
	else
		debugSpeakMsg(self, "parameters are updateScriptvar <scriptVarName> <scriptVarValue>");

	return SCRIPT_CONTINUE;

}

void qaExportBackpackContents(obj_id self)
{

	obj_id testerInventoryId = utils.getInventoryContainer(self);
	obj_id[] testerInventoryContents = getContents(testerInventoryId);
	obj_id myBag = getObjectInSlot(self, "back");

	if (isIdValid(myBag))
	{

		dictionary exportDataFile = new dictionary();

		exportDataFile.put("exportData", "");
		exportDataFile.put("myBag", myBag);
		messageTo(self, "qaSaveData", exportDataFile, 15, true);

	}
	else
	{
		sendSystemMessageTestingOnly(self,"Invalid backpack or no backpack equipped");
	}

}

int commandKill(obj_id self, obj_id target)
{

	if (!isIdValid(self) || !isIdValid(target) || !exists(target))
	{
		sendSystemMessageTestingOnly(self, "Kill command failed.");
		return SCRIPT_CONTINUE;
	}

	obj_id objMyShip = space_transition.getContainingShip(self);

	if (space_utils.isShip(objMyShip))
	{
		int commandKillShipResult = commandKillShip(self, target);
		return SCRIPT_CONTINUE;

	}
	else if (target==self)
	{
		sendSystemMessageTestingOnly(self,"Kill Command Failed. Cannot Kill self.");
		return SCRIPT_CONTINUE;
	}
	else if (isPlayer(target))
	{
		setPosture(target, POSTURE_INCAPACITATED);
		pclib.coupDeGrace(self, self, true, true);
		CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has killed (" + target + ") " + utils.getStringName(target) + " using the kill command.");
		return SCRIPT_CONTINUE;
	}


	else if (isMob(target))
	{
		if (isIncapacitated(target))
		{
			sendSystemMessageTestingOnly(self,"Kill Command. Target is already dead.");
			return SCRIPT_CONTINUE;
		}

		int commandKillMobResult = commandKillMob(self, target);

		CustomerServiceLog("qaTool","User: (" + self + ") " + getName(self) + " has killed (" + target + ") " + utils.getStringName(target) + " using the kill command.");
		return SCRIPT_CONTINUE;
	}
	else
	{
		sendSystemMessageTestingOnly(self, "you must have a valid player or mobile target to use this command");
		return SCRIPT_CONTINUE;
	}

}

int commandKillShip(obj_id self, obj_id target)
{

	if (!isIdValid(self) || !isIdValid(target) || !exists(target))
	{
		sendSystemMessageTestingOnly(self, "Kill ship command failed.");
		return SCRIPT_CONTINUE;
	}

	obj_id objMyShip = space_transition.getContainingShip(self);


	if(!isIdValid(target) || !isIdValid(objMyShip))
	{
		sendSystemMessageTestingOnly(self, "You must be in space and target a ship to destroy it");
		return SCRIPT_CONTINUE;
	}
	if(target==self)
	{
		sendSystemMessageTestingOnly(self, "DO NOT DESTROY YOURSELF");
		return SCRIPT_CONTINUE;
	}


	if(target==objMyShip)
	{
		sendSystemMessageTestingOnly(self, "DO NOT DESTROY YOURSELF");
		return SCRIPT_CONTINUE;
	}


	notifyShipDamage(target, objMyShip, 10.0f);
	space_combat.doChassisDamage(objMyShip, target, 0 ,1.0f);
	setShipCurrentChassisHitPoints(target, 0.0f);

	utils.setLocalVar(target, "space.give_rewards", 1);

	space_combat.targetDestroyed(target);

	space_combat.setDeathFlags(target);

	float fltIntensity = rand(0, 1.0f);
	handleShipDestruction(target, fltIntensity);

	space_combat.doDeathCleanup(target);

	return SCRIPT_CONTINUE;

}

int commandKillMob(obj_id self, obj_id target)
{
	if (!isIdValid(self) || !isIdValid(target) || !exists(target))
	{
		sendSystemMessageTestingOnly(self, "Kill command failed.");
		return SCRIPT_CONTINUE;
	}


	const string ATTACK_TYPE = "combat_rangedspecialize_pistol";

	int damage = getMaxHealth(target)+1;

	resizeable obj_id[] attackerList = utils.getResizeableObjIdBatchScriptVar(target, "creditForKills.attackerList.attackers");
	attackerList = utils.addElement(attackerList, self);
	utils.setBatchScriptVar(target, "creditForKills.attackerList.attackers", attackerList);

	utils.setScriptVar(target, "creditForKills.attackerList." + self + ".damage", damage);

	utils.setScriptVar(target, "creditForKills.damageCount", 100);
	utils.setScriptVar(target, "creditForKills.damageTally", damage);

	resizeable obj_id[] types = utils.getResizeableObjIdBatchScriptVar(target, "creditForKills.attackerList." +self+ ".xp.types");

	//sendSystemMessageTestingOnly(self, "creditForKills.attackerList." +self+ ".xp.types");

	types = utils.addElement(types, ATTACK_TYPE);
	utils.setBatchScriptVar(target, "creditForKills.attackerList." +self+ ".xp.types", types);

	utils.setScriptVar(target, "creditForKills.attackerList." + self + ".xp."+ ATTACK_TYPE, damage);

	//DO NOT USE "kill(target)". It bypasses OnIncapacitate which has some important cleanup tasks.
	//setHealth to zero appears to work for all Mob cases

	setHealth(target, -5000);

	return SCRIPT_CONTINUE;

}

obj_id qaGetTarget(obj_id self, string override)
{
	obj_id lookAtTarget = getLookAtTarget(self);
	obj_id intendedTarget = getIntendedTarget(self);
	obj_id target = null;

	if(isIdValid(lookAtTarget))
	{
		if (isIdValid(intendedTarget))
		{
			//requires override; any string is considered an override
			//default kill intendedTarget and not lookAtTarget

			if(override == null)
			{
				target = intendedTarget;
			}
			else
			{
				target = lookAtTarget;
			}
		}
		else
		{
			target = lookAtTarget;
		}
	}
	else
	{
		target = intendedTarget;
	}

	return target;
}

obj_id qaGetTarget(obj_id self)
{
	obj_id target = qaGetTarget(self, null);

	return target;
}

boolean createEnzyme(obj_id self, StringTokenizer st)
{
	if(isSpaceScene())
	{
		sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
	}

	else
	{
		string mutagenStr = "";
		string purityStr = "";
		int mutagen = 1;
		int purity = 1;
		obj_id testerInventoryId = utils.getInventoryContainer(self);

		if(st.hasMoreTokens())
		{
			mutagenStr = st.nextToken();
			if(mutagenStr == "?")
			{
				return true;
			}
			else
			{
				if(mutagenStr != "")
				{
					mutagen = Integer.parseInt(mutagenStr);
					if(mutagen > 20 || mutagen < 1)
					{
						sendSystemMessageTestingOnly(self, "The mutagen value must be between 1 and 20.");
						return false;
					}
				}

				if(st.hasMoreTokens())
				{
					purityStr = st.nextToken();
					if(purityStr == "?")
					{
						//sui.msgbox(self, self, SPECMEPOPUP, sui.OK_ONLY, QATOOL_TITLE, "noHandler" );
						return true;
					}
					else
					{
						if(purityStr != "")
						{
							purity = Integer.parseInt(purityStr);
							if(purity > 20 || purity < 1)
							{
								sendSystemMessageTestingOnly(self, "The purity value must be between 1 and 20.");
								return false;
							}
						}
					}
				}
			}
		}
		float mutagenFloat = mutagen;
		float purityFloat = purity;
		obj_id enzyme;






		if(getVolumeFree(testerInventoryId) <= 0)
		{
			sendSystemMessage(self, "Failed to create Enzyme, please make sure that your inventory is not full.", null);
			return false;
		}

		enzyme = createObject("object/tangible/loot/beast/enzyme_3.iff", testerInventoryId, "");

		if(isValidId(enzyme))
		{
			setObjVar (enzyme, "enzyme.enzyme_mutagen", mutagenFloat);
			setObjVar (enzyme, "enzyme.enzyme_purity", purityFloat);
			sendSystemMessageTestingOnly(self, "Created an Enzyme with the values: Mutagen: " + mutagen + " and Purity: " + purity);
		}

		else
		{
			sendSystemMessageTestingOnly(self, "Failed to create Enzyme, please make sure that your inventory is not full.");

		}
	}

	return true;
}

boolean createLyase(obj_id self)
{
	if(isSpaceScene())
	{
		sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
	}

	else
	{

		int randomStat = 11;

		obj_id testerInventoryId = utils.getInventoryContainer(self);
		//float randomFloat = randomStat;
		obj_id lyase;

		if(getVolumeFree(testerInventoryId) <= 0)
		{
			sendSystemMessage(self, "Failed to create Enzyme, please make sure that your inventory is not full.", null);
			return false;
		}

		lyase = createObject("object/tangible/loot/beast/enzyme_2.iff", testerInventoryId, "");

		if(isValidId(lyase))
		{
			dictionary params = new dictionary();
			params.put("lyase", lyase);

			messageTo(self, "makeLyase", params, 2, false);
		}

		else
		{
			sendSystemMessageTestingOnly(self, "Failed to create Enzyme, please make sure that your inventory is not full.");

		}
	}

	return true;
}

messageHandler makeLyase()
{
	obj_id lyaseObject = params.getObjId("lyase");
	setObjVar (lyaseObject, "beast.enzyme.randomStats", 11);
	if(hasObjVar(lyaseObject, "beast.enzyme.freeStatName"))
	{
		removeObjVar (lyaseObject, "beast.enzyme.freeStatName");
	}
	sendSystemMessageTestingOnly(self, "Created a Lyase Enzyme with the values: random Stats: 11");

	return SCRIPT_CONTINUE;
}


boolean clearHeroicTimer(obj_id self)
{

	if(hasObjVar(self, "instance_player_data"))
	{
		removeObjVar(self, "instance_player_data");
		sendSystemMessageTestingOnly(self, "Removed instance_player_data from: " + self + " - Heroic timers reset");
		return true;
	}

	else
	{
		sendSystemMessageTestingOnly(self, "QA tool could not find the objvar instance_player_data on the player: " + self);
	}

	return false;
}

boolean createIsomerase(obj_id self)
{
	if(isSpaceScene())
	{
		sendSystemMessageTestingOnly(self, "You have to be on the ground to use this tool.");
	}

	else
	{

		obj_id testerInventoryId = utils.getInventoryContainer(self);
		//float randomFloat = randomStat;
		obj_id isomerase;

		if(getVolumeFree(testerInventoryId) <= 0)
		{
			sendSystemMessage(self, "Failed to create Enzyme, please make sure that your inventory is not full.", null);
			return false;
		}

		isomerase = createObject("object/tangible/loot/beast/enzyme_1.iff", testerInventoryId, "");

		if(isValidId(isomerase))
		{
			//setObjVar (lyase, "beast.enzyme.quality", quality);
			dictionary params = new dictionary();
			params.put("iso", isomerase);
			messageTo(self, "makeIso", params, 2, false);
		}

		else
		{
			sendSystemMessageTestingOnly(self, "Failed to create Enzyme, please make sure that your inventory is not full.");

		}
	}

	return true;
}

messageHandler makeIso()
{
	float quality = 90;
	obj_id isoObject = params.getObjId("iso");
	setObjVar (isoObject, "beast.enzyme.quality", quality);
	sendSystemMessageTestingOnly(self, "Created a Isomerase Enzyme with the values: random Stats: 90%");

	return SCRIPT_CONTINUE;
}


void qaTCGMenu(obj_id self)
{
	if(!isIdValid(self) || !exists(self) || !isGod(self))
	{
		return;
	}

	qa.refreshMenu(self, "Select...", "-SWG TCG Menu-", TCG_MENU, "handleTCGMenu", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);
}

messageHandler handleTCGMenu()
{
	if(!isGod(self))
	{
		return SCRIPT_CONTINUE;
	}

	obj_id player = sui.getPlayerId(params);
	int idx = sui.getListboxSelectedRow(params);
	int btn = sui.getIntButtonPressed(params);

	if(btn == sui.BP_CANCEL)
	{
		cleanAllScriptVars(self);
		return SCRIPT_CONTINUE;
	}

	switch (idx)
	{
		case 0:
			scheduled_drop.dropCard(scheduled_drop.SYSTEM_COMBAT_NORMAL, self);
			sendSystemMessageTestingOnly(self, "Item placed in inventory.");
			qaTCGMenu(self);
			break;
		case 1:
			if(!hasObjVar(self, "qa_tcg"))
			{
				setObjVar(self, "qa_tcg", 1);
				sendSystemMessageTestingOnly(self, "TCG Info flag has been set on your character.");
				qa.refreshMenu(self, "Select...", "-SWG TCG Menu-", TCG_MENU, "handleTCGMenu", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);
				return SCRIPT_CONTINUE;
			}
			else
			{
				removeObjVar(self, "qa_tcg");
				sendSystemMessageTestingOnly(self, "TCG Info flag has been removed from your character.");
				qa.refreshMenu(self, "Select...", "-SWG TCG Menu-", TCG_MENU, "handleTCGMenu", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);
				return SCRIPT_CONTINUE;
			}
		case 2:
			if(!hasObjVar(self, "qa_tcg_always_drop"))
			{
				setObjVar(self, "qa_tcg_always_drop", 1);
				sendSystemMessageTestingOnly(self, "TCG always drop flag has been set on your character.");
				qa.refreshMenu(self, "Select...", "-SWG TCG Menu-", TCG_MENU, "handleTCGMenu", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);
				return SCRIPT_CONTINUE;
			}
			else
			{
				removeObjVar(self, "qa_tcg_always_drop");
				sendSystemMessageTestingOnly(self, "TCG always drop flag has been removed from your character.");
				qa.refreshMenu(self, "Select...", "-SWG TCG Menu-", TCG_MENU, "handleTCGMenu", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);
				return SCRIPT_CONTINUE;
			}
		case 3:
			qaTCGCardClusterInfo(self);
			break;
		case 4:
			qaTCGBoosterClusterInfo(self);
			break;
		case 5:
			qaTCGReinit(self);
			break;
		default:
			break;
	}

	return SCRIPT_CONTINUE;
}

string [] tcgClusterInfo(string type)
{
	string [] scheduledPromotions = scheduled_drop.getScheduledPromotions(type);

	if(scheduledPromotions == null || scheduledPromotions.length <= 0)
	{
		return null;
	}

	string [] promotions = scheduled_drop.validatePromotionsVersusCluster(scheduledPromotions);

	if(promotions == null || promotions.length <= 0)
	{
		return null;
	}

	int [] cardsLeft = new int[promotions.length];

	string [] listBoxInfo = new string[promotions.length * 2];

	obj_id tatooine = getPlanetByName("tatooine");

	for(int i = 0, j = promotions.length; i < j; i++)
	{
		cardsLeft[i] = getIntObjVar(tatooine, "tcg." + promotions[i] + ".count");

		listBoxInfo[i * 2] = promotions[i];

		if(cardsLeft[i] == -1)
		{
			listBoxInfo[(i * 2) + 1] = "Items Left: Infinite";
		}
		else
		{
			int maximumDrops = scheduled_drop.getPromotionMaxDrop(promotions[i]);

			listBoxInfo[(i * 2) + 1] = "Maximum drops: " + maximumDrops + " Items Left: " + cardsLeft[i];
		}
	}

	return listBoxInfo;
}

void qaTCGCardClusterInfo(obj_id self)
{
	string [] listBoxInfo = tcgClusterInfo("card");

	if(listBoxInfo == null || listBoxInfo.length <= 0)
	{
		sendSystemMessageTestingOnly(self, "No promotions running.");
		return;
	}

	qa.refreshMenu(self, "Select...", "-SWG Card Promotions-", listBoxInfo, "handleTCGPromotionMenu", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);
}

void qaTCGBoosterClusterInfo(obj_id self)
{
	string [] listBoxInfo = tcgClusterInfo("item");

	if(listBoxInfo == null || listBoxInfo.length <= 0)
	{
		sendSystemMessageTestingOnly(self, "No promotions running.");
		return;
	}

	qa.refreshMenu(self, "Select...", "-SWG Item Promotions-", listBoxInfo, "handleTCGPromotionMenu", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);
}

void qaTCGReinit(obj_id self)
{
	sendSystemMessageTestingOnly(self, "Promotions Reinitialized!  Planet tatooine: " + getPlanetByName("tatooine"));

	scheduled_drop.removeClusterPromotions();
	scheduled_drop.removeLastClusterUpdateTime();
	scheduled_drop.instantiatePromotionsOnCluster();
}

messageHandler handleTCGPromotionMenu()
{
	if(!isGod(self))
	{
		return SCRIPT_CONTINUE;
	}

	obj_id player = sui.getPlayerId(params);
	int idx = sui.getListboxSelectedRow(params);
	int btn = sui.getIntButtonPressed(params);

	if(btn == sui.BP_CANCEL)
	{
		cleanAllScriptVars(self);
		return SCRIPT_CONTINUE;
	}

	if(idx < 0)
	{
		qaTCGMenu(self);

		return SCRIPT_CONTINUE;
	}

	if(idx % 2 == 1)
	{
		idx--;
	}

	string [] listBoxInfo = utils.getStringArrayScriptVar(self, "tcg_menu");

	string [] promotions = new string[1];

	promotions[0] = listBoxInfo[idx];

	dictionary [] promotionalItems = scheduled_drop.getStaticItemsForAllPromotions(promotions);

	string [] promotionList = new string[promotionalItems.length];

	for(int i = 0, j = promotionalItems.length; i < j; i++)
	{
		promotionList[i] = "[" + i + "]  Promo: " + promotionalItems[i].getString("promotionName") + "  Item: " + promotionalItems[i].getString("promotionItem") + "  Weight: " + promotionalItems[i].getInt("promotionWeight");
	}

	qa.refreshMenu(self, "Items in promotion...", "-SWG TCG Promotional Items-", promotionList, "handleTCGPromotionItems", "tcg_menu", "tcg_menu", sui.OK_CANCEL_REFRESH);

	return SCRIPT_CONTINUE;
}

messageHandler handleTCGPromotionItems()
{
	qaTCGMenu(self);

	return SCRIPT_CONTINUE;
}
