include library.create;
include library.pclib;
include library.dot;
include library.combat;
include library.utils;
include java.util.StringTokenizer;
include library.buff;
include library.badge;
include library.healing;
include library.pet_lib;
include library.weapons;

const string[] BADBUFFS = {	"movement", "delay_attack", "private_defense_penalty", "private_armor_break",
				"private_posture_override", "private_state_resist_debuff", "suppression", "combat_slow"	};


//speaking commands for non god enhanced community reps
trigger OnSpeaking(string text)
{

	StringTokenizer st = new java.util.StringTokenizer(text);
	int tokens = st.countTokens();
	string command = null;
	if (st.hasMoreTokens())
		command = st.nextToken();

	//verbal non-god command to grant community a single badge
	if(command.equals("grantCommunityBadge"))
	{
		//create dictionary for use in messageTo
		dictionary dict = new dictionary();
		dict.put("communityRep", self);

		//get list of all community badges
		string[] allCommunityBadges = getAllCollectionSlotsInCollection("col_badge_accolades");

		//verify that they have at least one of the arguments
		if(st.hasMoreTokens())
		{
			string playerName = "";
			string badgeName = "";

			//first argument should be players name
			if(st.hasMoreTokens())
				playerName = st.nextToken();
			//second should be badge name
			if(st.hasMoreTokens())
				badgeName = st.nextToken();

			if(playerName == null || playerName.length() <= 0)
			{
				sendSystemMessage(self, "You must supply a player name.", "");
				return SCRIPT_CONTINUE;
			}
			if(badgeName == null || badgeName.length() <= 0)
			{
				sendSystemMessage(self, "You must supply a badge name.", "");
				return SCRIPT_CONTINUE;
			}

			//get all the slot info for that badge
			string[] info = getCollectionSlotInfo(badgeName);
			if ((info == null) || (info.length != COLLECTION_INFO_ARRAY_SIZE) || (info[COLLECTION_INFO_INDEX_BOOK] == null) || (info[COLLECTION_INFO_INDEX_BOOK] != badge.BADGE_BOOK))
			{
				sendSystemMessage(self, "This is an invalid badge name.", "");
				return SCRIPT_CONTINUE;
			}

			//verify the badge is a community one
			string collectionName = info[COLLECTION_INFO_INDEX_COLLECTION];

			if(collectionName == null || collectionName.length() <= 0)
			{
				sendSystemMessage(self, "Somehow this badge is missing a collection. Contact Development", "");
				return SCRIPT_CONTINUE;
			}

			if(!collectionName.equals("col_badge_accolades"))
			{
				sendSystemMessage(self, "This badge is not a community badge.", "");
				sendSystemMessage(self, "Valid Community Badges are:", "");

				for(int i = 0; i < allCommunityBadges.length; ++i)
				{
					sendSystemMessage(self, allCommunityBadges[i], "");
				}
				return SCRIPT_CONTINUE;
			}

			//attempt to find the players objId by the name supplied
			obj_id player = getPlayerIdFromFirstName(playerName);

			if(!isIdValid(player))
			{
				sendSystemMessage(self, "The name you supplied could not be found. Please check spelling.", "");
				return SCRIPT_CONTINUE;
			}


			//need to store the badge name for use on the playe receiving the badge
			dict.put("badgeName", badgeName);

			//send a message to the player
			//persist it so they dont have to be online
			messageTo(player, "handlerCommunityBadgeGrant", dict, 0, true);

			CustomerServiceLog("EventPerk", "[EventTool] 'grantCommunityBadge' used by " + getPlayerName(self) + ":" + self + ". Awarding badge " + badgeName + " to " + getPlayerName(player) + ":"+ player + " .", null);

			sendSystemMessage(self, "Message sent to grant badge. Please wait for response. If you dont get one, the player is not online.", "");

			return SCRIPT_CONTINUE;
		}
		else
		{
			//give syntax
			sendSystemMessage(self, "You need to specify a player name and what badge you want to grant.", "");
			sendSystemMessage(self, "Correct syntax is grantCommunityBadge <playerName> <badgeName>.", "");
			sendSystemMessage(self, "Valid Community Badges are:", "");

			for(int i = 0; i < allCommunityBadges.length; ++i)
			{
				sendSystemMessage(self, allCommunityBadges[i], "");
			}
		}

		return SCRIPT_CONTINUE;
	}

	//verbal non-god way to gran all community badges to an individual
	if(command.equals("grantAllCommunityBadges"))
	{
		//dictionary for storage
		dictionary dict = new dictionary();
		dict.put("communityRep", self);

		//only argument should be players name
		string playerName = "";
		if(st.hasMoreTokens())
		{
			playerName = st.nextToken();
		}
		else
		{
			sendSystemMessage(self, "You need to specify a player name.", "");
			sendSystemMessage(self, "Correct syntax is grantAllCommunityBadges <playerName>.", "");
			return SCRIPT_CONTINUE;
		}

		if(playerName == null || playerName.length() <= 0)
		{
			sendSystemMessage(self, "You must supply a player name.", "");
			return SCRIPT_CONTINUE;
		}

		//attempt to get the players objId from the name supplied
		obj_id player = getPlayerIdFromFirstName(playerName);

		if(!isIdValid(player))
		{
			sendSystemMessage(self, "The name you supplied could not be found. Please check spelling.", "");
			return SCRIPT_CONTINUE;
		}

		//get list of all community badges
		string[] allCommunityBadges = getAllCollectionSlotsInCollection("col_badge_accolades");

		//loop through them and send message to grant each one
		for(int i = 0; i < allCommunityBadges.length; ++i)
		{
			dict.put("badgeName", allCommunityBadges[i]);

			messageTo(player, "handlerCommunityBadgeGrant", dict, 0, true);
		}

		CustomerServiceLog("EventPerk", "[EventTool] 'grantAllCommunityBadges' used by " + getPlayerName(self) + ":" + self + ". Awarding all community badges to " + getPlayerName(player) + ":"+ player + " .", null);

		sendSystemMessage(self, "Messages sent to grant badges. Please wait for responses. If you dont get any, the player is not online.", "");
		return SCRIPT_CONTINUE;
	}

	//verbal non-god command for granting a community badge to everyone in the range supplied
	if(command.equals("grantCommunityBadgeArea"))
	{
		//dictionary for storage
		dictionary dict = new dictionary();
		dict.put("communityRep", self);

		//make sure we have at least one of the arguments
		if(st.hasMoreTokens())
		{
			string badgeName = "";
			int range = 0;

			//first argument is badge name
			if(st.hasMoreTokens())
				badgeName = st.nextToken();
			//second argument is range
			if(st.hasMoreTokens())
				range = utils.stringToInt(st.nextToken());

			//validate arguments
			if(badgeName == null || badgeName.length() <= 0)
			{
				sendSystemMessage(self, "You must supply a badge name.", "");
				return SCRIPT_CONTINUE;
			}
			if(range <= 0 || range > 156)
			{
				sendSystemMessage(self, "You supplied an invalid range.", "");
				sendSystemMessage(self, "Valid range is 1 to 156.", "");
				return SCRIPT_CONTINUE;
			}

			//validate that this is a community badge
			string[] info = getCollectionSlotInfo(badgeName);
			if ((info == null) || (info.length != COLLECTION_INFO_ARRAY_SIZE) || (info[COLLECTION_INFO_INDEX_BOOK] == null) || (info[COLLECTION_INFO_INDEX_BOOK] != badge.BADGE_BOOK))
			{
				sendSystemMessage(self, "This is an invalid badge name.", "");
				return SCRIPT_CONTINUE;
			}

			string collectionName = info[COLLECTION_INFO_INDEX_COLLECTION];

			if(collectionName == null || collectionName.length() <= 0)
			{
				sendSystemMessage(self, "Somehow this badge is missing a collection. Contact Development", "");
				return SCRIPT_CONTINUE;
			}

			if(!collectionName.equals("col_badge_accolades"))
			{
				sendSystemMessage(self, "This badge is not a community badge.", "");
				sendSystemMessage(self, "Valid Community Badges are:", "");

				string[] allCommunityBadges = getAllCollectionSlotsInCollection("col_badge_accolades");

				for(int i = 0; i < allCommunityBadges.length; ++i)
				{
					sendSystemMessage(self, allCommunityBadges[i], "");
				}
				return SCRIPT_CONTINUE;
			}

			//intialize a counter to track how many badges we give out
			int badgeCount = 0;
			obj_id[] objPlayers = getPlayerCreaturesInRange(self, range);

			//validate list and grant badge to everyone on list
			if (objPlayers != null && objPlayers.length>0)
			{
				for(int i = 0; i < objPlayers.length; i++)
				{
					if(objPlayers[i] != self)
					{
						dict.put("badgeName", badgeName);
						messageTo(objPlayers[i], "handlerCommunityBadgeGrant", dict, 0, true);

						sendSystemMessage(self, "Message sent to grant badge. Please wait for response. If you dont get one, the player is not online.", "");
						badgeCount ++;
					}
				}
			}

			sendSystemMessage(self, "A total of " + badgeCount + " badges were awarded.", null);

			CustomerServiceLog("EventPerk", "[EventTool] 'grantCommunityBadgeArea' used by " + getPlayerName(self) + ":" + self + ". Awarding badge " + badgeName + " to " + badgeCount + " people.", null);
		}
		else
		{
			sendSystemMessage(self, "You need to specify a badge name and range of area you want to give the badge.", "");
			sendSystemMessage(self, "Correct syntax is grantCommunityBadge <badgeName> <range>.", "");
			sendSystemMessage(self, "Valid Range is 1 to 156.", "");
			sendSystemMessage(self, "Valid Community Badges are:", "");

			string[] allCommunityBadges = getAllCollectionSlotsInCollection("col_badge_accolades");

			for(int i = 0; i < allCommunityBadges.length; ++i)
			{
				sendSystemMessage(self, allCommunityBadges[i], "");
			}
		}
	}
	return SCRIPT_CONTINUE;
}

messageHandler handlerCommunityBadgeGrantedToPlayer()
{
	if(params == null || params.isEmpty())
		return SCRIPT_CONTINUE;

	obj_id player = params.getObjId("player");
	string badgeName = params.getString("badgeName");

	sendSystemMessage(self, getPlayerName(player) + " has received the badge " + badgeName + " that you sent them.", "");

	return SCRIPT_CONTINUE;
}


commandHandler eventVaderChoke()
{
	obj_id myTarget = getLookAtTarget(self);

	if(!isIdValid(myTarget) || myTarget == self || !isPlayer(myTarget) || myTarget == null)
	{
		sendSystemMessage(self, "Your target for vaderChoke is invalid.", null);
		return SCRIPT_CONTINUE;
	}

	doAnimationAction(self, "force_choke" );
	doAnimationAction(myTarget, "heavy_cough_vomit");

	dictionary eDict = new dictionary();
	eDict.put("myTarget", myTarget);
	messageTo(self, "killTargetPlayer", eDict, 6, false);

	string selfName = getName(self);
	string targetName = getName(myTarget);
	CustomerServiceLog("EventPerk", "[EventTool] /eventVaderChoke used by [" + selfName + ":" + self + "] on [" + targetName + ":" + myTarget, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventClearStates()
{
	dot.removeAllDots(self);


	if(params.equals("all") )
	{
		buff.removeAllBuffs(self);
		return SCRIPT_CONTINUE;
	}

	int[] everyBuff = buff.getAllBuffs(self);

	for(int i = 0; i < everyBuff.length; i++)
	{
		string buffParam = buff.getEffectParam(everyBuff[i], 1);

		for(int j = 0; j < BADBUFFS.length; j++)
		{
			if(buffParam.equals(BADBUFFS[j]) )
			{

				buff.removeBuff(self, everyBuff[i]);
				sendSystemMessage(self, everyBuff[i] + " is EEeevil so it was removed.", null);
			}
		}
	}

	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventClearStates used by " + selfName + ":" + self, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventBuff()
{
	if(params == null || params.equals("") )
	{
		sendSystemMessage(self, "[Syntax] /eventBuff <buff name> <duration> <value>. Refer /sys.shared/compiled/game/datatables/buff/buff.tab for proper buff names.", null);
		return SCRIPT_CONTINUE;
	}

	StringTokenizer st = new StringTokenizer(params);
	int numArgs = st.countTokens();

	if(numArgs > 3)
	{
		sendSystemMessage(self, "Incorrect number of arguments. [Syntax] /eventBuff <buff name> <optional duration> <optional value>. Refer /sys.shared/compiled/game/datatables/buff/buff.tab for proper buff names.", null);
		return SCRIPT_CONTINUE;
	}

	string buffName = st.nextToken();
	float duration = 0.0f;
	float value = 0.0f;

	if(numArgs > 1)
	{
		string durationStr = st.nextToken();
		duration = (float)utils.stringToInt(durationStr);
	}
	if(numArgs > 2)
	{
		string valueStr = st.nextToken();
		value = (float)utils.stringToInt(valueStr);
	}

	if(numArgs == 1)
		buff.applyBuff(self, buffName);

	if(numArgs == 2)
		buff.applyBuff(self, buffName, duration);

	if(numArgs == 3)
		buff.applyBuff(self, buffName, duration, value);

	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventBuff used by " + selfName + ":" + self + ". Params: " + params, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventBuffTarget()
{
	obj_id myTarget = getLookAtTarget(self);

	if(!isIdValid(myTarget) || myTarget == null)
	{
		sendSystemMessage(self, "Invalid target for /eventBuffTarget. Your target must be a player.", null);
		return SCRIPT_CONTINUE;
	}

	if(params == null || params.equals("") )
	{
		sendSystemMessage(self, "[Syntax] /eventBuffTarget <buff name> <optional duration> <optional value>. Refer to /sys.shared/compiled/game/datatables/buff/buff.tab for proper buff names.", null);
		return SCRIPT_CONTINUE;
	}

	StringTokenizer st = new StringTokenizer(params);
	int numArgs = st.countTokens();

	if(numArgs > 3)
	{
		sendSystemMessage(self, "Incorrect number of arguments. [Syntax] /eventBuffTarget <buff name> <optional duration> <optional value>. Refer /sys.shared/compiled/game/datatables/buff/buff.tab for proper buff names.", null);
		return SCRIPT_CONTINUE;
	}

	string buffName = st.nextToken();
	float duration = 0.0f;
	float value = 0.0f;

	if(numArgs > 1)
	{
		string durationStr = st.nextToken();
		duration = (float)utils.stringToInt(durationStr);
	}
	if(numArgs > 2)
	{
		string valueStr = st.nextToken();
		value = (float)utils.stringToInt(valueStr);
	}

	if(numArgs == 1)
		buff.applyBuff(myTarget, buffName);

	if(numArgs == 2)
		buff.applyBuff(myTarget, buffName, duration);

	if(numArgs == 3)
		buff.applyBuff(myTarget, buffName, duration, value);

	string selfName = getName(self);
	string targetName = getName(myTarget);
	CustomerServiceLog("EventPerk", "[EventTool] /eventBuffTarget used by " + selfName + ":" + self + " on target " + targetName + ":" + myTarget + ". Params: " + params, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventBuffArea()
{
	if(params == null || params.equals("") )
	{
		sendSystemMessage(self, "[Syntax] /eventBuffArea <buff name> <player/npc/all> <range> <optional duration> <optioanal value>. Refer to /sys.shared/compiled/game/datatables/buff/buff.tab for proper buff names.", null);
		return SCRIPT_CONTINUE;
	}

	StringTokenizer st = new StringTokenizer(params);
	int numArgs = st.countTokens();

	if(numArgs > 5 || numArgs < 3)
	{
		sendSystemMessage(self, "Incorrect number of arguments. [Syntax] /eventBuffArea <buff name> <player/npc/all> <range> <optional duration> <optional value>. Refer /sys.shared/compiled/game/datatables/buff/buff.tab for proper buff names.", null);
		return SCRIPT_CONTINUE;
	}

	string buffName = st.nextToken();
	string commandType = st.nextToken();
	string rangeStr = st.nextToken();
	float range = (float)utils.stringToInt(rangeStr);

	if(!commandType.equals("player") && !commandType.equals("npc") && !commandType.equals("all") )
	{
		sendSystemMessage(self, "Target for eventBuffArea must be player, npc or all.[Syntax] /eventBuffArea <buff name> <player/npc/all> <range> <optional duration> <optional value>.", null);
		return SCRIPT_CONTINUE;
	}

	if(range < 1 || range > 256)
	{
		sendSystemMessage(self, "Invalid range for eventBuffArea. Range must be between 1 and 256.", null);
		return SCRIPT_CONTINUE;
	}

	float duration = 0.0f;
	float value = 0.0f;

	if(numArgs > 3)
	{
		string durationStr = st.nextToken();
		duration = (float)utils.stringToInt(durationStr);
	}
	if(numArgs > 4)
	{
		string valueStr = st.nextToken();
		value = (float)utils.stringToInt(valueStr);
	}

	if(commandType.equals("player") )
	{
		obj_id[] thingsInRange = getPlayerCreaturesInRange(self, range);

		if (thingsInRange != null && thingsInRange.length>0)
		{
			for(int i = 0; i < thingsInRange.length; i++)
			{
				if(thingsInRange[i] != self)
				{
					if(numArgs == 2)
						buff.applyBuff(thingsInRange[i], buffName);

					if(numArgs == 3)
						buff.applyBuff(thingsInRange[i], buffName, duration);

					if(numArgs == 4)
						buff.applyBuff(thingsInRange[i], buffName, duration, value);
				}
			}
		}
	}

	if(commandType.equals("npc") )
	{
		obj_id[] thingsInRange = getNPCsInRange(self, range);

		if (thingsInRange != null && thingsInRange.length>0)
		{
			for(int i = 0; i < thingsInRange.length; i++)
			{
				if(thingsInRange[i] != self)
				{
					if(numArgs == 2)
						buff.applyBuff(thingsInRange[i], buffName);

					if(numArgs == 3)
						buff.applyBuff(thingsInRange[i], buffName, duration);

					if(numArgs == 4)
						buff.applyBuff(thingsInRange[i], buffName, duration, value);
				}
			}
		}

	}

	if(commandType.equals("all") )
	{
		obj_id[] thingsInRange = getCreaturesInRange(self, range);

		if (thingsInRange != null && thingsInRange.length>0)
		{
			for(int i = 0; i < thingsInRange.length; i++)
			{
				if(thingsInRange[i] != self)
				{
					if(numArgs == 2)
						buff.applyBuff(thingsInRange[i], buffName);

					if(numArgs == 3)
						buff.applyBuff(thingsInRange[i], buffName, duration);

					if(numArgs == 4)
						buff.applyBuff(thingsInRange[i], buffName, duration, value);
				}
			}
		}
	}

	string selfName = getName(self);
	location here = getLocation(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventBuffArea used by " + selfName + ":" + self + " at location " + here + ". Params: " + params, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventTefArea()
{
	if(params == null || params.equals("") )
	{
		sendSystemMessage(self, "[Syntax] /eventTefArea <range>. Valid range is 1 to 256.", null);
		return SCRIPT_CONTINUE;
	}

	StringTokenizer st = new StringTokenizer(params);
	int numArgs = st.countTokens();

	if(numArgs > 1)
	{
		sendSystemMessage(self, "[Syntax] /eventTefArea <range>. Valid range is 1 to 256.", null);
		return SCRIPT_CONTINUE;
	}

	string rangeStr = st.nextToken();
	float range = (float)utils.stringToInt(rangeStr);

	if(range < 1 || range > 256)
	{
		sendSystemMessage(self, "Invalid range. Range must be between 1 and 256.", null);
		return SCRIPT_CONTINUE;
	}

	obj_id[] objPlayers = getPlayerCreaturesInRange(self, range);

	if (objPlayers != null && objPlayers.length>0)
	{
		for(int i = 0; i < objPlayers.length; i++)
		{
			if(objPlayers[i] != self)
			{
				pvpSetPersonalEnemyFlag(self, objPlayers[i]);
				string playerName = getName(objPlayers[i]);
				sendSystemMessage(self, playerName + " can now attack you!", null);
			}
		}
	}

	string selfName = getName(self);
	location here = getLocation(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventTefArea used by " + selfName + ":" + self + " at location " + here, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventTefTarget()
{
	obj_id myTarget = getLookAtTarget(self);

	if(!isIdValid(myTarget) || myTarget == self || !isPlayer(myTarget) || myTarget == null)
	{
		sendSystemMessage(self, "Your target for eventTefTarget is invalid.", null);
		return SCRIPT_CONTINUE;
	}

	pvpSetPersonalEnemyFlag(self, myTarget);
	string playerName = getName(myTarget);
	sendSystemMessage(self, playerName + " can now attack you!", null);

	string selfName = getName(self);
	string targetName = getName(myTarget);
	CustomerServiceLog("EventPerk", "[EventTool] /eventTefTarget used by " +selfName + ":" + self + " on target " + targetName + ":" + myTarget, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventTefClear()
{

	pvpRemoveAllTempEnemyFlags(self);

	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventTefClear used by " +selfName + ":" + self, null);


	return SCRIPT_CONTINUE;
}

commandHandler grantBadgeArea()
{
	if(params == null || params.equals("") )
	{
		sendSystemMessage(self, "[Syntax] /grantBadgeArea <range> <badge number>. Valid range is 1 to 256.", null);
		return SCRIPT_CONTINUE;
	}

	StringTokenizer st = new StringTokenizer(params);
	int numArgs = st.countTokens();

	if(numArgs != 2)
	{
		sendSystemMessage(self, "[Syntax] /grantBadgeArea <range> <badge number>. Valid range is 1 to 256.", null);
		return SCRIPT_CONTINUE;
	}

	string rangeStr = st.nextToken();
	string badgeNumStr = st.nextToken();
	float range = (float)utils.stringToInt(rangeStr);
	int badgeNumber = utils.stringToInt(badgeNumStr);

	if(range < 1 || range > 256)
	{
		sendSystemMessage(self, "Invalid range. Range must be between 1 and 256.", null);
		return SCRIPT_CONTINUE;
	}

	if(badgeNumber < 0)
	{
		sendSystemMessage(self, "Badge number was invalid and what not.", null);
		return SCRIPT_CONTINUE;
	}

	string badgeName = getCollectionSlotName(badgeNumber);
	if((badgeName == null) || (badgeName.length() == 0))
	{
		sendSystemMessage(self, "Badge number " + badgeNumber + " is not a valid badge.", null);
		return SCRIPT_CONTINUE;
	}

	int badgeCount = 0;
	obj_id[] objPlayers = getPlayerCreaturesInRange(self, range);

	if (objPlayers != null && objPlayers.length>0)
	{
		for(int i = 0; i < objPlayers.length; i++)
		{
			if(objPlayers[i] != self)
			{
				badge.grantBadge(objPlayers[i], badgeName);
				string playerName = getName(objPlayers[i]);
				sendSystemMessage(self, "Granting badge " + badgeNumber + " to player " + playerName, null);
				badgeCount ++;
			}
		}
	}

	sendSystemMessage(self, "A total of " + badgeCount + " badges were awarded.", null);
	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /grantBadgeArea used by " + selfName + ":" + self + ". Awarding badge #" + badgeNumber + " to " + badgeCount + " people.", null);

	return SCRIPT_CONTINUE;
}

commandHandler maxForcePower()
{

	int maxForce = getMaxForcePower(self);

	if(maxForce < 1)
	{
		sendSystemMessage(self, "MaxForcePower failed because you ain't no jedi son!", null);
		return SCRIPT_CONTINUE;
	}

	setForcePower(self, maxForce);

	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /maxForcePower used by " +selfName + ":" + self, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventDamage()
{
	obj_id myTarget = getLookAtTarget(self);

	if(!isIdValid(myTarget) || (!isPlayer(myTarget) && !isMob(myTarget) && !isNpcCreature(myTarget) ) )
	{
		sendSystemMessage(self, "Your target for /eventDamage is invalid ya nut!", null);
		return SCRIPT_CONTINUE;
	}

	if(params == null || params.equals("") )
	{
		sendSystemMessage(self, "[Syntax] /eventDamageTarget <amount>.", null);
		return SCRIPT_CONTINUE;
	}

	StringTokenizer st = new StringTokenizer(params);
	int numArgs = st.countTokens();

	if(numArgs != 1)
	{
		sendSystemMessage(self, "[Syntax] /eventDamageTarget <amount>.", null);
		return SCRIPT_CONTINUE;
	}

	string damageStr = st.nextToken();
	int damage = utils.stringToInt(damageStr) * -1;
	healing.healDamage(self, myTarget, HEALTH, damage);

	string targetName = getName(myTarget);
	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventDamage used by " +selfName + ":" + self + " on target " + targetName + ":" + myTarget + " for " + damage + " damage.", null);

	return SCRIPT_CONTINUE;
}

// This command should be level 15
commandHandler eventMoveToMe()
{

	obj_id myTarget = getLookAtTarget(self);

	if(!isIdValid(myTarget) )
	{
		sendSystemMessage(self, "Your target for eventMoveToMe is invalid. And by that I mean you don't have anything targetted.", null);
		return SCRIPT_CONTINUE;
	}

	location here = getLocation(myTarget);
	long myTargetsValue = myTarget.getValue();

	if(myTargetsValue < 1000000)
	{
		sendSystemMessage(self, "WARNING!!! This object has a very small OID and is likely a build object. You'll need to move it via the console.", null);
		return SCRIPT_CONTINUE;
	}

	setLocation(myTarget, self);

	utils.setScriptVar(self, "eventTool.lastMoveLocation", here);
	utils.setScriptVar(self, "eventTool.lastMovedObject", myTarget);

	sendSystemMessage(self, "Moved object " + myTarget + " to your location. ", null);

	location there = getLocation(self);
	string selfName = getName(self);
	string targetName = getName(myTarget);
	CustomerServiceLog("EventPerk", "[EventTool] /eventMoveToMe used by " + selfName + ":" + self + " on target " + targetName + ":" + target + " from location " + here + " to location " + there, null);

	return SCRIPT_CONTINUE;
}

// This needs to be admin level 15.
commandHandler eventUndoMoveToMe()
{
	location lastLocation = utils.getLocationScriptVar(self, "eventTool.lastMoveLocation");
	location here = getLocation(self);
	obj_id lastTarget = utils.getObjIdScriptVar(self, "eventTool.lastMovedObject");

	if(lastLocation == null)
	{
		sendSystemMessage(self, "The event tool was unable to get your last location. Move cannot be undone.", null);
		return SCRIPT_CONTINUE;
	}

	if(!here.area.equals(lastLocation.area) )
	{
		sendSystemMessage(self, "You must be in the same area as your last moved object to undo the move. Move to that area and try again.", null);
		return SCRIPT_CONTINUE;
	}

	if(!isIdValid(lastTarget) )
	{
		sendSystemMessage(self, "Event tool was unable to identify your last moved object. Make sure it still exists and that you are on the same server as that object.", null);
		return SCRIPT_CONTINUE;
	}

	location currentTargetLocation = getLocation(lastTarget);
	setLocation(lastTarget, lastLocation);

	utils.setScriptVar(self, "eventTool.lastMoveLocation", currentTargetLocation);
	utils.setScriptVar(self, "eventTool.lastMovedObject", lastTarget);

	sendSystemMessage(self, "Moved object " + lastTarget + " to " + lastLocation + ".", null);

	string selfName = getName(self);
	string targetName = getName(lastTarget);
	CustomerServiceLog("EventPerk", "[EventTool] /eventUndoMoveToMe used by " + selfName + ":" + self + " on target " + targetName + ":" + lastTarget + " from location " + currentTargetLocation + " to location " + lastLocation, null);

	return SCRIPT_CONTINUE;
}

commandHandler eventWeapon()
{
	if(params == null || params.equals("") )
	{
		sendSystemMessage(self, "[Syntax] /eventWeapon <weapon template> <power multiplier %>.", null);
		return SCRIPT_CONTINUE;
	}

	StringTokenizer st = new StringTokenizer(params);
	int numArgs = st.countTokens();

	if(numArgs != 2)
	{
		sendSystemMessage(self, "[Syntax] /eventWeapon <weapon template> <power multiplier %>.", null);
		return SCRIPT_CONTINUE;
	}

	string weaponTemplate = st.nextToken();
	float powerMult = (float)utils.stringToInt(st.nextToken() ) / 100;

	obj_id myInventory = utils.getInventoryContainer(self);
	obj_id eventWeapon = weapons.createWeapon(weaponTemplate, myInventory, powerMult);

	if(!isIdValid(eventWeapon) )
	{
		sendSystemMessage(self, "WARNING: That is not a recognized weapon template.", null);
		return SCRIPT_CONTINUE;
	}

	setName(eventWeapon, "***INTERNAL USE ONLY WEAPON");
	attachScript(eventWeapon, "event.no_rent");
	float creationTime = getGameTime();
	setObjVar(eventWeapon, "event.creationTime", creationTime);

	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventWeapon used by " +selfName + ":" +self + " to create " + weaponTemplate + " at " + powerMult + "% of maximum strength.", null);

	return SCRIPT_CONTINUE;
}

commandHandler eventStorePet()
{
	obj_id myTarget = getLookAtTarget(self);

	if(!isIdValid(myTarget) || !pet_lib.isPet(target) )
	{
		sendSystemMessage(self, "Your target for /eventStorePet is invalid.", null);
		return SCRIPT_CONTINUE;
	}

	pet_lib.storePet(myTarget);
	string targetName = getName(myTarget);
	string selfName = getName(self);
	CustomerServiceLog("EventPerk", "[EventTool] /eventStorePet used by " + selfName + ":" + self + " to store pet " + targetName + ":" + target, null);

	return SCRIPT_CONTINUE;
}

messageHandler killTargetPlayer()
{
	obj_id myTarget = params.getObjId("myTarget");
	pclib.killPlayer(myTarget, myTarget);

	return SCRIPT_CONTINUE;
}
