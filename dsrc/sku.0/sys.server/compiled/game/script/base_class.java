/**
 * Title:        base_class
 * Description:  Base class for all scripts.
 * Copyright:    Copyright (c) 2001
 * Company:      Sony Online Entertainment
 * @author       Steve Jakab
 * @version 1.0
 */

package script;

import java.io.FileNotFoundException;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;
import script.obj_id;
import script.region;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;


public class base_class
{
    // info about an object listening for a message
    /*
    private class listener_data
    {
        public obj_id listener;             // the object listening for a message
        public String messageHandler;       // the function to call when the message is broadcast
        public listener_data(obj_id listener, String messageHandler) {this.listener = listener; this.messageHandler = messageHandler;}
    }   // class listener_data
    */
    // Collection of scripts that are listening for broadcast messages
    private static Hashtable m_listeners = new Hashtable();

    /**
     * The range data associated with a weapon.
     */
    public static class range_info implements Cloneable
    {
        public float minRange = 0;          // min-distance range of the weapon (unit = meter)
        public float maxRange = 0;          // maximum effective range of the weapon (unit = meter)

        public Object clone()
        {
            try
            {
                return super.clone();
            }
            catch( CloneNotSupportedException err )
            {
            }
            return null;
        }
    }   // class range_info

    //*********************************************************************
    // Special objects that are used to identify the type of resizeable array
    // being passed to an objvar. This allows idetification of the objvar type
    // even if the array is empty or null
    //*********************************************************************

    public static final Object resizeableArrayTypeint = new Object();
    public static final Object resizeableArrayTypefloat = new Object();
    public static final Object resizeableArrayTypeboolean = new Object();
    public static final Object resizeableArrayTypestring = new Object();
    public static final Object resizeableArrayTypeString = new Object();
    public static final Object resizeableArrayTypeobj_id = new Object();
    public static final Object resizeableArrayTypelocation = new Object();
    public static final Object resizeableArrayTypestring_id = new Object();
    public static final Object resizeableArrayTypetransform = new Object();
    public static final Object resizeableArrayTypevector = new Object();
    public static final Object resizeableArrayTypeattrib_mod = new Object();

    //*********************************************************************
    // constants - IMPORTANT: changes of these values in the C code need to
    // be reflected here
    //*********************************************************************

    /**
     * @defgroup scriptReturns Script Return Values
     * @{
     */

    //  GameScriptObject.h
    /** return value for triggers */
    public static final int SCRIPT_OVERRIDE = 0;
    /** return value for triggers */
    public static final int SCRIPT_CONTINUE = 1;
    public static final int SCRIPT_DEFAULT  = 2;

    /**
     * @}
     * @defgroup triggerValues Trigger values for use with #triggerScript(obj_id, String, int Object[])
     * @{
     */
    // ScriptFuncTable.h
    /** trigger id for OnAttach
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ATTACH                 = 0;
    /** trigger id for OnDetach
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_DETACH                 = 1;
    /** trigger id for OnSpeaking
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_SPEAKING               = 2;
    /** trigger id for OnHearSpeech(string)
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_HEAR_SPEECH_STRING     = 3;
    /** trigger id for OnHearSpeech(string_id)
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_HEAR_SPEECH_STRINGID   = 4;
    /** trigger id for OnInspected
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_INSPECTED              = 5;
    /** trigger id for OnLogout
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_LOGOUT                 = 6;
    /** trigger id for OnLogin
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_LOGIN                  = 7;
    /** trigger id for OnItemEquip
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ITEM_EQUIP             = 8;
    /** trigger id for OnItemUnequip
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ITEM_UNEQUIP           = 9;
    /** trigger id for OnTargetEquipsItem
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_TARGET_EQUIPS_ITEM     = 10;
    /** trigger id for OnUnequipsItem
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_TARGET_UNEQUIPS_ITEM   = 11;
    /** trigger id for OnAboutToReceiveItem
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ABOUT_TO_RECEIVE_ITEM  = 12;
    /** trigger id for OnReceivedItem
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_RECEIVED_ITEM          = 13;
    /** trigger id for OnAboutToBeXferred
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ABOUT_TO_BE_XFERRED    = 14;
    /** trigger id for OnXferred
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_XFERRED                = 15;
    /** trigger id for OnAboutToLoseItem
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ABOUT_TO_LOSE_ITEM     = 16;
    /** trigger id for OnLostItem
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_LOST_ITEM              = 17;
    /** trigger id for OnLoadedFromDb
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_LOADED_FROM_DB         = 18;
    /** trigger id for OnUnloadedFromMemory
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_UNLOADED_FROM_MEMORY   = 19;
    /** trigger id for OnDecay
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_DECAY                  = 20;
    /** trigger id for OnDestroy
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_DESTROY                = 21;
    /** trigger id for OnServerTransfer
     * @see #triggerScript(obj_id, String, int, Object[]) */
//  public static final int TRIG_SERVER_TRANSFER        = 22;
    /** trigger id for OnMadeAuthoritative
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_MADE_AUTHORITATIVE     = 23;
    /** trigger id for OnIncapacitate
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_INCAPACITATE           = 24;
    /** trigger id for OnAboutToDie
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ABOUT_TO_DIE           = 25;
    /** trigger id for OnDeath
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_DEATH                  = 26;
    /** trigger id for OnCombatLoop
     * @see #triggerScript(obj_id, String, int, Object[]) */
//  public static final int TRIG_COMBAT_LOOP            = 27;
    /** trigger id for OnDefenderCombatAction
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_DEFENDER_COMBAT_ACTION = 28;
    /** trigger id for OnAttackerCombatAction
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ATTACKER_COMBAT_ACTION = 29;
    /** trigger id for OnWeaponCombatAction
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_WEAPON_COMBAT_ACTION   = 30;
    /** trigger id for OnIncapacitateTarget
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_INCAPACITATE_TARGET    = 32;
    /** trigger id for OnAddedToWorld
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_ADDED_TO_WORLD         = 37;
    /** trigger id for OnRemovedFromWorld
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_REMOVED_FROM_WORLD     = 38;
    /** trigger id for OnPreloadComplete
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_PRELOAD_COMPLETE       = 39;
    /** trigger id for OnRepathComplete
     * @see #triggerScript(obj_id, String, int, Object[]) */
    //public static final int TRIG_REPATH_COMPLETE        = 40;
    /** trigger id for GetStateDescription
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_GET_STATE_DESCRIPTION  = 41;
    /** trigger id for OnBehaviorChange
     * @see #triggerScript(obj_id, String, int, Object[]) */
    public static final int TRIG_BEHAVIOR_CHANGE = 46;
    /** trigger id for OnPathComplete
     * @see #triggerScript(obj_id, String, int, Object[]) */
    //public static final int TRIG_PATH_COMPLETE = 47;
    /** trigger id for OnTargetLost
     * @see #triggerScript(obj_id, String, int, Object[]) */
    //public static final int TRIG_TARGET_LOST = 48;
    /** trigger id for OnStartNpcConversation
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_START_NPC_CONVESATION = 49;
    /** trigger id for OnEndNpcConversation
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_END_NPC_CONVERSATION = 50;
    /** trigger id for OnNpcConversationResponse
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_NPC_CONVERSATION_RESPONSE = 51;
    /** trigger id for OnTargetChange
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_TARGET_CHANGE = 52;
    /** trigger id for OnResourceHarvesterSetActive
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_RESOURCE_HARVESTER_SET_ACTIVE = 53;
    /** trigger id for OnResouceHarvesterRequestStatus
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_RESOURCE_HARVESTER_REQUEST_STATUS = 54;
    /** trigger id for OnResourceHarvesterRequestResourceData
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_RESOURCE_HARVESTER_REQUEST_RESOURCE_DATA = 55;
    /** trigger id for OnObjectMenuSelect
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_OBJECT_MENU_SELECT = 56;
    /** trigger id for OnObjectMenuRequest
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_OBJECT_MENU_REQUEST = 57;
    /** trigger id for OnRecapacitated
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_RECAPACITATED = 62;
//  public static final int TRIG_REACHED_MAX            = ;
//  public static final int TRIG_EMOTE                  = ;
//  public static final int TRIG_SEE_EMOTE              = ;
    /** trigger id for OnWanderMoving
     * @see #triggerScript(obj_id, String, int, Object[]) */
        public static final int TRIG_WANDER_MOVING = 63;
    /** trigger id for OnWanderWaypoint
     * @see #triggerScript(obj_id, String, int, Object[]) */
        public static final int TRIG_WANDER_WAYPOINT = 64;
    /** trigger id for OnWanderWaiting
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_WANDER_WAITING = 65;
    /** trigger id for OnWanderPathNotFound
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_WANDER_PATH_NOT_FOUND = 66;
    /** trigger id for OnLoiterMoving
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_LOITER_MOVING = 67;
    /** trigger id for OnLoiterWaypoint
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_LOITER_WAYPOINT = 68;
    /** trigger id for OnLoiterWaiting
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_LOITER_WAITING = 69;
    /** trigger id for OnLoiterPathNotFound
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_LOITER_PATH_NOT_FOUND = 70;
    /** trigger id for OnFollowTargetLost
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_FOLLOW_TARGET_LOST = 75;
    /** trigger id for OnFollowWaiting
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_FOLLOW_WAITING = 76;
    /** trigger id for OnFollowMoving
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_FOLLOW_MOVING = 77;
    /** trigger id for OnFollowPathNotFound
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_FOLLOW_PATH_NOT_FOUND = 79;
    /** trigger id for OnFleeTargetLost
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_FLEE_TARGET_LOST = 80;
    /** trigger id for OnFleeWaypoint
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_FLEE_WAYPOINT = 81;
    /** trigger id for OnFleePathNotFound
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_FLEE_PATH_NOT_FOUND = 48;
    /** trigger id for OnMovePathComplete
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_MOVE_PATH_COMPLETE = 47;
    /** trigger id for OnMoveMoving
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_MOVE_MOVING = 40;
    /** trigger id for OnMovePathNotFound
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_MOVE_PATH_NOT_FOUND = 36;
    /** trigger id for OnInitialize
     * @see #triggerScript(obj_id, String, int, Object[]) */
            public static final int TRIG_INITIALIZE = 82;
    public static final int TRIG_REQUEST_DRAFT_SCHEMATICS = 83;
    public static final int TRIG_MANUFACTURING_SCHEMATIC_CREATION = 84;
    public static final int TRIG_CRAFTING_EXPERIMENT = 85;
    public static final int TRIG_MANUFACTURE_OBJECT = 86;
    public static final int TRIG_CRAFTING_DONE = 87;
    public static final int TRIG_ARRIVE_AT_LOCATION = 88;
    public static final int TRIG_EXITED_LOCATION = 89;
    public static final int TRIG_GRANT_MISSION = 90;
    public static final int TRIG_COMBAT_TARGETED = 91;
    public static final int TRIG_COMBAT_UNTARGETED = 92;
    public static final int TRIG_PLAYER_REQUEST_MISSION_BOARD = 93;
    public static final int TRIG_CRAFTING_ADD_RESOURCE = 94;
    public static final int TRIG_MONITORED_CREATURE_MOVEMENT = 96;
    public static final int TRIG_OUT_OF_AMMO = 97;
    public static final int TRIG_OBJECT_DISABLED = 98;
    public static final int TRIG_VOLUME_ENTERED = 99;
    public static final int TRIG_VOLUME_EXITED = 100;
    public static final int TRIG_ENTERED_COMBAT = 103;
    public static final int TRIG_EXITED_COMBAT = 104;
    public static final int TRIG_CHANGED_POSTURE = 105;
    public static final int TRIG_COMBAT_DAMAGED = 106;
    public static final int TRIG_COMBAT_LOST_TARGET = 107;
    public static final int TRIG_SAW_EMOTE = 108;
    public static final int TRIG_OPENED_CONTAINER = 110;
    public static final int TRIG_CLOSED_CONTAINER = 111;
    public static final int TRIG_SPAWN_HEARTBEAT = 112;
    public static final int TRIG_PVP_TYPE_CHANGED = 113;
    public static final int TRIG_PVP_FACTION_CHANGED = 114;
    public static final int TRIG_CITY_CHANGED = 115;
    public static final int TRIG_ENTER_SWIMMING = 116;
    public static final int TRIG_EXIT_SWIMMING = 117;
    public static final int TRIG_PLACE_STRUCTURE = 118;
    public static final int TRIG_PERMISSION_LIST_MODIFY = 121;
    public static final int TRIG_PURCHASE_TICKET = 122;
    public static final int TRIG_GROUP_LEADER_CHANGED = 123;
    public static final int TRIG_REMOVED_FROM_GROUP = 124;
    public static final int TRIG_GROUP_DISBANDED = 125;
    public static final int TRIG_ADDED_TO_GROUP = 126;
    public static final int TRIG_GROUP_FORMED = 127;
    public static final int TRIG_GET_ATTRIBS = 128;
    public static final int TRIG_REQUEST_CORESAMPLE = 129;
    public static final int TRIG_NEWBIE_TUTORIAL_RESPONSE = 133;
    public static final int TRIG_IMMEDIATE_LOGOUT = 134;
    public static final int TRIG_CREATURE_DAMAGED = 135;
    public static final int TRIG_OBJECT_DAMAGED = 136;
    public static final int TRIG_SAW_ATTACK = 137;
    public static final int TRIG_SURVEY_DATA_RECEIVED = 139;
    public static final int TRIG_APPLY_POWERUP = 140;
    public static final int TRIG_IMAGE_DESIGN_VALIDATE = 141;
    public static final int TRIG_IMAGE_DESIGN_COMPLETED = 142;
    public static final int TRIG_HIBERNATE_BEGIN = 143;
    public static final int TRIG_HIBERNATE_END = 144;
    public static final int TRIG_SOCKET_USED = 145;
    public static final int TRIG_QUERY_AUCTIONS = 146;
    public static final int TRIG_REQUEST_AUCTION_FEE = 147;
//  public static final int TRIG_IMAGE_DESIGN_REQUESTCONSENT = 148;
    public static final int TRIG_GET_RESPAWN_LOC = 149;
    public static final int TRIG_WAYPOINT_CREATED = 150;
    public static final int TRIG_WAYPOINT_DESTROYED = 151;
    public static final int TRIG_WAYPOINT_ON_GET_ATTRIBUTES = 152;
    public static final int TRIG_FINALIZE_SCHEMATIC = 153;
    public static final int TRIG_SKILL_GRANTED = 154;
    public static final int TRIG_SKILL_REVOKED = 155;
    public static final int TRIG_MAKE_CRAFTED_ITEM = 156;
    public static final int TRIG_START_CHARACTER_UPLOAD = 157;
    public static final int TRIG_RECEIVE_CHARACTER_TRANSFER_STATUS_MESSAGE = 158;
    public static final int TRIG_LOCATION_RECEIVED = 159;
    public static final int TRIG_ATTRIB_MOD_DONE = 160;
    public static final int TRIG_SKILL_MOD_DONE = 161;
    public static final int TRIG_STOMACH_UPDATE = 162;
    public static final int TRIG_RECEIVE_CLUSTER_WIDE_DATA_RESPONSE = 163;
    public static final int TRIG_IMAGE_DESIGN_CANCELED = 164;
    public static final int TRIG_DOWNLOAD_CHARACTER = 165;
    public static final int TRIG_PERFORM_EMOTE = 166;
    public static final int TRIG_CHAT_ON_LOGIN = 167;
    public static final int TRIG_ABOUT_TO_BE_INCAPACITATED  = 168;
    public static final int TRIG_ABOUT_TO_BE_GRANTED = 169;
    public static final int TRIG_ABOUT_TO_BE_REVOKED = 170;
    public static final int TRIG_CONTAINER_CHILD_GAIN_ITEM = 171;
    public static final int TRIG_CONTAINER_CHILD_LOST_ITEM = 172;
    public static final int TRIG_QUEST_ACTIVATED = 173;
    public static final int TRIG_CRAFTED_PROTOTYPE = 174;
    public static final int TRIG_THEATER_CREATED = 175;
    public static final int TRIG_ENTER_REGION = 176;
    public static final int TRIG_EXIT_REGION = 177;
    public static final int TRIG_VENDOR_ITEM_COUNT_REPLY = 178;
    public static final int TRIG_VENDOR_STATUS_CHANGE = 179;
    public static final int TRIG_PLAYER_THEATER_FAIL = 180;
    public static final int TRIG_GRANT_SCHEMATIC = 181;
    public static final int TRIG_REVOKE_SCHEMATIC = 182;
    public static final int TRIG_PLAYER_VENDOR_COUNT_REPLY = 183;
    public static final int TRIG_SHIP_HIT = 200;
    public static final int TRIG_SHIP_HITTING = 201;
    public static final int TRIG_SHIP_BEHAVIOR_CHANGED = 202;
    public static final int TRIG_SHIP_COMPONENT_POWER_SUFFICIENT = 203;
    public static final int TRIG_SHIP_COMPONENT_POWER_INSUFFICIENT = 204;
    public static final int TRIG_FORM_CREATEOBJECT = 205;
    public static final int TRIG_FORM_EDITOBJECT = 206;
    public static final int TRIG_FORM_REQUESTDATA = 207;
    public static final int TRIG_SHIP_COMPONENT_INSTALLING = 208;
    public static final int TRIG_SHIP_COMPONENT_INSTALLED = 209;
    public static final int TRIG_SHIP_COMPONENT_UNINSTALLING = 210;
    public static final int TRIG_SHIP_COMPONENT_UNINSTALLED = 211;
    public static final int TRIG_SHIP_COMPONENT_ITEM_DROPPED_ON_SLOT = 212;
    public static final int TRIG_SHIP_TRY_TO_EQUIP_DROID_CONTROL_DEVICE_IN_SHIP = 213;
    public static final int TRIG_SHIP_HIT_BY_LIGHTNING = 214;
    public static final int TRIG_SHIP_HIT_BY_ENVIRONMENT = 215;
    public static final int TRIG_SHIP_FIRED_MISSILE = 216;
    public static final int TRIG_SHIP_TARGETED_BY_MISSILE = 217;
    public static final int TRIG_SHIP_FIRED_COUNTERMEASURE = 218;
    public static final int TRIG_SPACE_UNIT_MOVE_TO_COMPLETE = 219;
    public static final int TRIG_SPACE_UNIT_BEHAVIOR_CHANGED = 220;
    public static final int TRIG_SPACE_UNIT_FOLLOW_LOST = 221;
    public static final int TRIG_SHIP_INTERNAL_DAMAGE_OVER_TIME_REMOVED = 222;
    public static final int TRIG_SHIP_DAMAGED_BY_INTERNAL_DAMAGE_OVER_TIME = 223;
    public static final int TRIG_SPACE_UNIT_DOCKED = 224;
    public static final int TRIG_SPACE_UNIT_UNDOCKED = 225;
    public static final int TRIG_SPACE_UNIT_ENTER_COMBAT = 226;
    public static final int TRIG_ABOUT_TO_LAUNCH_TO_SPACE = 227;
    public static final int TRIG_SPACE_UNIT_START_UNDOCK = 228;
    public static final int TRIG_SPACE_EJECT_PLAYER_FROM_SHIP = 229;
    public static final int TRIG_TASK_ACTIVATED = 230;
    public static final int TRIG_TASK_COMPLETED = 231;
    public static final int TRIG_TASK_FAILED = 232;
    public static final int TRIG_TASK_CLEARED = 233;
    public static final int TRIG_PROGRAM_DROID_COMMANDS = 234;
    public static final int TRIG_START_CONVERSATION = 235;
    public static final int TRIG_END_CONVERSATION = 236;
    public static final int TRIG_BEGIN_WARMUP = 237;
    public static final int TRIG_LOOT_LOTTERY_SELECTED = 238;
    public static final int TRIG_AI_PRIMARY_WEAPON_EQUIPPED = 239;
    public static final int TRIG_AI_SECONDARY_WEAPON_EQUIPPED = 240;
    public static final int TRIG_BUILDOUT_OBJECT_REGISTER_WITH_CONTROLLER = 241;
    public static final int TRIG_CYBERNETIC_CHANGE_REQUEST = 242;
    public static final int TRIG_SOME_TASK_ACTIVATED = 243;
    public static final int TRIG_SOME_TASK_COMPLETED = 244;
    public static final int TRIG_SOME_TASK_FAILED = 245;
    public static final int TRIG_SOME_TASK_CLEARED = 246;
    public static final int TRIG_SPACE_MINING_SELL_RESOURCE = 247;
    public static final int TRIG_AI_RETREAT_COMPLETE = 248;
    public static final int TRIG_HATE_TARGET_CHANGED = 249;
    public static final int TRIG_HATE_TARGET_ADDED = 250;
    public static final int TRIG_HATE_TARGET_REMOVED = 251;
    public static final int TRIG_AI_RETREAT_START = 252;
    public static final int TRIG_DO_STRUCTURE_ROLLUP = 253;
    public static final int TRIG_GET_SCRIPTVARS = 254;
    //public static final int TRIG_DEFAULT_ACTION = 255;
    public static final int TRIG_INVULERABLE_CHANGED = 256;
    public static final int TRIG_UNSTICKING = 257;
    public static final int TRIG_AI_COMBAT_FRAME = 258;
    public static final int TRIG_UPLOAD_CHARACTER = 259;
    public static final int TRIG_REQUEST_RESOURCE_WEIGHTS = 260;
    public static final int TRIG_FSQUEST_COMPLETED = 261;
    public static final int TRIG_MOVE_PATH_BLOCKED = 262;
    public static final int TRIG_QUEST_COMPLETED = 263;
    public static final int TRIG_QUEST_CLEARED = 264;
    public static final int TRIG_GROUP_MEMBERS_CHANGED = 265;
    public static final int TRIG_ENVIRONMENTAL_DEATH = 266;
    public static final int TRIG_LOCOMOTION_CHANGED = 267;
    public static final int TRIG_REQUEST_STATIC_ITEM_DATA = 268;
    public static final int TRIG_SKILL_TEMPLATE_CHANGED = 269;
    public static final int TRIG_WORKING_SKILL_CHANGED = 270;
    public static final int TRIG_COMBAT_LEVEL_CHANGED = 271;
    public static final int TRIG_QUEST_GRANT_REWARD = 272;
    public static final int TRIG_SKILLMODS_CHANGED = 273;
    public static final int TRIG_GET_STATIC_ITEM_ATTRIBS = 274;
    public static final int TRIG_PURCHASE_TICKET_INSTANT_TRAVEL = 275;
    // where's TRIG_HYPERSPACE_TO_HOME_LOCATION? - RH
    public static final int TRIG_CS_CREATE_ITEM = 277;
    public static final int TRIG_ON_CUSTOMIZE_FINISHED = 278;
    public static final int TRIG_PVP_RANKING_CHANGED = 279;
    public static final int TRIG_BUFF_BUILDER_VALIDATE = 280;
    public static final int TRIG_BUFF_BUILDER_COMPLETED = 281;
    public static final int TRIG_BUFF_BUILDER_CANCELED = 282;
    public static final int TRIG_BUILDING_CONTENTS_LOADED = 283;
    public static final int TRIG_INCUBATOR_COMMITTED = 284;
    public static final int TRIG_INCUBATOR_CANCELED = 285;
    public static final int TRIG_COLLECTION_SLOT_MODIFIED = 286;
    public static final int TRIG_COLLECTION_SERVER_FIRST = 287;
    public static final int TRIG_CREATE_VETERAN_REWARD = 288;
    public static final int TRIG_GROUND_TARGET_LOC = 289;
    public static final int TRIG_ON_DUEL_REQUEST = 290;
    public static final int TRIG_ON_DUEL_START = 291;
    public static final int TRIG_ON_ABOUT_TO_CHANGE_APPEARANCE = 292;
    public static final int TRIG_ON_ABOUT_TO_REVERT_APPEARANCE = 293;
    public static final int TRIG_ABOUT_TO_TRAVEL_TO_GROUP_PICKUP_POINT = 294;
    public static final int TRIG_TRAVEL_TO_GROUP_PICKUP_POINT = 295;
    public static final int TRIG_CHANGED_APPEARANCE = 296;
    public static final int TRIG_REVERTED_APPEARANCE = 297;
    public static final int TRIG_ON_DYNAMIC_SPAWN_REGION_CREATED = 298;
    public static final int TRIG_DO_RESTORE_ITEM_DECORATION_LAYOUT = 299;
    public static final int TRIG_DO_RESTORE_ITEM_DECORATION_LAYOUT_ROTATION_ONLY = 300;
    public static final int TRIG_ON_RATING_FINISHED = 301;
    public static final int TRIG_ON_ABANDON_PLAYER_QUEST = 302;
    public static final int TRIG_ON_GCW_SCORE_CATEGORY_PERCENTILE_CHANGE = 303;

    /**
     * @}
     * @defgroup gameObjectTypes Game Object Types from GameObjectType.def
     * @{
     */
    private static int private_GOT_counter = 0;

    public static final int GOT_none                               = private_GOT_counter = 0x00000000;
    public static final int GOT_corpse                             = ++private_GOT_counter;
    public static final int GOT_group                              = ++private_GOT_counter;
    public static final int GOT_guild                              = ++private_GOT_counter;
    public static final int GOT_lair                               = ++private_GOT_counter;
    public static final int GOT_static                             = ++private_GOT_counter;
    public static final int GOT_camp                               = ++private_GOT_counter;
    public static final int GOT_vendor                               = ++private_GOT_counter;

    public static final int GOT_armor                              = private_GOT_counter = 0x00000100;
    public static final int GOT_armor_body                         = ++private_GOT_counter;
    public static final int GOT_armor_head                         = ++private_GOT_counter;
    public static final int GOT_armor_misc                         = ++private_GOT_counter;
    public static final int GOT_armor_leg                          = ++private_GOT_counter;
    public static final int GOT_armor_arm                          = ++private_GOT_counter;
    public static final int GOT_armor_hand                         = ++private_GOT_counter;
    public static final int GOT_armor_foot                         = ++private_GOT_counter;
    public static final int GOT_armor_shield                       = ++private_GOT_counter;
    public static final int GOT_armor_layer                        = ++private_GOT_counter;
    public static final int GOT_armor_segment                      = ++private_GOT_counter;
    public static final int GOT_armor_core                         = ++private_GOT_counter;
    public static final int GOT_armor_psg                          = ++private_GOT_counter;

    public static final int GOT_building                           = private_GOT_counter = 0x00000200;
    public static final int GOT_building_municipal                 = ++private_GOT_counter;
    public static final int GOT_building_player                    = ++private_GOT_counter;
    public static final int GOT_building_factional                 = ++private_GOT_counter;

    public static final int GOT_creature                           = private_GOT_counter = 0x00000400;
    public static final int GOT_creature_character                 = ++private_GOT_counter;
    public static final int GOT_creature_droid                     = ++private_GOT_counter;
    public static final int GOT_creature_droid_probe               = ++private_GOT_counter;
    public static final int GOT_creature_monster                   = ++private_GOT_counter;

    public static final int GOT_data                               = private_GOT_counter = 0x00000800;
    public static final int GOT_data_draft_schematic               = ++private_GOT_counter;
    public static final int GOT_data_manufacturing_schematic       = ++private_GOT_counter;
    public static final int GOT_data_mission_object                = ++private_GOT_counter;
    public static final int GOT_data_token                         = ++private_GOT_counter;
    public static final int GOT_data_waypoint                      = ++private_GOT_counter;
    public static final int GOT_data_fictional                     = ++private_GOT_counter;
    public static final int GOT_data_pet_control_device            = ++private_GOT_counter;
    public static final int GOT_data_vehicle_control_device        = ++private_GOT_counter;
    public static final int GOT_data_draft_schematic_read_only     = ++private_GOT_counter;
    public static final int GOT_data_ship_control_device           = ++private_GOT_counter;
    public static final int GOT_data_droid_control_device          = ++private_GOT_counter;
    public static final int GOT_data_house_control_device          = ++private_GOT_counter;
	public static final int GOT_data_vendor_control_device         = ++private_GOT_counter;
	public static final int GOT_data_player_quest_object		   = ++private_GOT_counter;

    public static final int GOT_installation                       = private_GOT_counter = 0x00001000;
    public static final int GOT_installation_factory               = ++private_GOT_counter;
    public static final int GOT_installation_generator             = ++private_GOT_counter;
    public static final int GOT_installation_harvester             = ++private_GOT_counter;
    public static final int GOT_installation_turret                = ++private_GOT_counter;
    public static final int GOT_installation_minefield             = ++private_GOT_counter;

    public static final int GOT_misc                               = private_GOT_counter = 0x00002000;
    public static final int GOT_misc_ammunition                    = ++private_GOT_counter;
    public static final int GOT_misc_chemical                      = ++private_GOT_counter;
    public static final int GOT_misc_clothing_DUMMY                = ++private_GOT_counter;
    public static final int GOT_misc_component_DUMMY               = ++private_GOT_counter;
    public static final int GOT_misc_container                     = ++private_GOT_counter;
    public static final int GOT_misc_crafting_station              = ++private_GOT_counter;
    public static final int GOT_misc_deed_DUMMY                    = ++private_GOT_counter;
    public static final int GOT_misc_electronics                   = ++private_GOT_counter;
    public static final int GOT_misc_flora                         = ++private_GOT_counter;
    public static final int GOT_misc_food                          = ++private_GOT_counter;
    public static final int GOT_misc_furniture                     = ++private_GOT_counter;
    public static final int GOT_misc_instrument                    = ++private_GOT_counter;
    public static final int GOT_misc_pharmaceutical                = ++private_GOT_counter;
    public static final int GOT_misc_resource_container_DUMMY      = ++private_GOT_counter;
    public static final int GOT_misc_sign                          = ++private_GOT_counter;
    public static final int GOT_misc_counter                       = ++private_GOT_counter;
    public static final int GOT_misc_factory_crate                 = ++private_GOT_counter;
    public static final int GOT_misc_ticket_travel                 = ++private_GOT_counter;
    public static final int GOT_misc_item                          = ++private_GOT_counter;
    public static final int GOT_misc_trap                          = ++private_GOT_counter;
    public static final int GOT_misc_container_wearable            = ++private_GOT_counter;
    public static final int GOT_misc_fishing_pole                  = ++private_GOT_counter;
    public static final int GOT_misc_fishing_bait                  = ++private_GOT_counter;
    public static final int GOT_misc_drink                         = ++private_GOT_counter;
    public static final int GOT_misc_firework                      = ++private_GOT_counter;
    public static final int GOT_misc_item_usable                   = ++private_GOT_counter;
    public static final int GOT_misc_petmed                        = ++private_GOT_counter;
    public static final int GOT_misc_firework_show                 = ++private_GOT_counter;
    public static final int GOT_misc_clothing_attachment           = ++private_GOT_counter;
    public static final int GOT_misc_live_sample                   = ++private_GOT_counter;
    public static final int GOT_misc_armor_attachment              = ++private_GOT_counter;
    public static final int GOT_misc_community_crafting_project    = ++private_GOT_counter;
    public static final int GOT_misc_force_crystal                 = ++private_GOT_counter;
    public static final int GOT_misc_droid_programming_chip        = ++private_GOT_counter;
    public static final int GOT_misc_misc_asteroid                 = ++private_GOT_counter;
    public static final int GOT_misc_pob_ship_pilot_chair          = ++private_GOT_counter;
    public static final int GOT_misc_operations_chair              = ++private_GOT_counter;
    public static final int GOT_misc_turret_access_ladder          = ++private_GOT_counter;
    public static final int GOT_misc_container_ship_loot           = ++private_GOT_counter;
    public static final int GOT_misc_armor_noequip                 = ++private_GOT_counter;
    public static final int GOT_misc_enzyme                        = ++private_GOT_counter;
    public static final int GOT_misc_food_pet                      = ++private_GOT_counter;
    public static final int GOT_misc_collection                    = ++private_GOT_counter;
    public static final int GOT_misc_container_public              = ++private_GOT_counter;
    public static final int GOT_misc_ground_target                 = ++private_GOT_counter;
    public static final int GOT_misc_blueprint                     = ++private_GOT_counter;
    public static final int GOT_misc_enzyme_isomerase              = ++private_GOT_counter;
    public static final int GOT_misc_enzyme_lyase                  = ++private_GOT_counter;
    public static final int GOT_misc_enzyme_hydrolase              = ++private_GOT_counter;
    public static final int GOT_misc_tcg_card                      = ++private_GOT_counter;
    public static final int GOT_misc_appearance_only               = ++private_GOT_counter;
    public static final int GOT_misc_appearance_only_invisible     = ++private_GOT_counter;

    public static final int GOT_terminal                           = private_GOT_counter = 0x00004000;
    public static final int GOT_terminal_bank                      = ++private_GOT_counter;
    public static final int GOT_terminal_bazaar                    = ++private_GOT_counter;
    public static final int GOT_terminal_cloning                   = ++private_GOT_counter;
    public static final int GOT_terminal_insurance                 = ++private_GOT_counter;
    public static final int GOT_terminal_manage                    = ++private_GOT_counter;
    public static final int GOT_terminal_mission                   = ++private_GOT_counter;
    public static final int GOT_terminal_permissions               = ++private_GOT_counter;
    public static final int GOT_terminal_player_structure          = ++private_GOT_counter;
    public static final int GOT_terminal_shipping                  = ++private_GOT_counter;
    public static final int GOT_terminal_travel                    = ++private_GOT_counter;
    public static final int GOT_terminal_space                     = ++private_GOT_counter;
    public static final int GOT_terminal_misc                      = ++private_GOT_counter;
    public static final int GOT_terminal_space_npe                 = ++private_GOT_counter;

    public static final int GOT_tool                               = private_GOT_counter = 0x00008000;
    public static final int GOT_tool_crafting                      = ++private_GOT_counter;
    public static final int GOT_tool_survey                        = ++private_GOT_counter;
    public static final int GOT_tool_repair                        = ++private_GOT_counter;
    public static final int GOT_tool_camp_kit                      = ++private_GOT_counter;
    public static final int GOT_tool_ship_component_repair         = ++private_GOT_counter;

    public static final int GOT_vehicle                            = private_GOT_counter = 0x00010000;
    public static final int GOT_vehicle_hover                      = ++private_GOT_counter;
    public static final int GOT_vehicle_hover_ai                   = ++private_GOT_counter;

    public static final int GOT_weapon                             = private_GOT_counter = 0x00020000;
    public static final int GOT_weapon_melee_misc                  = ++private_GOT_counter;
    public static final int GOT_weapon_ranged_misc                 = ++private_GOT_counter;
    public static final int GOT_weapon_ranged_thrown               = ++private_GOT_counter;
    public static final int GOT_weapon_heavy_misc                  = ++private_GOT_counter;
    public static final int GOT_weapon_heavy_mine                  = ++private_GOT_counter;
    public static final int GOT_weapon_heavy_special               = ++private_GOT_counter;
    public static final int GOT_weapon_melee_1h                    = ++private_GOT_counter;
    public static final int GOT_weapon_melee_2h                    = ++private_GOT_counter;
    public static final int GOT_weapon_melee_polearm               = ++private_GOT_counter;
    public static final int GOT_weapon_ranged_pistol               = ++private_GOT_counter;
    public static final int GOT_weapon_ranged_carbine              = ++private_GOT_counter;
    public static final int GOT_weapon_ranged_rifle                = ++private_GOT_counter;

    public static final int GOT_component                          = private_GOT_counter = 0x00040000;
    public static final int GOT_component_armor                    = ++private_GOT_counter;
    public static final int GOT_component_chemistry                = ++private_GOT_counter;
    public static final int GOT_component_clothing                 = ++private_GOT_counter;
    public static final int GOT_component_droid                    = ++private_GOT_counter;
    public static final int GOT_component_electronics              = ++private_GOT_counter;
    public static final int GOT_component_munition                 = ++private_GOT_counter;
    public static final int GOT_component_structure                = ++private_GOT_counter;
    public static final int GOT_component_weapon_melee             = ++private_GOT_counter;
    public static final int GOT_component_weapon_ranged            = ++private_GOT_counter;
    public static final int GOT_component_tissue                   = ++private_GOT_counter;
    public static final int GOT_component_genetic                  = ++private_GOT_counter;
    public static final int GOT_component_saber_crystal            = ++private_GOT_counter;
    public static final int GOT_component_community_crafting       = ++private_GOT_counter;
    public static final int GOT_component_new_armor                = ++private_GOT_counter;

    public static final int GOT_powerup_weapon                     = private_GOT_counter = 0x00080000;
    public static final int GOT_powerup_weapon_melee               = ++private_GOT_counter;
    public static final int GOT_powerup_weapon_ranged              = ++private_GOT_counter;
    public static final int GOT_powerup_weapon_thrown              = ++private_GOT_counter;
    public static final int GOT_powerup_weapon_heavy               = ++private_GOT_counter;
    public static final int GOT_powerup_weapon_mine                = ++private_GOT_counter;
    public static final int GOT_powerup_weapon_heavy_special       = ++private_GOT_counter;

    public static final int GOT_powerup_armor                      = private_GOT_counter = 0x00100000;
    public static final int GOT_powerup_armor_body                 = ++private_GOT_counter;
    public static final int GOT_powerup_armor_head                 = ++private_GOT_counter;
    public static final int GOT_powerup_armor_misc                 = ++private_GOT_counter;
    public static final int GOT_powerup_armor_leg                  = ++private_GOT_counter;
    public static final int GOT_powerup_armor_arm                  = ++private_GOT_counter;
    public static final int GOT_powerup_armor_hand                 = ++private_GOT_counter;
    public static final int GOT_powerup_armor_foot                 = ++private_GOT_counter;
    public static final int GOT_powerup_armor_layer                = ++private_GOT_counter;
    public static final int GOT_powerup_armor_segment              = ++private_GOT_counter;
    public static final int GOT_powerup_armor_core                 = ++private_GOT_counter;

    public static final int GOT_jewelry                            = private_GOT_counter = 0x00200000;
    public static final int GOT_jewelry_ring                       = ++private_GOT_counter;
    public static final int GOT_jewelry_bracelet                   = ++private_GOT_counter;
    public static final int GOT_jewelry_necklace                   = ++private_GOT_counter;
    public static final int GOT_jewelry_earring                    = ++private_GOT_counter;

    public static final int GOT_resource_container                     = private_GOT_counter = 0x00400000;
    public static final int GOT_resource_container_energy_gas          = ++private_GOT_counter;
    public static final int GOT_resource_container_energy_liquid       = ++private_GOT_counter;
    public static final int GOT_resource_container_energy_radioactive  = ++private_GOT_counter;
    public static final int GOT_resource_container_energy_solid        = ++private_GOT_counter;
    public static final int GOT_resource_container_inorganic_chemicals = ++private_GOT_counter;
    public static final int GOT_resource_container_inorganic_gas       = ++private_GOT_counter;
    public static final int GOT_resource_container_inorganic_minerals  = ++private_GOT_counter;
    public static final int GOT_resource_container_inorganic_water     = ++private_GOT_counter;
    public static final int GOT_resource_container_organic_food        = ++private_GOT_counter;
    public static final int GOT_resource_container_organic_hide        = ++private_GOT_counter;
    public static final int GOT_resource_container_organic_structure   = ++private_GOT_counter;
    public static final int GOT_resource_container_pseudo              = ++private_GOT_counter;

    public static final int GOT_deed                                   = private_GOT_counter = 0x00800000;
    public static final int GOT_deed_building                          = ++private_GOT_counter;
    public static final int GOT_deed_installation                      = ++private_GOT_counter;
    public static final int GOT_deed_pet                               = ++private_GOT_counter;
    public static final int GOT_deed_droid                             = ++private_GOT_counter;
    public static final int GOT_deed_vehicle                           = ++private_GOT_counter;

    public static final int GOT_clothing                               = private_GOT_counter = 0x01000000;
    public static final int GOT_clothing_bandolier                     = ++private_GOT_counter;
    public static final int GOT_clothing_belt                          = ++private_GOT_counter;
    public static final int GOT_clothing_bodysuit                      = ++private_GOT_counter;
    public static final int GOT_clothing_cape                          = ++private_GOT_counter;
    public static final int GOT_clothing_cloak                         = ++private_GOT_counter;
    public static final int GOT_clothing_foot                          = ++private_GOT_counter;
    public static final int GOT_clothing_dress                         = ++private_GOT_counter;
    public static final int GOT_clothing_hand                          = ++private_GOT_counter;
    public static final int GOT_clothing_eye                           = ++private_GOT_counter;
    public static final int GOT_clothing_head                          = ++private_GOT_counter;
    public static final int GOT_clothing_jacket                        = ++private_GOT_counter;
    public static final int GOT_clothing_pants                         = ++private_GOT_counter;
    public static final int GOT_clothing_robe                          = ++private_GOT_counter;
    public static final int GOT_clothing_shirt                         = ++private_GOT_counter;
    public static final int GOT_clothing_vest                          = ++private_GOT_counter;
    public static final int GOT_clothing_wookiee                       = ++private_GOT_counter;
    public static final int GOT_clothing_misc                          = ++private_GOT_counter;
    public static final int GOT_clothing_skirt                         = ++private_GOT_counter;

    //add space-specific GOTS at the "end" to make merging easier

    public static final int GOT_ship_component                         = private_GOT_counter = 0x40000000;
    public static final int GOT_ship_component_reactor                 = ++private_GOT_counter;
    public static final int GOT_ship_component_engine                  = ++private_GOT_counter;
    public static final int GOT_ship_component_shield                  = ++private_GOT_counter;
    public static final int GOT_ship_component_armor                   = ++private_GOT_counter;
    public static final int GOT_ship_component_weapon                  = ++private_GOT_counter;
    public static final int GOT_ship_component_capacitor               = ++private_GOT_counter;
    public static final int GOT_ship_component_booster                 = ++private_GOT_counter;
    public static final int GOT_ship_component_droid_interface         = ++private_GOT_counter;
    public static final int GOT_ship_component_hangar                  = ++private_GOT_counter;
    public static final int GOT_ship_component_targeting_station       = ++private_GOT_counter;
    public static final int GOT_ship_component_bridge                  = ++private_GOT_counter;
    public static final int GOT_ship_component_chassis                 = ++private_GOT_counter;
    public static final int GOT_ship_component_missilepack             = ++private_GOT_counter;
    public static final int GOT_ship_component_countermeasurepack      = ++private_GOT_counter;
    public static final int GOT_ship_component_missilelauncher         = ++private_GOT_counter;
    public static final int GOT_ship_component_countermeasurelauncher  = ++private_GOT_counter;
    public static final int GOT_ship_component_cargo_hold              = ++private_GOT_counter;
    public static final int GOT_ship_component_modification            = ++private_GOT_counter;

    public static final int GOT_ship                                   = private_GOT_counter = 0x20000000;
    public static final int GOT_ship_fighter                           = ++private_GOT_counter;
    public static final int GOT_ship_capital                           = ++private_GOT_counter;
    public static final int GOT_ship_station                           = ++private_GOT_counter;
    public static final int GOT_ship_transport                         = ++private_GOT_counter;
    public static final int GOT_ship_mining_asteroid_static            = ++private_GOT_counter;
    public static final int GOT_ship_mining_asteroid_dynamic           = ++private_GOT_counter;

    public static final int GOT_cybernetic                             = private_GOT_counter = 0x20000100;
    public static final int GOT_cybernetic_arm                         = ++private_GOT_counter;
    public static final int GOT_cybernetic_legs                        = ++private_GOT_counter;
    public static final int GOT_cybernetic_torso                       = ++private_GOT_counter;
    public static final int GOT_cybernetic_forearm                     = ++private_GOT_counter;
    public static final int GOT_cybernetic_hand                        = ++private_GOT_counter;
    public static final int GOT_cybernetic_component                   = ++private_GOT_counter;

    public static final int GOT_chronicles                             = private_GOT_counter = 0x00001100;
    public static final int GOT_chronicles_relic                       = ++private_GOT_counter;
    public static final int GOT_chronicles_chronicle                   = ++private_GOT_counter;
    public static final int GOT_chronicles_quest_holocron              = ++private_GOT_counter;
    public static final int GOT_chronicles_quest_holocron_recipe       = ++private_GOT_counter;
    public static final int GOT_chronicles_relic_fragment              = ++private_GOT_counter;

    //note that 0x80000000 is currently a reserved value and unavailable for use


    public static boolean isGameObjectTypeOf (int typeToTest, int typeToTestAgainst)
    {
        if (typeToTest == typeToTestAgainst)
            return true;

        if ((typeToTest & 0xffffff00) == typeToTestAgainst)
            return true;

        return false;
    }

    public static class waypoint_colors
    {
        public static final String blue   = "blue";
        public static final String green  = "green";
        public static final String orange = "orange";
        public static final String yellow = "yellow";
        public static final String purple = "purple";
        public static final String white  = "white";
    };

    /**
     * @}
     * @defgroup attributeConstants Attribute contants
     * @{
     */
    // Attributes.def
    /** id for health attribute
     * @see #getAttrib(obj_id, int) */
    public static final int HEALTH       = 0;
    /** id for constitution attribute
     * @see #getAttrib(obj_id, int) */
    public static final int CONSTITUTION = 1;
    /** id for action attribute
     * @see #getAttrib(obj_id, int) */
    public static final int ACTION       = 2;
    /** id for stamina attribute
     * @see #getAttrib(obj_id, int) */
    public static final int STAMINA      = 3;
    /** id for mind attribute
     * @see #getAttrib(obj_id, int) */
    public static final int MIND         = 4;
    /** id for willpower attribute
     * @see #getAttrib(obj_id, int) */
    public static final int WILLPOWER    = 5;

    public static final int NUM_ATTRIBUTES = 6;
    public static final int NUM_ATTRIBUTE_GROUPS = 3;
    public static final int NUM_ATTRIBUTES_PER_GROUP = 2;


    /** error code returned by getAttrib
     * @see #getAttrib(obj_id, int) */
    public static final int ATTRIB_ERROR = Integer.MIN_VALUE;
    /**
     * @}
     * @defgroup mentalStateConstants Mental state constants from MentalStates.def
     * @{
     */

    public static final int FEAR         = 0;
    public static final int ANGER        = 1;
    public static final int INTEREST     = 2;
    public static final int DISTRESS     = 3;
    public static final float MENTAL_ERROR = -34359738368.0f; // this is an unlikely, exactly representable floating point number

    /**
     * @}
     * @defgroup behaviorConstants Behavior constants from Behaviors.def
     * @{
     */
    public static final int BEHAVIOR_ERROR = -1;
    public static final int BEHAVIOR_CALM = 0;
    public static final int BEHAVIOR_ALERT = 1;
    public static final int BEHAVIOR_THREATEN = 2;
    public static final int BEHAVIOR_FLEE = 3;
    public static final int BEHAVIOR_PANIC = 4;
    public static final int BEHAVIOR_ATTACK = 5;
    public static final int BEHAVIOR_FRENZY = 6;
    /**
     * @}
     * @defgroup weaponModConstants Weapon attribute modifier constants from WeaponObjectTemplate.h
     * @{
     */
    /** attrib_mod decay value indicating to decay at the attribute's pool value
     *  @see #addAttribModifier(obj_id, int, int, float, float, float) */
    public static final float MOD_POOL     = -1.0f;
    /** attrib_mod decay value indicating that the mod can only be healed by a skill/item
     *  @see #addAttribModifier(obj_id, int, int, float, float, float) */
    public static final float MOD_WOUND    = -2.0f;
    /** attrib_mod decay value indicating that we want to clear any attrib mods for an attribute
     *  @see #addAttribModifier(obj_id, int, int, float, float, float) */
    public static final float MOD_ANTIDOTE = -3.0f;
    /**
     * @}
     * @defgroup genderConstants Gender constants from CreatureObjectTemplate.h
     * @{
     */
    /** id for male gender
     * @see #getGender(obj_id) */
    public static final int GENDER_MALE   = 0;
    /** id for female gender
     * @see #getGender(obj_id) */
    public static final int GENDER_FEMALE = 1;
    /** id for other gender
     * @see #getGender(obj_id) */
    public static final int GENDER_OTHER  = 2;
    /**
     * @}
     * @defgroup nicheConstants Niche constants from CreatureObjectTemplate.h
     * See #getNiche(obj_id)
     * @{
     */
    public static final int NICHE_NONE      = 0;
    public static final int NICHE_PC        = 1;
    public static final int NICHE_AI        = 2;
    public static final int NICHE_DROID     = 3;
    public static final int NICHE_VEHICLE   = 4;
    public static final int NICHE_NPC       = 5;
    public static final int NICHE_MONSTER   = 6;
    public static final int NICHE_HERBIVORE = 7;
    public static final int NICHE_CARNIVORE = 8;
    public static final int NICHE_PREDATOR  = 9;
    public static final int NICHE_ANDROID   = 10;

     /**
     * @}
     * @defgroup raceConstants Race constants from CreatureObjectTemplate.h
     * See #getRace(obj_id)
     * @{
     */

    public static final int RACE_NONE = 0;
    public static final int RACE_AQUALISH_QUARA = 1;
    public static final int RACE_AQUALISH_AQUALA = 2;
    public static final int RACE_EWOK_EWOK = 1;                  // pale; green; black; white (subject to change, pending information request to LucasArts)
    public static final int RACE_EWOK_DULOK = 2;                 // blue skin; "Orn Free Taa", "Ann Gella" & "Tann", Sebulba's personal entourage.
    public static final int RACE_EWOK_JINDA = 3;                 // red skin; "Pampy" & "Supi", consorts of Orn Free Taa.
    public static final int RACE_GUNGAN_ANKURA = 1;              // Boss Nass
    public static final int RACE_GUNGAN_OTOLLA = 2;              // Jar Jar
    public static final int RACE_NIKTO_RED = 1;                  // Kajain'sa'Nikto
    public static final int RACE_NIKTO_GREEN = 2;                // Kadas'sa'Nikto
    public static final int RACE_NIKTO_MOUNTAIN = 3;             // Esral'sa'Nikto
    public static final int RACE_NIKTO_PALE = 4;                 // Gluss'sa'Nikto
    public static final int RACE_NIKTO_SOUTHERN = 5;             // M'shento'su'Nikto
    public static final int RACE_KRAYT_CANYON = 1;
    public static final int RACE_KRAYT_GREATER = 2;
    public static final int RA_R2 = 0;
    public static final int RA_R3 = 1;
    public static final int RA_R4 = 2;
    public static final int RA_R5 = 3;

    /**
     * @}
     * @defgroup speciesConstants Species constants from CreatureObjectTemplate.h
     * @see #getSpecies(obj_id)
     * @{
     */
    public static final int SPECIES_HUMAN                              = 0;
    public static final int SPECIES_RODIAN                             = 1;
    public static final int SPECIES_TRANDOSHAN                         = 2;
    public static final int SPECIES_MON_CALAMARI                       = 3;
    public static final int SPECIES_WOOKIEE                            = 4;
    public static final int SPECIES_BOTHAN                             = 5;
    public static final int SPECIES_TWILEK                             = 6;
    public static final int SPECIES_ZABRAK                             = 7;
    public static final int SPECIES_ABYSSIN                            = 8;
    public static final int SPECIES_AQUALISH                           = 9;
    public static final int SPECIES_ARCONA                             = 10;
    public static final int SPECIES_ASKAJIAN                           = 11;
    public static final int SPECIES_BITH                               = 12;
    public static final int SPECIES_BOMARR_MONK                        = 13;
    public static final int SPECIES_CHADRA_FAN                         = 14;
    public static final int SPECIES_CHEVIN                             = 15;
    public static final int SPECIES_DANTARI                            = 16;
    public static final int SPECIES_DEVARONIAN                         = 17;
    public static final int SPECIES_DRALL                              = 18;
    public static final int SPECIES_DUG                                = 19;
    public static final int SPECIES_DUROS                              = 20;
    public static final int SPECIES_ELOMIN                             = 21;
    public static final int SPECIES_EWOK                               = 22;
    public static final int SPECIES_FEEORIN                            = 23;
    public static final int SPECIES_FROG_DOG                           = 24;
    public static final int SPECIES_GAMORREAN                          = 25;
    public static final int SPECIES_GORAX                              = 26;
    public static final int SPECIES_GOTAL                              = 27;
    public static final int SPECIES_GRAN                               = 28;
    public static final int SPECIES_GUNGAN                             = 29;
    public static final int SPECIES_GUPIN                              = 30;
    public static final int SPECIES_HUTT                               = 31;
    public static final int SPECIES_ISHI_TIB                           = 32;
    public static final int SPECIES_ITHORIAN                           = 33;
    public static final int SPECIES_JAWA                               = 34;
    public static final int SPECIES_KIFFU                              = 35;
    public static final int SPECIES_KITONAK                            = 36;
    public static final int SPECIES_KLATOOINIAN                        = 37;
    public static final int SPECIES_KOWAKIAN_MONKEY_LIZARD             = 38;
    public static final int SPECIES_KUBAZ                              = 39;
    public static final int SPECIES_MARAUDER                           = 40;
    public static final int SPECIES_MASSASSI_WARRIOR                   = 41;
    public static final int SPECIES_NIKTO                              = 42;
    public static final int SPECIES_ORTOLAN                            = 43;
    public static final int SPECIES_PALOWICK                           = 44;
    public static final int SPECIES_PHLOG                              = 45;
    public static final int SPECIES_QUARREN                            = 46;
    public static final int SPECIES_SELONIAN                           = 47;
    public static final int SPECIES_SHISTAVANEN                        = 48;
    public static final int SPECIES_SULLUSTAN                          = 49;
    public static final int SPECIES_TALZ                               = 50;
    public static final int SPECIES_TEEK                               = 51;
    public static final int SPECIES_TULGAH                             = 52;
    public static final int SPECIES_TOYDARIAN                          = 53;
    public static final int SPECIES_TUSKEN_RAIDER                      = 54;
    public static final int SPECIES_WEEQUAY                            = 55;
    public static final int SPECIES_WHIFFID                            = 56;
    public static final int SPECIES_WISTIE                             = 57;
    public static final int SPECIES_YUZZUM                             = 58;
    public static final int SPECIES_FIORAN                             = 59;
    public static final int SPECIES_ANGLER                             = 60;
    public static final int SPECIES_BAGERASET                          = 61;
    public static final int SPECIES_BANTHA                             = 62;
    public static final int SPECIES_BARK_MITE                          = 63;
    public static final int SPECIES_BAZ_NITCH                          = 64;
    public static final int SPECIES_BEARDED_JAX                        = 65;
    public static final int SPECIES_BLACKFISH                          = 66;
    public static final int SPECIES_BLISTMOK                           = 67;
    public static final int SPECIES_BLUEFISH                           = 68;
    public static final int SPECIES_BLURRG                             = 69;
    public static final int SPECIES_BOAR_WOLF                          = 70;
    public static final int SPECIES_BOCATT                             = 71;
    public static final int SPECIES_BOL                                = 72;
    public static final int SPECIES_BOLLE_BOL                          = 73;
    public static final int SPECIES_BOLMA                              = 74;
    public static final int SPECIES_BORDOK                             = 75;
    public static final int SPECIES_BORGLE                             = 76;
    public static final int SPECIES_BRACKASET                          = 77;
    public static final int SPECIES_CAPPER_SPINEFLAP                   = 78;
    public static final int SPECIES_CARRION_SPAT                       = 79;
    public static final int SPECIES_CHOKU                              = 80;
    public static final int SPECIES_CHUBA                              = 81;
    public static final int SPECIES_COLO_CLAW_FISH                     = 82;
    public static final int SPECIES_CONDOR_DRAGON                      = 83;
    public static final int SPECIES_CORELLIAN_SAND_PANTHER             = 84;
    public static final int SPECIES_CORELLIAN_SLICE_HOUND              = 85;
    public static final int SPECIES_CROWNED_RASP                       = 86;
    public static final int SPECIES_CRYSTAL_SNAKE                      = 87;
    public static final int SPECIES_CU_PA                              = 88;
    public static final int SPECIES_DALYRAKE                           = 89;
    public static final int SPECIES_DEWBACK                            = 90;
    public static final int SPECIES_DUNE_LIZARD                        = 91;
    public static final int SPECIES_DURNI                              = 92;
    public static final int SPECIES_DWARF_NUNA                         = 93;
    public static final int SPECIES_EOPIE                              = 94;
    public static final int SPECIES_FAA                                = 95;
    public static final int SPECIES_FALUMPASET                         = 96;
    public static final int SPECIES_FAMBAA                             = 97;
    public static final int SPECIES_FANNED_RAWL                        = 98;
    public static final int SPECIES_FLEWT                              = 99;
    public static final int SPECIES_FLIT                               = 100;
    public static final int SPECIES_FLITE_RASP                         = 101;
    public static final int SPECIES_FYNOCK                             = 102;
    public static final int SPECIES_GACKLE_BAT                         = 103;
    public static final int SPECIES_GAPING_SPIDER                      = 104;
    public static final int SPECIES_GEKK                               = 105;
    public static final int SPECIES_GNORT                              = 106;
    public static final int SPECIES_GRAUL                              = 107;
    public static final int SPECIES_GREAT_GRASS_PLAINS_TUSK_CAT        = 108;
    public static final int SPECIES_GRONDA                             = 109;
    public static final int SPECIES_GUALAMA                            = 110;
    public static final int SPECIES_GUBBUR                             = 111;
    public static final int SPECIES_GUF_DROLG                          = 112;
    public static final int SPECIES_GULGINAW                           = 113;
    public static final int SPECIES_GURK                               = 114;
    public static final int SPECIES_GURNASET                           = 115;
    public static final int SPECIES_GURREK                             = 116;
    public static final int SPECIES_HANADAK                            = 117;
    public static final int SPECIES_HERMIT_SPIDER                      = 118;
    public static final int SPECIES_HORNED_KREVOL                      = 119;
    public static final int SPECIES_HORNED_RASP                        = 120;
    public static final int SPECIES_HUF_DUN                            = 121;
    public static final int SPECIES_HUURTON                            = 122;
    public static final int SPECIES_IKOPI                              = 123;
    public static final int SPECIES_JELLYFISH                          = 124;
    public static final int SPECIES_KAADU                              = 125;
    public static final int SPECIES_KAITOK                             = 126;
    public static final int SPECIES_KIMA                               = 127;
    public static final int SPECIES_KIMOGILA                           = 128;
    public static final int SPECIES_KITTLE                             = 129;
    public static final int SPECIES_KLIKNIK                            = 130;
    public static final int SPECIES_KRAHBU                             = 131;
    public static final int SPECIES_KRAYT_DRAGON                       = 132;
    public static final int SPECIES_KUPERNUG                           = 133;
    public static final int SPECIES_KUSAK                              = 134;
    public static final int SPECIES_KWI                                = 135;
    public static final int SPECIES_LAA                                = 136;
    public static final int SPECIES_LANGLATCH                          = 137;
    public static final int SPECIES_LANTERN_BIRD                       = 138;
    public static final int SPECIES_MALKLOC                            = 139;
    public static final int SPECIES_MAMIEN                             = 140;
    public static final int SPECIES_MAWGAX                             = 141;
    public static final int SPECIES_MEREK                              = 142;
    public static final int SPECIES_MOTT                               = 143;
    public static final int SPECIES_MURRA                              = 144;
    public static final int SPECIES_MYNOCK                             = 145;
    public static final int SPECIES_NARGLATCH                          = 146;
    public static final int SPECIES_NERF                               = 147;
    public static final int SPECIES_NUNA                               = 148;
    public static final int SPECIES_OPEE_SEA_KILLER                    = 149;
    public static final int SPECIES_PREDATORIAL_BUTTERFLY              = 150;
    public static final int SPECIES_PEKO_PEKO                          = 151;
    public static final int SPECIES_PERLEK                             = 152;
    public static final int SPECIES_PHARPLE                            = 153;
    public static final int SPECIES_PIKET                              = 154;
    public static final int SPECIES_PLUMED_RASP                        = 155;
    public static final int SPECIES_PUFFERFISH                         = 156;
    public static final int SPECIES_PUGORISS                           = 157;
    public static final int SPECIES_PURBOLE                            = 158;
    public static final int SPECIES_QUENKER                            = 159;
    public static final int SPECIES_QURVEL                             = 160;
    public static final int SPECIES_RANCOR                             = 161;
    public static final int SPECIES_RAY                                = 162;
    public static final int SPECIES_REMMER                             = 163;
    public static final int SPECIES_REPTILIAN_FLYER                    = 164;
    public static final int SPECIES_ROBA                               = 165;
    public static final int SPECIES_ROCK_MITE                          = 166;
    public static final int SPECIES_RONTO                              = 167;
    public static final int SPECIES_SALT_MYNOCK                        = 168;
    public static final int SPECIES_SARLACC                            = 169;
    public static final int SPECIES_SCURRIER                           = 170;
    public static final int SPECIES_SHARNAFF                           = 171;
    public static final int SPECIES_SHAUPAUT                           = 172;
    public static final int SPECIES_SHEAR_MITE                         = 173;
    public static final int SPECIES_SKREEG                             = 174;
    public static final int SPECIES_SNORBAL                            = 175;
    public static final int SPECIES_SPINED_PUC                         = 176;
    public static final int SPECIES_SPINED_SNAKE                       = 177;
    public static final int SPECIES_SQUALL                             = 178;
    public static final int SPECIES_SQUILL                             = 179;
    public static final int SPECIES_STINTARIL                          = 180;
    public static final int SPECIES_STRIPED_FISH                       = 181;
    public static final int SPECIES_SWIRL_PRONG                        = 182;
    public static final int SPECIES_TANC_MITE                          = 183;
    public static final int SPECIES_TAUN_TAUN                          = 184;
    public static final int SPECIES_TESSELATED_ARBOREAL_BINJINPHANT    = 185;
    public static final int SPECIES_THUNE                              = 186;
    public static final int SPECIES_TORTON                             = 187;
    public static final int SPECIES_TYBIS                              = 188;
    public static final int SPECIES_VEERMOK                            = 189;
    public static final int SPECIES_VERNE                              = 190;
    public static final int SPECIES_VESP                               = 191;
    public static final int SPECIES_VIR_VUR                            = 192;
    public static final int SPECIES_VLUTORE                            = 193;
    public static final int SPECIES_VOG_EEL                            = 194;
    public static final int SPECIES_VORITOR_LIZARD                     = 195;
    public static final int SPECIES_VYNOCK                             = 196;
    public static final int SPECIES_WHISPER_BIRD                       = 197;
    public static final int SPECIES_WINGED_ORNITH                      = 198;
    public static final int SPECIES_WOMP_RAT                           = 199;
    public static final int SPECIES_WOOLAMANDER                        = 200;
    public static final int SPECIES_WORRT                              = 201;
    public static final int SPECIES_ZUCCA_BOAR                         = 202;
    public static final int SPECIES_ASSASSINDROID                      = 203;
    public static final int SPECIES_ASTROMECH                          = 204;
    public static final int SPECIES_BARTENDERDROID                     = 205;
    public static final int SPECIES_BUGDROID                           = 206;
    public static final int SPECIES_DARKTROOPER                        = 207;
    public static final int SPECIES_DEMOLITIONMECH                     = 208;
    public static final int SPECIES_DOORDROID                          = 209;
    public static final int SPECIES_DROIDEKA                           = 210;
    public static final int SPECIES_INTERROGATOR                       = 211;
    public static final int SPECIES_JEDITRAINER                        = 212;
    public static final int SPECIES_LOADLIFTER                         = 213;
    public static final int SPECIES_MOUSEDROID                         = 214;
    public static final int SPECIES_POWERDROID                         = 215;
    public static final int SPECIES_PROBOT                             = 216;
    public static final int SPECIES_PROTOCOLDROID                      = 217;
    public static final int SPECIES_REPAIRDROID                        = 218;
    public static final int SPECIES_SPIDERDROID                        = 219;
    public static final int SPECIES_SURGICALDROID                      = 220;
    public static final int SPECIES_TATTLETALEDROID                    = 221;
    public static final int SPECIES_TRACKERDROID                       = 222;
    public static final int SPECIES_TREADWELL                          = 223;
    public static final int SPECIES_EV9D9                              = 224;
    public static final int SPECIES_MAUL_PROBE_DROID                   = 225;
    public static final int SPECIES_ATST                               = 226;
    public static final int SPECIES_ATAT                               = 227;
    public static final int SPECIES_GEONOSIAN                          = 228;
    public static final int SPECIES_VERACTYLE                          = 229;

    /**
     * @}
     * @defgroup returned by aiGetMovementState
     * From gameServer/AiMovementBase.h, enum MovementType
     * @{
     */
    public static final int MOVEMENT_IDLE    = 0;
    public static final int MOVEMENT_LOITER  = 1;
    public static final int MOVEMENT_WANDER  = 2;
    public static final int MOVEMENT_FOLLOW  = 3;
    public static final int MOVEMENT_FLEE    = 4;
    public static final int MOVEMENT_MOVE    = 5;
    public static final int MOVEMENT_PATROL  = 6;
    public static final int MOVEMENT_TURN    = 7;
    public static final int MOVEMENT_SWARM   = 8;
    public static final int MOVEMENT_INVALID = 9;

    /**
     * @}
     * @defgroup venueConstants Venue type constants from VenueObjectTemplate.h
     * @{
     */

    /** \internal */
    public static final int VENUE_GENERIC             = 0;
    /** \internal */
    public static final int VENUE_HOUSE               = 1;
    /** \internal */
    public static final int VENUE_SHOP                = 2;
    /** \internal */
    public static final int VENUE_GUILD_HALL          = 3;
    /** \internal */
    public static final int VENUE_GOVERNMENT_BUILDING = 4;

    /**
     * @}
     * @defgroup postureConstants Posture constants
     * @see #getPosture(obj_id)
     * @{
     * From postures.def
     */

    // Postures.def
    public static final int POSTURE_NONE                = -1;   // for script use only, do not send to C code!
    public static final int POSTURE_UPRIGHT             = 0;
    public static final int POSTURE_CROUCHED            = 1;
    public static final int POSTURE_PRONE               = 2;
    public static final int POSTURE_SNEAKING            = 3;
    public static final int POSTURE_BLOCKING            = 4;
    public static final int POSTURE_CLIMBING            = 5;
    public static final int POSTURE_FLYING              = 6;
    public static final int POSTURE_LYING_DOWN          = 7;
    public static final int POSTURE_SITTING             = 8;
    public static final int POSTURE_SKILL_ANIMATING     = 9;
    public static final int POSTURE_DRIVING_VEHICLE     = 10;
    public static final int POSTURE_RIDING_CREATURE     = 11;
    public static final int POSTURE_KNOCKED_DOWN        = 12;
    public static final int POSTURE_INCAPACITATED       = 13;
    public static final int POSTURE_DEAD                = 14;
    public static final int POSTURE_COUNT               = 15;

    // Locomotions.def
    public static final int LOCOMOTION_STANDING                = 0;
    public static final int LOCOMOTION_SNEAKING                = 1;
    public static final int LOCOMOTION_WALKING                 = 2;
    public static final int LOCOMOTION_RUNNING                 = 3;

    public static final int LOCOMOTION_KNEELING                = 4;
    public static final int LOCOMOTION_CROUCH_SNEAKING         = 5;
    public static final int LOCOMOTION_CROUCH_WALKING          = 6;

    public static final int LOCOMOTION_PRONE                   = 7;
    public static final int LOCOMOTION_CRAWLING                = 8;

    public static final int LOCOMOTION_CLIMBING_STATIONARY     = 9;
    public static final int LOCOMOTION_CLIMBING                = 10;

    public static final int LOCOMOTION_HOVERING                = 11;
    public static final int LOCOMOTION_FLYING                  = 12;

    public static final int LOCOMOTION_LYING_DOWN              = 13;

    public static final int LOCOMOTION_SITTING                 = 14;

    public static final int LOCOMOTION_SKILL_ANIMATING         = 15;

    public static final int LOCOMOTION_DRIVING_VEHICLE         = 16;

    public static final int LOCOMOTION_RIDING_CREATURE         = 17;

    public static final int LOCOMOTION_KNOCKED_DOWN            = 18;
    public static final int LOCOMOTION_INCAPACITATED           = 19;
    public static final int LOCOMOTION_DEAD                    = 20;

    public static final int LOCOMOTION_BLOCKING                = 21;

    public static final int LOCOMOTION_COUNT                   = 22;

    /**
     * @}
     * @defgroup stateConstants State constants
     * @see #getState(obj_id)
     * @{
     * From States.def
     */

    // States.def
    public static final int STATE_COVER             = 0;
    public static final int STATE_COMBAT            = 1;
    public static final int STATE_PEACE             = 2;
    public static final int STATE_AIMING            = 3;
    public static final int STATE_MEDITATE          = 4;
    public static final int STATE_BERSERK           = 5;
    public static final int STATE_FEIGN_DEATH       = 6;
    public static final int STATE_CA_EVASIVE        = 7;
    public static final int STATE_CA_NORMAL         = 8;
    public static final int STATE_CA_AGGRESSIVE     = 9;
    public static final int STATE_TUMBLING          = 10;
    public static final int STATE_RALLIED           = 11;
    public static final int STATE_STUNNED           = 12;
    public static final int STATE_BLINDED           = 13;
    public static final int STATE_DIZZY             = 14;
    public static final int STATE_INTIMIDATED       = 15;
    public static final int STATE_IMMOBILIZED       = 16;
    public static final int STATE_FROZEN            = 17;
    public static final int STATE_SWIMMING          = 18;
    public static final int STATE_SITTING_ON_CHAIR  = 19;
    public static final int STATE_CRAFTING          = 20;
    public static final int STATE_GLOWING_JEDI      = 21;   // Jedi master who has died. Can only walk around, chat, and train skills
    public static final int STATE_MASK_SCENT        = 22;
    public static final int STATE_POISONED          = 23;
    public static final int STATE_BLEEDING          = 24;
    public static final int STATE_DISEASED          = 25;
    public static final int STATE_ON_FIRE           = 26;
    public static final int STATE_RIDING_MOUNT      = 27;
    public static final int STATE_MOUNTED_CREATURE  = 28;
    public static final int STATE_PILOTING_SHIP     = 29;
    public static final int STATE_SHIP_OPERATIONS   = 30;
    public static final int STATE_SHIP_GUNNER       = 31;
    public static final int STATE_SHIP_INTERIOR     = 32;
    public static final int STATE_PILOTING_POB_SHIP = 33;
    public static final int STATE_PERFORM_DEATHBLOW = 34;
    public static final int STATE_DISGUISE          = 35;
    public static final int STATE_ELECTRIC_BURNED   = 36;
    public static final int STATE_COLD_BURNED       = 37;
    public static final int STATE_ACID_BURNED       = 38;
    public static final int STATE_ENERGY_BURNED     = 39;
    public static final int STATE_KINETIC_BURNED    = 40;
    public static final int STATE_NUMBER_OF_STATES  = 41;

    public static final int STATE_STEADIED          = 20000; // NOT A REAL STATE, FOR USE IN INTERNAL SYSTEMS

    /**
     * @}
     * @defgroup commandPriorities Command Queue Priority constants
     * From Command.h
     * @{
     */
    public static final int COMMAND_PRIORITY_IMMEDIATE            = 0;
    public static final int COMMAND_PRIORITY_FRONT                = 1;
    public static final int COMMAND_PRIORITY_NORMAL               = 2;
    public static final int COMMAND_PRIORITY_DEFAULT              = 3;
    public static final int COMMAND_PRIORITY_NUMBER_OF_PRIORITIES = 4;

    /**
     * @}
     * @defgroup pvpTypes Pvp type constants
     * From PvpInternal.cpp
     * @{
     */
    public static final int PVPTYPE_NEUTRAL  = 0;
    public static final int PVPTYPE_COVERT   = 1;
    public static final int PVPTYPE_DECLARED = 2;

    /**
     * @}
     * @defgroup pathNodeConstants Path Node type constants
     * From ServerCreatureObjectTemplate.h
     * @{
     */
    public static final int PATHNODE_OPEN                     = 0;
    public static final int PATHNODE_SPARSE_COVER             = 1;
    public static final int PATHNODE_DENSE_COVER              = 2;
    public static final int PATHNODE_NATURAL_INTERIOR         = 3;
    public static final int PATHNODE_ARTIFICIAL_INTERIOR      = 4;
    public static final int PATHNODE_NATURAL_PATH             = 5;
    public static final int PATHNODE_ARTIFICIAL_PATH          = 6;
    public static final int PATHNODE_PASSABLE_WATER           = 7;
    public static final int PATHNODE_IMPASSABLE_WATER         = 8;
    /**
     * @}
     * @defgroup bearingConstants Constants indicating relative directions
     * @{
     */
    public static final int BEARING_F                         = 0;
    public static final int BEARING_FR                        = 1;
    public static final int BEARING_R                         = 2;
    public static final int BEARING_BR                        = 3;
    public static final int BEARING_B                         = 4;
    public static final int BEARING_BL                        = -3;
    public static final int BEARING_L                         = -2;
    public static final int BEARING_FL                        = -1;
    /**
     * @}
     * @defgroup steeringConstants Steering constants
     * @{
     */

    public static final int STEER_TOWARD = 0;
    public static final int STEER_AWAY = 1;
    /**
     * @}
     * @defgroup experimentResultConstants Crafting experiment result constants
     * @{
     */
    public static final int EXP_CRITICAL_SUCCESS   = 0;
    public static final int EXP_GREAT_SUCCESS      = 1;
    public static final int EXP_GOOD_SUCCESS       = 2;
    public static final int EXP_MODERATE_SUCCESS   = 3;
    public static final int EXP_SUCCESS            = 4;
    public static final int EXP_FAILURE            = 5;
    public static final int EXP_MODERATE_FAILURE   = 6;
    public static final int EXP_BIG_FAILURE        = 7;
    public static final int EXP_STUPENDOUS_FAILURE = 8;
    /* @}*/

    /**
     * @}
     * @defgroup housingConstants Housing constants.  This should correspond to CreatureObject.cpp
     * @{
     */
    public static final int HOUSING_MAX_LOTS       = 10;
    /* @}*/

/**
     * @}
     * @defgroup container error code constants.  This should correspond to Container.h
     * @{
     */
    public static final int CEC_SUCCESS            = 0;
    public static final int CEC_UNKNOWN            = 1;
    public static final int CEC_ADD_SELF            = 2;
    public static final int CEC_FULL               = 3;
    public static final int CEC_SLOT_OCCUPIED      = 4;
    public static final int CEC_NO_SLOT            = 5;
    public static final int CEC_INVALID_ARRANGEMENT= 6;
    public static final int CEC_WRONG_TYPE         = 7;
    public static final int CEC_NO_PERMISSION      = 8;
    public static final int CEC_NO_ACCECSS         = 9;
    public static final int CEC_NOT_FOUND      = 10;

    /**
     * @}
     * @defgroup rankConstants Player rank designation constants.
     * There is a client datatables that map rank/gender/species
     * to a wearable.
     * @{
     */
    public static final int RANK_NONE               = 0;

    public static final int RANK_PRIVATE            = 1;
    public static final int RANK_LANCE_CORPORAL     = 2;
    public static final int RANK_SERGEANT           = 3;
    public static final int RANK_STAFF_SERGEANT     = 4;
    public static final int RANK_STAFF_CORPORAL     = 5;
    public static final int RANK_WARRANT_OFFICER_2  = 6;
    public static final int RANK_MASTER_SERGEANT    = 7;
    public static final int RANK_SERGEANT_MAJOR     = 8;
    public static final int RANK_WARRANT_OFFICER_1  = 9;
    public static final int RANK_SECOND_LIEUTENANT  = 10;
    public static final int RANK_FIRST_LIEUTENANT   = 11;
    public static final int RANK_CAPTAIN            = 12;
    public static final int RANK_MAJOR              = 13;
    public static final int RANK_LIEUTENANT_COLONEL = 14;
    public static final int RANK_COLONEL            = 15;
    public static final int RANK_HIGH_COLONEL       = 16;
    public static final int RANK_BRIGADIER_GENERAL  = 17;
    public static final int RANK_MAJOR_GENERAL      = 18;
    public static final int RANK_LIETENANT_GENERAL  = 19;
    public static final int RANK_GENERAL            = 20;
    public static final int RANK_HIGH_GENERAL       = 21;
    public static final int RANK_SURFACE_MARSHALL   = 22;

/* @}*/

    /**
     * @}
     * @defgroup defines timer classes
     * @{
     */
    public static final int TIMER_INVALID_TIMER = -1;
    public static final int TIMER_WARMUP        = 0;
    public static final int TIMER_EXECUTE       = 1;
    public static final int TIMER_COOLDOWN      = 2;

    public static final int TIMERSTATE_INVALID  = -1;
    public static final int TIMERSTATE_WAITING  = 0;
    public static final int TIMERSTATE_DELAYED  = 1;
    public static final int TIMERSTATE_WARMUP   = 2;
    public static final int TIMERSTATE_EXECUTE  = 3;

    public static final int TIME_MAX        = 0x10;
    public static final int TIME_CURRENT    = 0x20;

    /**
     * @}
     * @defgroup defines cybernetics UI constants
     * @{
    */
    public static final int CYBERNETICS_UI_OPENTYPE_INSTALL = 0;
    public static final int CYBERNETICS_UI_OPENTYPE_UNINSTALL = 1;
    public static final int CYBERNETICS_UI_OPENTYPE_REPAIR = 2;
    public static final int CYBERNETICS_UI_OPENTYPE_VIEW = 3;

    public static final int CYBERNETICS_UI_CHANGETYPE_INSTALL = 0;
    public static final int CYBERNETICS_UI_CHANGETYPE_UNINSTALL = 1;
    public static final int CYBERNETICS_UI_CHANGETYPE_REPAIR = 2;

    /**
     * @}
     * @defgroup xpConstants Experience point constants.
     * @{
     */
    public static final int XP_ERROR = Integer.MIN_VALUE;
    /* @}*/
    public static final int NOTE_ICON_STYLE_NONE = 0;
    public static final int NOTE_ICON_STYLE_EXCLAMATION = 1;
    public static final int NOTE_ICON_STYLE_QUESTION = 2;

    /**
     * @}
     * @defgroup flyTextFlag Fly text flags
     * @{
     */
    public static final int FLY_TEXT_FLAG_PRIVATE = 1;
    public static final int FLY_TEXT_FLAG_SHOW_IN_CHAT_BOX = 2;
    public static final int FLY_TEXT_FLAG_IS_DAMAGE_FROM_PLAYER = 4;
    public static final int FLY_TEXT_FLAG_IS_SNARE = 8;
    public static final int FLY_TEXT_FLAG_IS_GLANCING_BLOW = 16;
    public static final int FLY_TEXT_FLAG_IS_CRITICAL_HIT = 32;
    public static final int FLY_TEXT_FLAG_IS_LUCKY = 64;
    public static final int FLY_TEXT_FLAG_IS_DOT = 128;
    public static final int FLY_TEXT_FLAG_IS_BLEED = 256;
    public static final int FLY_TEXT_FLAG_IS_HEAL = 512;
    public static final int FLY_TEXT_FLAG_IS_FREESHOT = 1024;

	/**
     * @}
     * @defgroup holgram types
     * @{
     */
	public static final int HOLOGRAM_NONE = -1;
	public static final int HOLOGRAM_TYPE1_QUALITY1 = 0;
	public static final int HOLOGRAM_TYPE1_QUALITY2 = 1;
	public static final int HOLOGRAM_TYPE1_QUALITY3 = 2;
	public static final int HOLOGRAM_TYPE1_QUALITY4 = 3;


    /**
     * Returns an obj_id for a given id number.
     * In order to match compliance with previous behavior, will return null if id == 0
     * otherwishe, it will construct a new obj_id
     */
    static public obj_id getObjIdWithNull(long id)
    {
        if ( id == 0 )
            return null;

        return obj_id.getObjId(new Long(id));
    } // getObjId

    /**
     * Returns an long for a given obj_id
     * In order to match compliance with previous behavior, will return 0 if the obj_id is null
     * otherwishe, it will construct a new obj_id
     */
    static public long getLongWithNull(obj_id id)
    {
        if ( id == null )
            return 0;

        return id.getValue();
    } // getObjId

    //*********************************************************************
    // native methods
    //*********************************************************************

    /**
     * @defgroup debuggingMethods Debugging methods. These methods are removed
     * from scripts that are compiled in release mode.
     * @{
     */
    // debugging methods
    /**
     * Prints a message to the console of the player controlling the object with
     * the given id. Debug mode only.
     * @param object    the object(controller) to print to
     * @param msg       the message to print
     */
    private static native void _debugConsoleMsg(long object, String msg);
    public static void debugConsoleMsg(obj_id object, String msg)
    {
        _debugConsoleMsg(getLongWithNull(object), msg);
    }
    /**
     * Causes the object to "speak" the given message. Debug mode only.
     * @param object    the object to speak
     * @param msg       the message to print
     */
    private static native void _debugSpeakMsg(long object, String msg);
    public static void debugSpeakMsg(obj_id object, String msg)
    {
        _debugSpeakMsg(getLongWithNull(object), msg);
    }

    /**
     * Causes the object to "speak" the given message. Debug mode only.
     * @param forceMsg  whether to actually speak the msg
     * @param object    the object to speak
     * @param msg       the message to print
     */
    public static void debugSpeakMsgc(boolean forceMsg, obj_id object, String msg)
    {
        if (forceMsg)
        {
            debugSpeakMsg(object, msg);
        }
    }

    /**
     * Prints a message to the server console. Debug mode only.
     * @param object    the object sending the message (may be null)
     * @param msg       the message to print
     */
    private static native void _debugServerConsoleMsg(long object, String msg);
    public static void debugServerConsoleMsg(obj_id object, String msg)
    {
        _debugServerConsoleMsg(getLongWithNull(object), msg);
    }

    /**
     * Logs a message.
     * @param channel the channel to log to
     * @param msg     the message to log
     */
    public static void LOG(String channel, String msg)
    {
        LOG(channel, msg, null, null);
    }

    /**
     * Conditionally logs a message.
     * @param forceLog whether to actually log
     * @param channel  the channel to log to
     * @param msg      the message to log
     */
    public static void LOGC(boolean forceLog, String channel, String msg)
    {
        if (forceLog)
        {
            LOG(channel, msg, null, null);
        }
    }

    /**
     * Logs a message involving a player. The player info will replace the tag %TU in the message.
     * (The tag should match the prose package tag for user).
     * @param channel the channel to log to
     * @param msg     the message to log
     * @param player  the player for the message
     */
    public static void LOG(String channel, String msg, obj_id player)
    {
        LOG(channel, msg, player, null);
    }

    /**
     * Logs a message involving two players. The info for player one will replace the tag %TU in
     * the message, and the info for player two will replace the tag %TT in the message.
     * (The tags should match the prose package tag for user and target).
     * @param channel  the channel to log to
     * @param msg      the message to log
     * @param player1  the 1st player for the message
     * @param player2  the 2nd player for the message
     */
    public static void LOG(String channel, String msg, obj_id player1, obj_id player2)
    {
        _LOG(channel, msg, getSelf(), player1, player2, false);
    }

    public static void LIVE_LOG(String channel, String msg)
    {
        _LOG(channel, msg, getSelf(), null, null, true);
    }

    /**
     * Logs a message involving two players. The info for player one will replace the tag %TU in
     * the message, and the info for player two will replace the tag %TT in the message.
     * (The tags should match the prose package tag for user and target).
     * @param channel  the channel to log to
     * @param msg      the message to log
     * @param self     id of the object where the log is coming from
     * @param player1  the 1st player for the message
     * @param player2  the 2nd player for the message
     * @param alwaysLog flag to ignore the disableScriptLogs flag and always log this message
     */
    private static native void __LOG(String channel, String msg, long self, long player1, long player2, boolean alwaysLog);
    private static void _LOG(String channel, String msg, obj_id self, obj_id player1, obj_id player2, boolean alwaysLog)
    {
        __LOG(channel, msg, getLongWithNull(self), getLongWithNull(player1), getLongWithNull(player2), alwaysLog);
    }

    public static native void logBalance(String msg);

    /**
     * Logs a message to the customer service logs (looting, corpses, death, etc).
     * @param channel sub channel to log to (e.g. "Corpse:", "Insure:", "Loot:")
     * @param msg     the message to log
     */
    public static void CustomerServiceLog(String channel, String msg)
    {
        CustomerServiceLog(channel, msg, null, null);
    }

    /**
     * Logs a message to the customer service logs (looting, corpses, death, etc) involving a player.
     * The player info will replace the tag %TU in the message. (The tag should match the prose package tag for user).
     * @param channel sub channel to log to (e.g. "Corpse:", "Insure:", "Loot:")
     * @param msg     the message to log
     * @param player  the player for the message
     */
    public static void CustomerServiceLog(String channel, String msg, obj_id player)
    {
        CustomerServiceLog(channel, msg, player, null);
    }

    /**
     * Logs a message to the customer service logs (looting, corpses, death, etc) involving two players. The info
     * for player one will replace the tag %TU in the message, and the info for player two will replace the tag
     * %TT in the message. (The tags should match the prose package tag for user and target).
     * @param channel sub channel to log to (e.g. "Corpse:", "Insure:", "Loot:")
     * @param msg     the message to log
     * @param player1  the 1st player for the message
     * @param player2  the 2nd player for the message
     */
    public static void CustomerServiceLog(String channel, String msg, obj_id player1, obj_id player2)
    {
        _LOG("CustomerService", channel + ": " + msg, getSelf(), player1, player2, true);
    }

    // Returns the CPU time (DEBUG ONLY)
    public static native long queryPerformanceCounter();
    public static native long queryPerformanceCounterFrequency();


    private static boolean m_traceLoggingEnabled;
    public static void TRACE_LOG(String channel, String msg)
    {
        if(m_traceLoggingEnabled)
        {
            LOG(channel, msg);
        }
    }

    public static void enableTraceLogging()
    {
        m_traceLoggingEnabled = true;
    }

    public static void disableTraceLogging()
    {
        m_traceLoggingEnabled = false;
    }

    public static native void PROFILER_START(String sectionName);
    public static native void PROFILER_STOP(String sectionName);
    public static native void PROFILER_START_ACCUM(String sectionName);
    public static native void PROFILER_STOP_ACCUM(String sectionName);

    public static native void disableGameMemoryDump();
    public static native void debugMemoryReport();
    public static native void debugMemoryReportMap();
    public static native void generateJavacore();

    /**
     * @}
     * @defgroup objvarMethods Object variable methods
     * @{
     **/

    /**
     * Finds an obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the obj_var, or null if not found
     */
    private static native obj_var _getObjVar(long object, String name);
    public static obj_var getObjVar(obj_id object, String name)
    {
        return _getObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds an integer obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the integer, or 0 if not found
     */
    private static native int _getIntObjVar(long object, String name);
    public static int getIntObjVar(obj_id object, String name)
    {
        return _getIntObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds an integer array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the integer array, or null if not found
     */
    private static native int[] _getIntArrayObjVar(long object, String name);
    public static int[] getIntArrayObjVar(obj_id object, String name)
    {
        return _getIntArrayObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds an integer array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the integer array, or null if not found
     */
    public static Vector getResizeableIntArrayObjVar(obj_id object, String name)
    {
        int[] array = getIntArrayObjVar(object, name);
        if (array != null)
        {
            Integer[] newArray = new Integer[array.length];
            for ( int i = 0; i < array.length; ++i )
                newArray[i] = new Integer(array[i]);
            return new Vector(Arrays.asList(newArray));
        }
        return null;
    }
    /**
     * Finds a float obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the float, or 0 if not found
     */
    private static native float _getFloatObjVar(long object, String name);
    public static float getFloatObjVar(obj_id object, String name)
    {
        return _getFloatObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a float array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the float array, or null if not found
     */
    private static native float[] _getFloatArrayObjVar(long object, String name);
    public static float[] getFloatArrayObjVar(obj_id object, String name)
    {
        return _getFloatArrayObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a float array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the float array, or null if not found
     */
    public static Vector getResizeableFloatArrayObjVar(obj_id object, String name)
    {
        float[] array = getFloatArrayObjVar(object, name);
        if (array != null)
        {
            Float[] newArray = new Float[array.length];
            for ( int i = 0; i < array.length; ++i )
                newArray[i] = new Float(array[i]);
            return new Vector(Arrays.asList(newArray));
        }
        return null;
    }
    /**
     * Finds a string obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the string, or null if not found
     */
    private static native String _getStringObjVar(long object, String name);
    public static String getStringObjVar(obj_id object, String name)
    {
        return _getStringObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a string array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the string array, or null if not found
     */
    private static native String[] _getStringArrayObjVar(long object, String name);
    public static String[] getStringArrayObjVar(obj_id object, String name)
    {
        return _getStringArrayObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a string array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the string array, or null if not found
     */
    public static Vector getResizeableStringArrayObjVar(obj_id object, String name)
    {
        String[] array = getStringArrayObjVar(object, name);
        if (array != null)
            return new Vector(Arrays.asList(array));
        return null;
    }
    /**
     * Finds an obj_id obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the obj_id, or null if not found
     */
    private static native long _getObjIdObjVar(long object, String name);
    public static obj_id getObjIdObjVar(obj_id object, String name)
    {
        return getObjIdWithNull(_getObjIdObjVar(getLongWithNull(object), name));
    }
    /**
     * Finds an obj_id array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the obj_id array, or null if not found
     */
    private static native long[] _getObjIdArrayObjVar(long object, String name);
    public static obj_id[] getObjIdArrayObjVar(obj_id object, String name)
    {
        long[] _ret_long = _getObjIdArrayObjVar(getLongWithNull(object), name);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Finds an obj_id array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the obj_id array, or null if not found
     */
    public static Vector getResizeableObjIdArrayObjVar(obj_id object, String name)
    {
        obj_id[] array = getObjIdArrayObjVar(object, name);
        if (array != null)
            return new Vector(Arrays.asList(array));
        return null;
    }
    /**
     * Finds a location obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the location, or null if not found
     */
    private static native location _getLocationObjVar(long object, String name);
    public static location getLocationObjVar(obj_id object, String name)
    {
        return _getLocationObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a location array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the location array, or null if not found
     */
    private static native location[] _getLocationArrayObjVar(long object, String name);
    public static location[] getLocationArrayObjVar(obj_id object, String name)
    {
        return _getLocationArrayObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a location array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the location array, or null if not found
     */
    public static Vector getResizeableLocationArrayObjVar(obj_id object, String name)
    {
        location[] array = getLocationArrayObjVar(object, name);
        if (array != null)
            return new Vector(Arrays.asList(array));
        return null;
    }
    /**
     * Finds a string_id obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the string_id, or null if not found
     */
    private static native string_id _getStringIdObjVar(long object, String name);
    public static string_id getStringIdObjVar(obj_id object, String name)
    {
        return _getStringIdObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a string_id array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the string_id array, or null if not found
     */
    private static native string_id[] _getStringIdArrayObjVar(long object, String name);
    public static string_id[] getStringIdArrayObjVar(obj_id object, String name)
    {
        return _getStringIdArrayObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a transform obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the transform, or null if not found
     */
    private static native transform _getTransformObjVar(long object, String name);
    public static transform getTransformObjVar(obj_id object, String name)
    {
        return _getTransformObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a transform array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the transform array, or null if not found
     */
    private static native transform[] _getTransformArrayObjVar(long object, String name);
    public static transform[] getTransformArrayObjVar(obj_id object, String name)
    {
        return _getTransformArrayObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a vector obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the vector, or null if not found
     */
    private static native vector _getVectorObjVar(long object, String name);
    public static vector getVectorObjVar(obj_id object, String name)
    {
        return _getVectorObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds a vector array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the vector array, or null if not found
     */
    private static native vector[] _getVectorArrayObjVar(long object, String name);
    public static vector[] getVectorArrayObjVar(obj_id object, String name)
    {
        return _getVectorArrayObjVar(getLongWithNull(object), name);
    }
    /**
     * Finds an boolean obj_var with a given name on an object. Note that since
     * we don't have real boolean objvars we get the value as an int and convert it.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the boolean value
     */
    public static boolean getBooleanObjVar(obj_id object, String name)
    {
        int value = getIntObjVar(object, name);
        if ( value == 0 )
            return false;
        return true;
    }
    /**
     * Finds an attrib_mod obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the attrib_mod, or null if not found
     */
    public static attrib_mod getAttribModObjVar(obj_id object, String name)
    {
        String data = getStringObjVar(object, name);
        if (data == null)
            return null;
        attrib_mod mod = new attrib_mod(data);
        if (mod.getAttribute() < 0)
            mod = null;
        return mod;
    }
    /**
     * Finds an attrib_mod array obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the attrib_mod array, or null if not found
     */
    public static attrib_mod[] getAttribModArrayObjVar(obj_id object, String name)
    {
        String[] data = getStringArrayObjVar(object, name);
        if (data == null)
            return null;
        attrib_mod[] mod = new attrib_mod[data.length];
        for (int i = 0; i < data.length; ++i)
        {
            mod[i] = new attrib_mod(data[i]);
            if (mod[i].getAttribute() < 0)
            {
                mod = null;
                break;
            }
        }
        return mod;
    }
    /**
     * Finds an obj_var_list obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return the obj_var_list, or null if not found
     */
    private static native obj_var_list _getObjVarList(long object, String name);
    public static obj_var_list getObjVarList(obj_id object, String name)
    {
        return _getObjVarList(getLongWithNull(object), name);
    }
    /**
     * Deletes an obj_var with a given name on an object.
     * @param object    the object to search
     * @param name      the objvar name to search for
     */
    private static native void _removeObjVar(long object, String name);
    public static void removeObjVar(obj_id object, String name)
    {
        _removeObjVar(getLongWithNull(object), name);
    }
    /**
     * Deletes all the obj_vars on an object.
     * @param object    the object
     */
    private static native void _removeAllObjVars(long object);
    public static void removeAllObjVars(obj_id object)
    {
        _removeAllObjVars(getLongWithNull(object));
    }
    /**
     * Tests if an obj_var with a given name on an object exists.
     * @param object    the object to search
     * @param name      the objvar name to search for
     * @return true on success, false on fail
     */
    private static native boolean _hasObjVar(long object, String name);
    public static boolean hasObjVar(obj_id object, String name)
    {
        return _hasObjVar(getLongWithNull(object), name);
    }
    /** @deprecated You should use the data-specific set methods.  */
    private static native boolean _setObjVar(long object, String name, obj_var data);
    public static boolean setObjVar(obj_id object, String name, obj_var data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes an integer obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, int data);
    public static boolean setObjVar(obj_id object, String name, int data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes an integer array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, int[] data);
    public static boolean setObjVar(obj_id object, String name, int[] data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a float obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, float data);
    public static boolean setObjVar(obj_id object, String name, float data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a float array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, float[] data);
    public static boolean setObjVar(obj_id object, String name, float[] data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a string obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, String data);
    public static boolean setObjVar(obj_id object, String name, String data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a string array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, String[] data);
    public static boolean setObjVar(obj_id object, String name, String[] data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes an obj_id obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, long data);
    public static boolean setObjVar(obj_id object, String name, obj_id data)
    {
        return _setObjVar(getLongWithNull(object), name, getLongWithNull(data));
    }
    /**
     * Adds/changes an obj_id array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, long[] data);
    public static boolean setObjVar(obj_id object, String name, obj_id[] data)
    {
        long[] _data = null;
        if (data != null)
        {
            _data = new long[data.length];
            for (int _i = 0; _i < data.length; ++_i)
                _data[_i] = getLongWithNull(data[_i]);
        }
        return _setObjVar(getLongWithNull(object), name, _data);
    }
    /**
     * Adds/changes a location obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, location data);
    public static boolean setObjVar(obj_id object, String name, location data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a location array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, location[] data);
    public static boolean setObjVar(obj_id object, String name, location[] data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a string_id obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, string_id data);
    public static boolean setObjVar(obj_id object, String name, string_id data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a string_id array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, string_id[] data);
    public static boolean setObjVar(obj_id object, String name, string_id[] data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a transform obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, transform data);
    public static boolean setObjVar(obj_id object, String name, transform data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a transform array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, transform[] data);
    public static boolean setObjVar(obj_id object, String name, transform[] data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a vector obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, vector data);
    public static boolean setObjVar(obj_id object, String name, vector data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a vector array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    private static native boolean _setObjVar(long object, String name, vector[] data);
    public static boolean setObjVar(obj_id object, String name, vector[] data)
    {
        return _setObjVar(getLongWithNull(object), name, data);
    }
    /**
     * Adds/changes a boolean obj_var on an object. Note that since we don't have
     * real boolean objvars, we store the data as an integer.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    public static boolean setObjVar(obj_id object, String name, boolean data)
    {
        int value = 0;
        if ( data )
            value = 1;
        return setObjVar(object, name, value);
    }
    /**
     * Adds/changes a boolean obj_var array on an object. Note that since we don't have
     * real boolean objvars, we store the data as an integer.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    public static boolean setObjVar(obj_id object, String name, boolean[] data)
    {
        if (data == null)
            return false;
        int[] newData = new int[data.length];
        for (int i = 0; i < data.length; ++i)
        {
            if ( data[i] )
                newData[i] = 1;
            else
                newData[i] = 0;
        }
        return setObjVar(object, name, newData);
    }
    /**
     * Adds/changes an attrib_mod obj_var on an object. Note that since we don't have
     * real attrib_mod objvars, we store the data as a string.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    public static boolean setObjVar(obj_id object, String name, attrib_mod data)
    {
        if (data == null)
            return false;
        return setObjVar(object, name, data.pack());
    }
    /**
     * Adds/changes an attrib_mod array obj_var on an object. Note that since we don't have
     * real attrib_mod objvars, we store the data as a string.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    public static boolean setObjVar(obj_id object, String name, attrib_mod[] data)
    {
        if (data == null)
            return false;
        String[] newData = new String[data.length];
        for (int i = 0; i < data.length; ++i)
        {
            if (data[i] == null)
                return false;
            newData[i] = data[i].pack();
        }
        return setObjVar(object, name, newData);
    }
    /**
     * !!! THIS FUNCTION SHOULD BE REMOVED AFTER ALL SCRIPTS HAVE BEEN RECOMPILED TO USE THE FUNCTION BELOW !!!
     * Adds/changes a resizeable array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    public static boolean setObjVar(obj_id object, String name, Vector data)
    {
        // if we can't determine the class of the elements in data, we have to exit with an error
        if (data == null || data.size() == 0)
        {
            debugServerConsoleMsg(null, "base_class.setObjVar(Vector) got data for objvar " + name + " that is null");
            return false;
        }

        Object o = data.get(0);
        if (o instanceof Integer)
        {
            return setObjVar(object, name, data, resizeableArrayTypeint);
        }
        else if (o instanceof Float)
        {
            return setObjVar(object, name, data, resizeableArrayTypefloat);
        }
        else if (o instanceof Boolean)
        {
            return setObjVar(object, name, data, resizeableArrayTypeboolean);
        }
        else if (o instanceof String)
        {
            return setObjVar(object, name, data, resizeableArrayTypestring);
        }
        else if (o instanceof obj_id)
        {
            return setObjVar(object, name, data, resizeableArrayTypeobj_id);
        }
        else if (o instanceof location)
        {
            return setObjVar(object, name, data, resizeableArrayTypelocation);
        }
        else if (o instanceof string_id)
        {
            return setObjVar(object, name, data, resizeableArrayTypestring_id);
        }
        else if (o instanceof transform)
        {
            return setObjVar(object, name, data, resizeableArrayTypetransform);
        }
        else if (o instanceof vector)
        {
            return setObjVar(object, name, data, resizeableArrayTypevector);
        }
        else if (o instanceof attrib_mod)
        {
            return setObjVar(object, name, data, resizeableArrayTypeattrib_mod);
        }

        debugServerConsoleMsg(null, "base_class.setObjVar(Vector) got data for objvar " + name +
            " that is of unhandled type " + o.getClass());
        return false;
    }
    /**
     * Adds/changes a resizeable array obj_var on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    public static boolean setObjVar(obj_id object, String name, Vector data, Object dataType)
    {
        // if we can't determine the class of the elements in data, we have to exit with an error
        if (data == null)
        {
            debugServerConsoleMsg(null, "base_class.setObjVar(Vector) got data for objvar " + name + " that is null");
            return false;
        }
        if (dataType == null)
        {
            debugServerConsoleMsg(null, "base_class.setObjVar(Vector) got dataType for objvar " + name + " that is null");
            return false;
        }

        if (dataType == resizeableArrayTypeint)
        {
            int[] x = new int[data.size()];
            for ( int i = 0; i < x.length; ++i )
            {
                x[i] = ((Integer)data.get(i)).intValue();
            }
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypefloat)
        {
            float[] x = new float[data.size()];
            for ( int i = 0; i < x.length; ++i )
            {
                x[i] = ((Float)data.get(i)).floatValue();
            }
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypeboolean)
        {
            boolean[] x = new boolean[data.size()];
            for ( int i = 0; i < x.length; ++i )
            {
                x[i] = ((Boolean)data.get(i)).booleanValue();
            }
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypestring || dataType == resizeableArrayTypeString)
        {
            String[] x = new String[data.size()];
            data.toArray(x);
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypeobj_id)
        {
            obj_id[] x = new obj_id[data.size()];
            data.toArray(x);
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypelocation)
        {
            location[] x = new location[data.size()];
            data.toArray(x);
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypestring_id)
        {
            string_id[] x = new string_id[data.size()];
            data.toArray(x);
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypetransform)
        {
            transform[] x = new transform[data.size()];
            data.toArray(x);
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypevector)
        {
            vector[] x = new vector[data.size()];
            data.toArray(x);
            return setObjVar(object, name, x);
        }
        else if (dataType == resizeableArrayTypeattrib_mod)
        {
            attrib_mod[] x = new attrib_mod[data.size()];
            data.toArray(x);
            return setObjVar(object, name, x);
        }

        debugServerConsoleMsg(null, "base_class.setObjVar(Vector) got data for objvar " + name +
            " that is of unhandled type " + dataType.getClass());
        return false;
    }
    /**
     * Sets an obj_var of an unknown type on an object.
     * @param object    the object
     * @param name      the obj_var name
     * @param data      the obj_var value
     * @return true on success, false on fail
     */
    public static boolean setObjVar(obj_id object, String name, Object data)
    {
        if (data instanceof Integer)
            return setObjVar(object, name, ((Integer)data).intValue());
        else if (data instanceof int[])
            return setObjVar(object, name, (int[])data);
        else if (data instanceof Float)
            return setObjVar(object, name, ((Float)data).floatValue());
        else if (data instanceof float[])
            return setObjVar(object, name, (float[])data);
        if (data instanceof Boolean)
            return setObjVar(object, name, ((Boolean)data).booleanValue());
        else if (data instanceof boolean[])
            return setObjVar(object, name, (boolean[])data);
        else if (data instanceof String)
            return setObjVar(object, name, (String)data);
        else if (data instanceof String[])
            return setObjVar(object, name, (String[])data);
        else if (data instanceof obj_id)
            return setObjVar(object, name, (obj_id)data);
        else if (data instanceof obj_id[])
            return setObjVar(object, name, (obj_id[])data);
        else if (data instanceof location)
            return setObjVar(object, name, (location)data);
        else if (data instanceof location[])
            return setObjVar(object, name, (location[])data);
        else if (data instanceof string_id)
            return setObjVar(object, name, (string_id)data);
        else if (data instanceof string_id[])
            return setObjVar(object, name, (string_id[])data);
        else if (data instanceof transform)
            return setObjVar(object, name, (transform)data);
        else if (data instanceof transform[])
            return setObjVar(object, name, (transform[])data);
        else if (data instanceof vector)
            return setObjVar(object, name, (vector)data);
        else if (data instanceof vector[])
            return setObjVar(object, name, (vector[])data);
        else if (data instanceof attrib_mod)
            return setObjVar(object, name, (attrib_mod)data);
        else if (data instanceof attrib_mod[])
            return setObjVar(object, name, (attrib_mod[])data);
        return false;
    }
    /**
     * Adds an obj_var_list to an object.
     * @param object    the object
     * @param name      the obj_var_list name
     * @return true on success, false on fail
     */
    private static native boolean _setObjVarList(long object, String name);
    public static boolean setObjVarList(obj_id object, String name)
    {
        return _setObjVarList(getLongWithNull(object), name);
    }
    /**
     * Copies on obj_var/obj_var_list from one object to another.
     * @param from      the source object
     * @param to        the destination object
     * @param name      the obj_var name
     * @return true on success, false on fail
     */
    private static native boolean _copyObjVar(long from, long to, String name);
    public static boolean copyObjVar(obj_id from, obj_id to, String name)
    {
        return _copyObjVar(getLongWithNull(from), getLongWithNull(to), name);
    }
    /**
     * Packs all objvars from an object into a string.
     *
     * @param source  the object to pack objvars for
     * @param prefix  the prefix to look for objvars with which to pack
     * @return the packed string of the objvars
     */
    private static native String _getPackedObjvars(long source, String prefix);
    public static String getPackedObjvars(obj_id source, String prefix)
    {
        return _getPackedObjvars(getLongWithNull(source), prefix);
    }

    public static String getPackedObjvars(obj_id source)
    {
        return getPackedObjvars(source, null);
    }

    /**
     * Sets objvars on an object from a packed string (generated with getPackedObjvars)
     *
     * @param target  the object to unpack the objvars onto
     * @param packedVars  the packed variable string

	The indexes for packed objvars are:

	enum DynamicVariableType {
		INT=0, INT_ARRAY,
		REAL, REAL_ARRAY,
		STRING, STRING_ARRAY,
		NETWORK_ID, NETWORK_ID_ARRAY,
		LOCATION, LOCATION_ARRAY,
		LIST,
		STRING_ID, STRING_ID_ARRAY,
		TRANSFORM, TRANSFORM_ARRAY,
		VECTOR, VECTOR_ARRAY
	};
     */
    private static native void _setPackedObjvars(long target, String packedVars);
    public static void setPackedObjvars(obj_id target, String packedVars)
    {
        _setPackedObjvars(getLongWithNull(target), packedVars);
    }

    /*@}*/

    /**
    * @defgroup scriptMethods Script methods
    */
    /*@{*/

    /**
     * Attaches a script to an object.
     * @param object        the object to attach to
     * @param scriptName    the name of the script to attach
     * @return the result of the OnAttach function of the script; if OnAttach doesn't exist, SCRIPT_CONTINUE on success, or SCRIPT_OVERRIDE on fail
     */
    private static native int _attachScript(long object, String scriptName);
    public static int attachScript(obj_id object, String scriptName)
    {
        return _attachScript(getLongWithNull(object), scriptName);
    }
    /**
     * Removes a script from an object.
     * @param object        the object to detach from
     * @param scriptName    the name of the script to attach
     * @return true if the script was detached, false if not
     */
    private static native boolean _detachScript(long object, String scriptName);
    public static boolean detachScript(obj_id object, String scriptName)
    {
        return _detachScript(getLongWithNull(object), scriptName);
    }
    /**
     * Removes all the scripts from an object.
     * @param object        the object to detach from
     * @return true if all the scripts were detached, false if not
     */
    private static native boolean _detachAllScripts(long object);
    public static boolean detachAllScripts(obj_id object)
    {
        return _detachAllScripts(getLongWithNull(object));
    }
    /**
     * Checks to see if an object has a script attached.
     * @param object        the object to test
     * @param scriptName    the name of the script to look for
     * @return true if the script exists, false if not
     */
    public static boolean hasScript(obj_id object, String scriptName)
    {
        if (object != null && scriptName != null)
            return object.hasScript(scriptName);
        return false;
    }

    /**
     * Gets a list of all the scripts attached to an object.
     * @param object        the object to test
     * @return an array of script names attached to the object, or null on error
     */
    public static String[] getScriptList(obj_id object)
    {
        if (object != null)
            return object.getScripts();
        return null;
    }

    /**
     * Forces a script trigger to execute on a specific script. The script must already be attached to the object. DEBUG ONLY.
     * @param object        the object
     * @param script        name of the script to trigger
     * @param triggerId     id of the trigger to execute
     * @param params        array of params to be passed to the trigger; trigger specific, "self" does not have to be added
     * @return the return value of the trigger, or SCRIPT_OVERRIDE on error
     */
    private static native int _triggerScript(long object, String script, int triggerId, Object[] params);
    public static int triggerScript(obj_id object, String script, int triggerId, Object[] params)
    {
        return _triggerScript(getLongWithNull(object), script, triggerId, params);
    }

    /**
     * Tests to see if a given script exists.
     * @param script        name of the script to test
     * @return true if the script exists, false if not
     */
    public static boolean scriptExists(String script)
    {
        if (script != null)
        {
            // if the script name has '.' in it, convert them to '\'
            String pathedName = script.replace('.', java.io.File.separatorChar);

            String fullname = script_entry.getScriptPath() + "script" + java.io.File.separatorChar + pathedName + ".class";
            System.out.println("base_class.scriptExists, testing file " + fullname);

            File file = new File(fullname);
            return file.exists();
        }
        return false;
    }

    /**
     * Forces the current script to stop running.
     */
    public static void testAbortScript() throws InterruptedException
    {
        long startTime = script_entry.getScriptStartTime();
        if (script_entry.getScriptStartTime() > 0)
        {
            long currentTime = System.currentTimeMillis();
            if (currentTime > startTime + script_entry.getScriptInterruptMs())
            {
                System.err.println("WARNING: script " + script_entry.getCurrentScriptAndMethod() + " on object " + getSelf() +
                    " is being aborted, printing stack trace:");
                Thread.dumpStack();
                throw new InterruptedException();
            }
            else if (currentTime > startTime + script_entry.getScriptWarnMs() && !script_entry.isScriptWarnPrinted())
            {
                System.err.println("WARNING: script " + script_entry.getCurrentScriptAndMethod() + " on object " + getSelf() +
                    " is running long");
                script_entry.setScriptWarnPrinted();
            }
        }
    }

    public static void logScriptDataError(String text)
    {
        System.err.println("WARNING: script " + script_entry.getCurrentScriptAndMethod() + " on object " + getSelf() + ": " + text);
        Thread.dumpStack();
    }

    public static native boolean reloadScript(String scriptName);

    /*@}*/


    /**
     * @defgroup messageMethods Messaging methods
     * @{
     */

    /** \internal internal function */
    private static native boolean _localMessageTo(long receiver, String messageName, dictionary params);
    public static boolean localMessageTo  (obj_id receiver, String messageName, dictionary params)
    {
        return _localMessageTo(getLongWithNull(receiver), messageName, params);
    }
    /** \internal internal function */
    private static native boolean _remoteMessageTo(long receiver, String messageName, byte[] params, float time, boolean guaranteed, long undeliveredCallbackObject, String undeliveredCallbackMessageName);
    public static boolean remoteMessageTo (obj_id receiver, String messageName, byte[] params, float time, boolean guaranteed, obj_id undeliveredCallbackObject, String undeliveredCallbackMessageName)
    {
        return _remoteMessageTo(getLongWithNull(receiver), messageName, params, time, guaranteed, getLongWithNull(undeliveredCallbackObject), undeliveredCallbackMessageName);
    }
    /** \internal internal function */
    private static native int _remoteMessageTo(long receiver, String messageName, byte[] params, int dayOfWeek, int hour, int minute, int second);
    /** \internal internal function */
    private static native int _remoteMessageTo(long receiver, String messageName, byte[] params, int month, int dayOfMonth, int hour, int minute, int second);
    /** \internal internal function */
    private static native void _internalRecurringMessageTo(long receiver, String messageName, byte[] params, float time);
    public static void internalRecurringMessageTo (obj_id receiver, String messageName, byte[] params, float time)
    {
        _internalRecurringMessageTo(getLongWithNull(receiver), messageName, params, time);
    }
    private static native void _cancelRecurringMessageTo(long receiver, String messageName);
    public static void cancelRecurringMessageTo (obj_id receiver, String messageName)
    {
        _cancelRecurringMessageTo(getLongWithNull(receiver), messageName);
    }

	/* checks to see if the object has a recurring messageTo of the specified name

								 *OR*

	   the object has a messageTo of the specified name *AND* that messageTo is *NOT*
	   currently being executed

	   returns the number of seconds until the messageTo fires, which *CAN* be 0
	   returns -1 if object doesn't have the messageTo
	*/
	private static native int _timeUntilMessageTo(long object, String messageName);
    public static int timeUntilMessageTo(obj_id object, String messageName)
    {
        return _timeUntilMessageTo(getLongWithNull(object), messageName);
    }

    public static boolean hasMessageTo(obj_id object, String messageName)
    {
        return (_timeUntilMessageTo(getLongWithNull(object), messageName) >= 0);
    }

    public static obj_id getSelf()
    {
        return script_entry.getOwnerContext();
    }

    /** @brief Listen for a message from a particular script on a particular object
     *
     *  When a script object invokes listenForMessage, it will receive messages from the
     *  specified object.
     *
     *  @param emitter             The object id of the object that might emit the message
     *  @param messageHandlerName  The name of the message, which must also have a corresponding function name
     *                             in the current script. (E.g. if emitter emits "foo", your script should have a
     *                             foo(dictionary params) method implemented
     *
     *  @see listenForMessage(obj_id emitter, String emitterScriptName, String messageHandlerName)
     *  @see disconnectFromMessage(obj_id emitter, String messageHandlerName)
     */
    private static native void _listenToMessage(long listener, long emitter, String messageHandlerName);
    public static void listenToMessage(obj_id emitter, String messageHandlerName)
    {
        obj_id self = getSelf();
        if(self != null && emitter != null)
        {
            _listenToMessage(getLongWithNull(self), getLongWithNull(emitter), messageHandlerName);
        }
    }

    /** @brief stop listening for a message
     *
     *  @param emitter             The id of the object that the current script is listening to for the message
     *  @param messageHandlerName  The name of the message and corresponding handler that receives the message
     *
     *  @see listenForMessage(obj_id emitter, String messageHandlerName)
     *  @see disconnectFromMessage(obj_id emitter, String emitterScriptName, String messageHandlerName)
     */
    private static native void _stopListeningToMessage(long listener, long emitter, String messageHandlerName);
    public static void stopListeningToMessage(obj_id emitter, String messageHandlerName)
    {
        obj_id self = getSelf();
        if(self != null && emitter != null)
        {
            _stopListeningToMessage(getLongWithNull(self), getLongWithNull(emitter), messageHandlerName);
        }
    }

    public static void locateObject(obj_id target, String callbackMethod, dictionary params)
    {
        if(target == null)
            return;

        if(callbackMethod == null)
            return;

        if(params == null)
            return;

        params.put("callback", callbackMethod);
        params.put("requestor", getSelf());
        messageTo(target, "OnLocateObject", params, 0.0f, false);
    }

    /** @brief emit a message
     *
     *  Whenever a script should advertise that it is exercising some capability, it can
     *  broadcast a message. Other objects can then extend the overall behavior of the system
     *  by listening for particular messages and acting on them. This means that the original
     *  script that can emit a message does not need any prior knowledge of objects and scripts
     *  that may care about the message.
     *
     *  @param messageHandlerName   The name of the message, which also corresponds to the name
     *                              of a message handler on some receiving object that may handle
     *                              this message.
     *  @param params               A dictionary of arbitrary parameters associated with this message
     *                              when it is emitted.
     *
     *  @see listenForMessage
     *  @see disconnectFromMessage
     */
    public static void broadcastMessage(String messageHandlerName, dictionary params)
    {
        obj_id self = getSelf();
        if (self == null)
            return;

        if (params == null)
            params = new dictionary();
        params.put("idSender", self);

        obj_id[] listeners = getMessageListeners(messageHandlerName);
        if (listeners != null && listeners.length > 0)
        {
            for (int i = 0; i < listeners.length; ++i)
            {
                messageTo(listeners[i], messageHandlerName, params, 0, false);
            }
        }
    }

    private static native long[] _getMessageListeners(long emitter, String messageHandlerName);
    public static obj_id[] getMessageListeners(String messageHandlerName)
    {
        obj_id self = getSelf();
        if (self == null)
            return null;

        long[] _ret_long = _getMessageListeners(getLongWithNull(self), messageHandlerName);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

    /**
     * Causes a message function on scripts attached to an object to be called after a given amount of time passes.
     *
     * @param receiver      the object that will get the message
     * @param messageName   the name of the message function that will be called
     * @param params        data that will be sent to the receiving message function
     * @param time          time (in secs) before the message function will be called. A time of <= 0 will cause the message function to be called as fast as possible.
     * @param guaranteed    flag that the message is guaranteed; if false, the object will not get the message if it is unloaded when the timer expires. NOTE: currently ignored until message persistance is implemented.
     *
     * @return true on success, false on fail.  Returns false if it is known for sure that the message will not be delivered
     */
    public static boolean messageTo(obj_id receiver, String messageName, dictionary params, float time, boolean guaranteed)
    {
        return messageTo(receiver, messageName, params, time, guaranteed, null, null);
    }

    public static boolean messageTo(obj_id receiver, String messageName, dictionary params, float time, boolean guaranteed, obj_id undeliveredCallbackObject, String undeliveredCallbackMessageName)
    {
        if ( !isIdValid(receiver) || messageName == null || messageName.length() >= 50 )
            return false;

//      System.out.println("Java messageTo enter, message = " + messageName + ", delay = " + time + ", current time = " +
//          System.currentTimeMillis());

        if (time == 0 && receiver == getSelf())
        {
            // directly call the messageHandler function
            if (params == null)
                params = new dictionary();
            try
            {

                if (script_entry.callMessageHandlers(messageName, receiver, params) == SCRIPT_CONTINUE)
                    return true;
            }
            catch ( internal_script_error err)
            {
            }
            return false;
        }
        else
        {
            if ( params != null )
            {
                return remoteMessageTo(receiver, messageName, params.pack(), time, guaranteed, undeliveredCallbackObject, undeliveredCallbackMessageName);
            }
            else
                return remoteMessageTo(receiver, messageName, null, time, guaranteed, undeliveredCallbackObject, undeliveredCallbackMessageName);
        }
    }   // messageTo()


    /**
    * "messageTo" for players on the current planet
    *
    * unlike calls based on getObjectsInRange(),
    * this call does work across game server boundary
    *
    * If you want everyone on the planet to receive the message,
    * specify null for loc and -1.0f for radius; otherwise, specify
    * a loc and a radius and only players on the planet within the
    * specified area will receive the message
    */
    private static native void _messageToPlayersOnPlanet(String messageName, byte[] params, float time, location loc, float radius, boolean includeDisconnectedPlayers);
    public static void messageToPlayersOnPlanet(String messageName, dictionary params, float time, location loc, float radius, boolean includeDisconnectedPlayers)
    {
        _messageToPlayersOnPlanet(messageName, ((params != null) ? params.pack() : null), time, loc, radius, includeDisconnectedPlayers);
    }

    /**
     * "messageTo" that goes off at a certain GMT calendar date/time
     *
     * month must be between 1-12
     * dayOfMonth must be between 1-31
     * day of week is 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
     * hour must be between 0-23
     * minute must be between 0-59
     * second must be between 0-59
     *
     * returns -1 if there is an error
     * returns the number of seconds until the specified GMT calendar date/time
     */

    // "messageTo" will go off at the next minute:second on the hour
    public static int createHourlyAlarmClock(obj_id receiver, String messageName, dictionary params, int minute, int second)
    {
        if (!isIdValid(receiver) || messageName == null || messageName.length() >= 50)
            return -1;

        if (params != null)
            return _remoteMessageTo(getLongWithNull(receiver), messageName, params.pack(), -1, -1, minute, second);
        else
            return _remoteMessageTo(getLongWithNull(receiver), messageName, null, -1, -1, minute, second);
    }

    // "messageTo" will go off at the next hour:minute:second on the day
    public static int createDailyAlarmClock(obj_id receiver, String messageName, dictionary params, int hour, int minute, int second)
    {
        if (!isIdValid(receiver) || messageName == null || messageName.length() >= 50)
            return -1;

        if (params != null)
            return _remoteMessageTo(getLongWithNull(receiver), messageName, params.pack(), -1, hour, minute, second);
        else
            return _remoteMessageTo(getLongWithNull(receiver), messageName, null, -1, hour, minute, second);
    }

    // "messageTo" will go off at the next day of week:hour:minute:second on the week
    public static final int DAY_OF_WEEK_SUN = 0;
    public static final int DAY_OF_WEEK_MON = 1;
    public static final int DAY_OF_WEEK_TUE = 2;
    public static final int DAY_OF_WEEK_WED = 3;
    public static final int DAY_OF_WEEK_THU = 4;
    public static final int DAY_OF_WEEK_FRI = 5;
    public static final int DAY_OF_WEEK_SAT = 6;

    public static int createWeeklyAlarmClock(obj_id receiver, String messageName, dictionary params, int dayOfWeek, int hour, int minute, int second)
    {
        if (!isIdValid(receiver) || messageName == null || messageName.length() >= 50)
            return -1;

        if (params != null)
            return _remoteMessageTo(getLongWithNull(receiver), messageName, params.pack(), dayOfWeek, hour, minute, second);
        else
            return _remoteMessageTo(getLongWithNull(receiver), messageName, null, dayOfWeek, hour, minute, second);
    }

    // "messageTo" will go off at the next day of month:hour:minute:second on the month
    public static int createMonthlyAlarmClock(obj_id receiver, String messageName, dictionary params, int dayOfMonth, int hour, int minute, int second)
    {
        if (!isIdValid(receiver) || messageName == null || messageName.length() >= 50)
            return -1;

        if (params != null)
            return _remoteMessageTo(getLongWithNull(receiver), messageName, params.pack(), -1, dayOfMonth, hour, minute, second);
        else
            return _remoteMessageTo(getLongWithNull(receiver), messageName, null, -1, dayOfMonth, hour, minute, second);
    }

    // "messageTo" will go off at the next month:day of month:hour:minute:second on the year
    public static int createYearlyAlarmClock(obj_id receiver, String messageName, dictionary params, int month, int dayOfMonth, int hour, int minute, int second)
    {
        if (!isIdValid(receiver) || messageName == null || messageName.length() >= 50)
            return -1;

        if (params != null)
            return _remoteMessageTo(getLongWithNull(receiver), messageName, params.pack(), month, dayOfMonth, hour, minute, second);
        else
            return _remoteMessageTo(getLongWithNull(receiver), messageName, null, month, dayOfMonth, hour, minute, second);
    }

    /**
     * returns the number of seconds until the next specified GMT calendar date/time
     *
     * month must be between 1-12
     * dayOfMonth must be between 1-31
     * day of week is 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
     * hour must be between 0-23
     * minute must be between 0-59
     * second must be between 0-59
     *
     * returns -1 if there is an error
     */

    private static native int secondsUntilCalendarTimeDayOfWeek(int dayOfWeek, int hour, int minute, int second);
    private static native int secondsUntilCalendarTimeDayOfMonth(int month, int dayOfMonth, int hour, int minute, int second);

    // returns the number of seconds until the next minute:second of the hour GMT calendar date/time
    public static int secondsUntilNextHourlyTime(int minute, int second)
    {
        return secondsUntilCalendarTimeDayOfWeek(-1, -1, minute, second);
    }

    // returns the number of seconds until the next hour:minute:second of the day GMT calendar date/time
    public static int secondsUntilNextDailyTime(int hour, int minute, int second)
    {
        return secondsUntilCalendarTimeDayOfWeek(-1, hour, minute, second);
    }

    // returns the number of seconds until the next day of week:hour:minute:second of the week GMT calendar date/time
    // see above for the pre-defined constants to use for dayOfWeek
    public static int secondsUntilNextWeeklyTime(int dayOfWeek, int hour, int minute, int second)
    {
        return secondsUntilCalendarTimeDayOfWeek(dayOfWeek, hour, minute, second);
    }

    // returns the number of seconds until the next day of month:hour:minute:second of the month GMT calendar date/time
    public static int secondsUntilNextMonthlyTime(int dayOfMonth, int hour, int minute, int second)
    {
        return secondsUntilCalendarTimeDayOfMonth(-1, dayOfMonth, hour, minute, second);
    }

    // returns the number of seconds until the next month:day of month:hour:minute:second of the year GMT calendar date/time
    public static int secondsUntilNextYearlyTime(int month, int dayOfMonth, int hour, int minute, int second)
    {
        return secondsUntilCalendarTimeDayOfMonth(month, dayOfMonth, hour, minute, second);
    }

    /**
     * Causes a message function on scripts attached to objects within a given radius to be called after a given amount of time passes.
     *
     * @param range         the radius we are interested in
     * @param messageName   the name of the message function that will be called
     * @param params        data that will be sent to the receiving message function
     * @param time          time (in secs) before the message function will be called. A time of <= 0 will cause the message function to be called as fast as possible.
     *
     * @return true if all messages sent successfully, false if any failed
     */
    public static boolean messageToRange(float range, String messageName, dictionary params, float time)
    {
        obj_id[] objects = getObjectsInRange(getSelf(), range);
        if (objects == null || objects.length <= 0)
            return true;

        boolean result = true;
        for (int i = 0; i < objects.length; ++i)
        {
            if (!messageTo(objects[i], messageName, params, time, false))
                result = false;
        }
        return result;
    }   // messageToRange

    /**
     * Send a messageTo that will automatically repeat at the specified interval.  An object can have only
     * one recurring messageTo with the same name pending for it.  If you send the same recurring messageTo
     * to an object twice, the second one will be ignored.
     * @param receiver The object which will receive the message (must be loaded, but does not have to be on this server)
     * @param messageName The message to send.
     * @param params A dictionary which will be passed to the message handler
     * @param time How often (in seconds) to deliver the message.  The time will be rounded to the nearest second.
     */
    public static void recurringMessageTo (obj_id receiver, String messageName, dictionary params, float time)
    {
        if (params != null)
            internalRecurringMessageTo (receiver, messageName, params.pack(), time);
        else
            internalRecurringMessageTo (receiver, messageName, null, time);
    }

    /**
     * @}
     * @defgroup triggerVolumeMethods Trigger volume methods
     * @{
     */

	/*
	* Players will breach trigger volumes, NPCs will not
	* NPCs are supposed to breach trigger volumes if setAttributeInterested is set on the object with the trigger volume,
	* and the corresponding setAttributeAttained() is set on the breaching NPC.
	* Refer to library/attrib.scriptlib for the attributes you can set as interested.
	*/

    /** @brief create a named trigger volume with a given radius on the requested object
     *
     *  Trigger volumes are special characteristics of objects. When they are breached by other
     *  objects, they send notification messages to anyone listening for "handleTriggerEnter"
     *  or "handleTriggerExit" on the object containing the trigger volume.
     *
     *  @param triggerVolumeName  The name of the trigger volume
     *  @param radius             The size of the trigger volume. (Sphere)
        @param isPromiscuous      Whether the trigger volume should be created in promiscuous mode
     */

    public static void createTriggerVolume(String triggerVolumeName, float radius, boolean isPromiscuous)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            _createTriggerVolume(self, triggerVolumeName, radius, isPromiscuous);
        }
    }

    private static native void __createTriggerVolume(long target, String triggerVolumeName, float radius, boolean isPromiscuous);
    private static void _createTriggerVolume(obj_id target, String triggerVolumeName, float radius, boolean isPromiscuous)
    {
        __createTriggerVolume(getLongWithNull(target), triggerVolumeName, radius, isPromiscuous);
    }


    /** @brief enumerates the contents of a trigger volume
     *
     *  This method will return an array of objects that are currently contained within a trigger
     *  volume's bounding geometry (default is a Sphere).
     *
     *  @param target             The object id of the object containing the named trigger volume
     *  @param triggerVolumeName  The name of the trigger volume to check
     *
     *  @return an array of object id's representing the objects contained within the trigger volume
     */
    private static native long[] _getTriggerVolumeContents(long target, String triggerVolumeName);
    public static obj_id[] getTriggerVolumeContents(obj_id target, String triggerVolumeName)
    {
        long[] _ret_long = _getTriggerVolumeContents(getLongWithNull(target), triggerVolumeName);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    private static native boolean _isInTriggerVolume(long owner, String triggerVolumeName, long target);
    public static boolean isInTriggerVolume(obj_id owner, String triggerVolumeName, obj_id target)
    {
        return _isInTriggerVolume(getLongWithNull(owner), triggerVolumeName, getLongWithNull(target));
    }

    /** @brief determines if an object has a trigger volume with the requested name
     *
     *  @param target             The object id of the object containing the named trigger volume
     *  @param triggerVolumeName  The name of the trigger volume to check
     *
     *  @return true if the object has a trigger volume with the requested
     *  name, otherwise false
     */
    private static native boolean _hasTriggerVolume(long target, String triggerVolumeName);
    public static boolean hasTriggerVolume(obj_id target, String triggerVolumeName)
    {
        return _hasTriggerVolume(getLongWithNull(target), triggerVolumeName);
    }

    /** @brief destroy a trigger volume contained by an object
     *
     *  An effective way to "activate" and "deactivate" a trigger volume is to simple create and
     *  destroy a trigger volume on an object keeping the radius and name the same. This
     *  method will destroy the named trigger volume characteristic of an object.
     *
     *  @param triggerVolumeName  The name of the trigger volume to destroy
     */
    public static void removeTriggerVolume(String triggerVolumeName)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            _removeTriggerVolume(self, triggerVolumeName);
        }
    }

    private static native void  __removeTriggerVolume(long target, String triggerVolumeName);
    private static void  _removeTriggerVolume(obj_id target, String triggerVolumeName)
    {
        __removeTriggerVolume(getLongWithNull(target), triggerVolumeName);
    }

    /** @brief query the range of a trigger volume on an object
     *
     *  @param target             The object id of the target containing the named trigger volume
     *  @param triggerVolumeName  The name of the trigger volume to destroy
     *
     *  @return the radius of the trigger volume, or 0 if the trigger volume name could not be found on the object.
     */
    private static native float    _getTriggerVolumeRadius(long target, String triggerVolumeName);
    public static float    getTriggerVolumeRadius(obj_id target, String triggerVolumeName)
    {
        return _getTriggerVolumeRadius(getLongWithNull(target), triggerVolumeName);
    }


    /** @brief add an object as a potential source as a trigger volume breach/exit event

        If the trigger volume is not promiscuous (not interacting with everything that touches it),
        then only objects identified as potential event sources will cause OnTriggerVolumeEntered and
        OnTriggerVolumeExited to execute.

        @param triggerVolumeName   The name of the trigger volume that responds to the specified sourceObject
        @param sourceObject        An object that will cause trigger events to execute
    */
    public static void addTriggerVolumeEventSource(String triggerVolumeName, obj_id sourceObject)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            _addTriggerVolumeEventSource(self, triggerVolumeName, sourceObject);
        }
    }

    private static native void __addTriggerVolumeEventSource(long target, String triggerVolumeName, long sourceObject);
    private static void _addTriggerVolumeEventSource(obj_id target, String triggerVolumeName, obj_id sourceObject)
    {
        __addTriggerVolumeEventSource(getLongWithNull(target), triggerVolumeName, getLongWithNull(sourceObject));
    }

    /** @brief remove an object as a potential source as a trigger volume breach/exit event

        If the trigger volume is not promiscuous (not interacting with everything that touches it),
        then only objects identified as potential event sources will cause OnTriggerVolumeEntered and
        OnTriggerVolumeExited to execute.

        @param triggerVolumeName   The name of the trigger volume that no longer responds to the specified sourceObject
        @param sourceObject        An object that will no longer cause trigger events to execute
    */
    public static void removeTriggerVolumeEventSource(String triggerVolumeName, obj_id sourceObject)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            _removeTriggerVolumeEventSource(self, triggerVolumeName, sourceObject);
        }
    }
    private static native void __removeTriggerVolumeEventSource(long target, String triggerVolumeName, long sourceObject);
    private static void _removeTriggerVolumeEventSource(obj_id target, String triggerVolumeName, obj_id sourceObject)
    {
        __removeTriggerVolumeEventSource(getLongWithNull(target), triggerVolumeName, getLongWithNull(sourceObject));
    }

    /** @brief place a trigger volume in promiscuous mode

        When a trigger volume is in promiscuous mode, it will process enter/exit trigger events for
        any object. When it is not promiscuous, only objects identified as event sources (@see addTriggerVolumeEventSource)
        will cause trigger enter/exit events to execute.

        @param triggerVolumeName  The trigger who's promiscuous mode is being set
        @param isPromiscuous      Whether or not the trigger volume is in promiscuous mode
    */
    public static void setTriggerVolumePromiscuous(String triggerVolumeName, boolean isPromiscuous)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            _setTriggerVolumePromiscuous(self, triggerVolumeName, isPromiscuous);
        }
    }
    private static native void __setTriggerVolumePromiscuous(long target, String triggerVolumeName, boolean isPromiscuous);
    private static void _setTriggerVolumePromiscuous(obj_id target, String triggerVolumeName, boolean isPromiscuous)
    {
        __setTriggerVolumePromiscuous(getLongWithNull(target), triggerVolumeName, isPromiscuous);
    }


    /** @brief determines if a trigger volume is in promiscuous mode

        @param target              The object that has the trigger volume to chage
        @param triggerVolumeName  The name of the trigger volume to check for promiscuity

        @return true if the trigger volume is promiscuous. false if it is not or was not found.
    */
    private static native boolean _isTriggerVolumePromiscuous(long target, String triggerVolumeName);
    public static boolean isTriggerVolumePromiscuous(obj_id target, String triggerVolumeName)
    {
        return _isTriggerVolumePromiscuous(getLongWithNull(target), triggerVolumeName);
    }

    /**
     * Expel an object from a trigger volume.
     *
     * @param  self              the object owning the trigger volume
     * @param  triggerVolumeName the name of the trigger volume to expel from
     * @param  target            the object to expel
     * @return whether successful
     */
    private static native boolean _expelFromTriggerVolume(long self, String triggerVolumeName, long target);
    public static boolean expelFromTriggerVolume(obj_id self, String triggerVolumeName, obj_id target)
    {
        return _expelFromTriggerVolume(getLongWithNull(self), triggerVolumeName, getLongWithNull(target));
    }
    /**
     * Confine an object to a trigger volume - this should be used to prevent leaving a trigger volume.
     *
     * @param  self              the object owning the trigger volume
     * @param  triggerVolumeName the name of the trigger volume to confine from
     * @param  target            the object to confine
     * @return whether successful
     */
    private static native boolean _confineToTriggerVolume(long self, String triggerVolumeName, long target);
    public static boolean confineToTriggerVolume(obj_id self, String triggerVolumeName, obj_id target)
    {
        return _confineToTriggerVolume(getLongWithNull(self), triggerVolumeName, getLongWithNull(target));
    }

    public int dispatchTriggerVolumeEvents(obj_id self, boolean[] isEnter, String[] names, obj_id[] sources, obj_id[] targets) throws internal_script_error
    {

        PROFILER_START("dispatchTriggerVolumeEvents");

        int count = isEnter.length;
        if (count > 0)
        {
            Object [] params = new Object[3];
            for (int iter = 0; iter < count; iter++)
            {
                params[0] = targets[iter];
                params[1] = names[iter];
                params[2] = sources[iter];
                if (isEnter[iter])
                    script_entry.runScripts("OnTriggerVolumeEntered", params);
                else
                    script_entry.runScripts("OnTriggerVolumeExited", params);
            }
        }

        PROFILER_STOP("dispatchTriggerVolumeEvents");

        return 0;
    }


    private static String galaxyName = "toodles";

    public int setGalaxyName(obj_id self, String newName)
    {
        galaxyName = newName;
        return 0;
    }

    private static native int __getModValue(long target, String modName);
    private static int _getModValue(obj_id target, String modName)
    {
        return __getModValue(getLongWithNull(target), modName);
    }
    public static int getModValue(String modName)
    {
        int result = 0;
        obj_id self = getSelf();
        if(self != null)
        {
            result = _getModValue(self, modName);
        }
        return result;
    }

    private static native void __setModValue(long target, String modName, int value);
    private static void _setModValue(obj_id target, String modName, int value)
    {
        __setModValue(getLongWithNull(target), modName, value);
    }
    public static void setModValue(String modName, int value)
    {
        obj_id self = getSelf();
        _setModValue(self, modName, value);
    }


    /**
     * @}
     * @defgroup timeMethods Time and Clock methods
     * @{
     */

    /****************************************************************
     *  Server Clock
     ****************************************************************/
    /** @brief get the current (local) server frame

        The server tries to run at 0.25 seconds per frame, but
        it may take slightly more or less time. Do NOT use
        getServerFrame for time-based callbacks!

        \code
        int serverFrame = getServerFrame();
        makeMyCallback(someObject, serverFrame + 3); // callback in 3 frames
        \endcode

        @return The current server frame
        @author Justin Randall
    */
    public static native int getServerFrame();
    /** @brief get the current (local) server time in seconds

        The server tries to run at 0.25 seconds per frame, but
        it may take slightly more or less time. Do NOT use
        getServerTime for time-based callbacks!

        @return The current server time
    */

    public static native int getGameTime();

    // returns the calendar time in seconds (i.e. the Epoch)
    public static native int getCalendarTime();

    // returns the calendar time in seconds (i.e. the Epoch) corresponding to the specified
    // year (1975 - 2035), month (1 - 12), day (1 - 31), hour (0 - 23), minute (0 - 59), second (0 - 59)
    // interpreted in the local time zone (i.e. the time zone that the computer is set to)
    //
    // returns a negative number if the specified values do not correspond to a valid date/time
    public static native int getCalendarTime(int year, int month, int day, int hour, int minute, int second);

    // converts a calendar time value in seconds (i.e. the Epoch) to a display calendar string in the GMT time zone
    public static native String getCalendarTimeStringGMT(int calendarTime);
    public static native String getCalendarTimeStringGMT_YYYYMMDDHHMMSS(int calendarTime);

    // converts a calendar time value in seconds (i.e. the Epoch) to a display calendar string in the local time zone
    public static native String getCalendarTimeStringLocal(int calendarTime);
    public static native String getCalendarTimeStringLocal_YYYYMMDDHHMMSS(int calendarTime);

    /****************************************************************
     *  Chat API
     ****************************************************************/
    /** @}
        @defgroup chatSystemMethods Chat System API
        @{
    */

    /** @brief Create a chat room. Room names are dot-formatted.

        Create a chat room. Rooms are organized in a hierarchy.
        E.g. "swg.TestCenter.Tatooine" would be the name for a planet-wide
        room on the TestCenter galaxy in the swg game.

        Example:
        \code
        trigger OnCreateGroup(String groupName, obj_id leader, obj_id[] players)
        {
            String[] moderators = new String[1];
            moderators[0] = getName(leader);

            chatCreateRoom(false, "swg." + getGalaxyName() + ".groups." + groupName, moderators);

            return SCRIPT_CONTINUE;
        }
        \endcode

        @see chatDestroyRoom
    */
    public static void chatCreateRoom(boolean isPublic, String roomName, String roomTitle)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            _chatCreateRoom(getName(self), isPublic, roomName, roomTitle);
        }
    }
    private static native void _chatCreateRoom(String ownerName, boolean isPublic, String roomName, String roomTitle);

    /** @brief Destroy a chat room.

        Destroy a chat room by name. See chatCreateRoom for a description
        how rooms are named.

        example:

        \code

        trigger OnDestroyGroup(String groupName, obj_id leader, obj_id players)
        {
            chatDestroyRoom("swg." + getGalaxyName() + ".groups." + groupName);
            return SCRIPT_CONTINUE;
        }
        \endcode

        @see chatCreateRoom
    */
    public static native void chatDestroyRoom(String roomName);

    /** @brief Send a message from self to a chat room.

        Sends a message to a chat room, with optional information embedded in the
        out-of-band data.

        Note: StringId's are packed into the OOB data for display on SWG game
        clients. This does not send plain text, because other non-swg clients
        may be participating in a channel.

    */
    public static void chatSendToRoom(String roomName, String localizedMessageText, String outOfBand)
    {
        obj_id self = getSelf();
        //String avatarName = getName(self);
        _chatSendToRoom("SYSTEM", roomName, localizedMessageText, outOfBand);
    }
    private static native void _chatSendToRoom(String from, String roomName, String localizedMessageText, String outOfBand);

    /** @brief enter self into a named chat room

        example:

        \code
        trigger OnAddedToGroup(String groupName)
        {
            chatEnterRoom("swg." + getGalaxyName() + ".groups." + groupName);
            return SCRIPT_CONTINUE;
        }
        \endcode
    */
    public static void chatEnterRoom(String roomName)
    {
        obj_id self = getSelf();
        String avatarName = getName(self);
        _chatEnterRoom(avatarName, roomName);
    }
    private static native void _chatEnterRoom(String who, String roomName);

    /** @brief self exits a chat room

        example:

        \code
        trigger OnGroupDisbanded(String groupName)
        {
            chatExitRoom("swg." + getGalaxyName() + ".groups." + groupName);
            return SCRIPT_CONTINUE;
        }
        \endcode
    */
    public static void chatExitRoom(String roomName)
    {
        obj_id self = getSelf();
        String avatarName = getName(self);
        _chatExitRoom(avatarName, roomName);
    }
    private static native void _chatExitRoom(String who, String roomName);

    /**
    */
    public static native void chatAddModeratorToRoom(String roomName, String moderatorName);
    public static native void chatRemoveModeratorFromRoom(String roomName, String moderatorName);
    public static void chatSendInstantMessage(String to, String localizedMessageText, String outOfBand)
    {
        obj_id self = getSelf();
        String avatarName = getName (self);
        _chatSendInstantMessage(avatarName, to, localizedMessageText, outOfBand);
    }
    private static native void _chatSendInstantMessage(String from, String to, String localizedMessageText, String outOfBand);

    public static void chatSendPersistentMessage(obj_id to, string_id subject, String localizedMessageText, String outOfBand)
    {
        chatSendPersistentMessage(to, "@" + subject.toString(), localizedMessageText, outOfBand);
    }

    public static void chatSendPersistentMessage(obj_id to, String subject, String localizedMessageText, String outOfBand)
    {
        obj_id self = getSelf();
        if (!isIdValid(self))
            return;

        chatSendPersistentMessage(getChatName(self), to, subject, localizedMessageText, outOfBand);
    }

    public static void chatSendPersistentMessage(String from, obj_id to, String subject, String localizedMessageText, String outOfBand)
    {
        if ( from == null || from.length() == 0 )
        {
            obj_id self = getSelf();
            if (!isIdValid(self))
            return;
            from = getChatName(self);
        }

        String recipient = getChatName(to);
        if (recipient != null)
        {
            _chatSendPersistentMessage(from, recipient, localizedMessageText, outOfBand, subject);
        }
        else
        {
            dictionary dict = new dictionary();
            dict.put("from",      from);
            dict.put("subject",   subject);
            dict.put("message",   localizedMessageText);
            if (outOfBand != null)
                dict.put("outofband", outOfBand);
            messageTo(to, "handleChatPersistentMessage", dict, 0, true);
        }
    }

    public static void chatSendPersistentMessage(String from, String to, String subject, String localizedMessageText, String outOfBand)
    {
        _chatSendPersistentMessage(from, to, localizedMessageText, outOfBand, subject);
    }

    public static String chatMakePersistentMessageOutOfBandBody (String target, string_id bodyId)
    {
        prose_package pp = new prose_package ();
        pp.stringId      = bodyId;
        return chatMakePersistentMessageOutOfBandBody (target, pp);
    }

    public static String chatMakePersistentMessageOutOfBandBody (String target, prose_package bodyProse)
    {
        if (bodyProse != null)
            return packOutOfBandProsePackage (target, -1, bodyProse);

        return null;
    }

    /**
    * Pack a waypoint if the obj_id is a waypoint.
    * If the obj_id is not a waypoint, pack a waypoint for the location of the object
    * @param waypoint the object or waypoint to pack as a waypoint
    * @param target the oob buffer to pack into, may be null
    */

    public static String chatAppendPersistentMessageWaypoint (String target, obj_id waypoint)
    {
        return _packOutOfBandWaypoint (waypoint, target, -3);
    }

    /**
    * Pack enough information to reconstruct a waypoint later
    * @param target the oob buffer to pack into, may be null
    * @param planet the canonical name of the planet.  may be null to use the current planet
    * @param nameId the string_id to use as the display name for the waypoint
    * @param name   the string to use as the display name.  Overrides nameId.  Either nameId or name must be non-null.
    */

    public static String chatAppendPersistentMessageWaypointData (String target, String planet, float x, float z, string_id nameId, String name)
    {
        return _packOutOfBandWaypointData (target, -3, planet, x, z, nameId, name);
    }

    private static native void _chatSendPersistentMessage(String from, String to, String localizedMessageText, String outOfBand, String subject);

    public static String getGalaxyName ()
    {
        return galaxyName;
    }

    public static String getGameChatCode ()
    {
        return "SWG";
    }

    //--------------------------------------------------------------
    //--------------------------------------------------------------

    private static native void _sendQuestSystemMessage(long to, String localizedMessageText, String oob);
    public static void sendQuestSystemMessage(obj_id to, String localizedMessageText, String oob)
    {
        _sendQuestSystemMessage(getLongWithNull(to), localizedMessageText, oob);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendQuestSystemMessage(obj_id to, prose_package pp)
    {
        String oob = packOutOfBandProsePackage(null, pp);
        sendQuestSystemMessage(to, null, oob);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendQuestSystemMessage(obj_id to, string_id messageId)
    {
        prose_package pp = new prose_package();
        pp.stringId = messageId;
        sendQuestSystemMessage(to, pp);
    }

    /**
    * Send a system message to an individual
    */
    public static native void sendSystemMessage (String to, String localizedMessageText, String oob);
    private static native void _sendSystemMessage(long to, String localizedMessageText, String oob);
    public static void sendSystemMessage (obj_id to, String localizedMessageText, String oob)
    {
        _sendSystemMessage(getLongWithNull(to), localizedMessageText, oob);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessageTestingOnly (String to, String localizedMessageText)
    {
        sendSystemMessage (to, localizedMessageText, null);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessageOob (String to, String oob)
    {
        sendSystemMessage (to, null, oob);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessageProse (String to, prose_package pp)
    {
        String oob = packOutOfBandProsePackage (null, pp);
        sendSystemMessage (to, null, oob);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessage (String to, string_id messageId)
    {
        prose_package pp = new prose_package ();
        pp.stringId = messageId;
        sendSystemMessageProse  (to, pp);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessageTestingOnly (obj_id to, String localizedMessageText)
    {
        //sendSystemMessageTestingOnly (getChatName (to), localizedMessageText);
        sendSystemMessage(to, localizedMessageText, null);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessageOob (obj_id to, String oob)
    {
        sendSystemMessage (to, null, oob);
        //sendSystemMessageOob (getChatName (to), oob);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessageProse (obj_id to, prose_package pp)
    {
        String oob = packOutOfBandProsePackage (null, pp);
        sendSystemMessage (to, null, oob);
        //sendSystemMessageProse (getChatName (to), pp);
    }

    /**
    * Send a system message to an individual
    */
    public static void sendSystemMessage (obj_id to, string_id messageId)
    {
        //sendSystemMessage (getChatName (to), messageId);
        prose_package pp = new prose_package ();
        pp.stringId = messageId;
        sendSystemMessageProse  (to, pp);
    }

    //--------------------------------------------------------------
    //--------------------------------------------------------------

    /**
    * Send a system message to factional individuals on the planet
    * If you want everyone on the planet to receive the message,
    * specify null for loc and -1.0f for radius; otherwise, specify
    * a loc and a radius and only players on the planet within the
    * specified area will receive the message
    */
    private static native void sendFactionalSystemMessagePlanet(String prosePackage, location loc, float radius, boolean notifyImperial, boolean notifyRebel);

    public static void sendFactionalSystemMessagePlanet(prose_package pp, location loc, float radius, boolean notifyImperial, boolean notifyRebel)
    {
        String oob = packOutOfBandProsePackage(null, pp);
        sendFactionalSystemMessagePlanet(oob, loc, radius, notifyImperial, notifyRebel);
    }

    public static void sendFactionalSystemMessagePlanet(string_id messageId, location loc, float radius, boolean notifyImperial, boolean notifyRebel)
    {
        prose_package pp = new prose_package();
        pp.stringId = messageId;
        sendFactionalSystemMessagePlanet(pp, loc, radius, notifyImperial, notifyRebel);
    }

    //--------------------------------------------------------------
    //--------------------------------------------------------------

    /**
    * Send a system message to a planet
    */
    public static void sendSystemMessagePlanetTestingOnly (String localizedMessageText)
    {
        String room = getGameChatCode () + "." + getGalaxyName () + "." + getCurrentSceneName () + ".system";
        chatSendToRoom (room, localizedMessageText, null);
    }

    /**
    * Send a system message to a planet
    */
    public static void sendSystemMessagePlanetOob (String oob)
    {
        String room = getGameChatCode () + "." + getGalaxyName () + "." + getCurrentSceneName () + ".system";
        chatSendToRoom (room, null, oob);
    }

    /**
    * Send a system message to a planet
    */
    public static void sendSystemMessagePlanet (string_id messageId)
    {
        prose_package pp = new prose_package ();
        pp.stringId = messageId;
        sendSystemMessagePlanetProse (pp);
    }

    /**
    * Send a system message to a planet
    */
    public static void sendSystemMessagePlanetProse (prose_package pp)
    {
        String oob = packOutOfBandProsePackage (null, pp);
        sendSystemMessagePlanetOob (oob);
    }

    //--------------------------------------------------------------
    //--------------------------------------------------------------

    /**
    * Send a system message to a planet
    */
    public static void sendSystemMessageGalaxyTestingOnly (String localizedMessageText)
    {
        String room = getGameChatCode () + "." + getGalaxyName () + ".system";
        chatSendToRoom (room, localizedMessageText, null);
    }

    /**
    * Send a system message to a galaxy
    */
    public static void sendSystemMessageGalaxyOob (String oob)
    {
        String room = getGameChatCode () + "." + getGalaxyName () + ".system";
        chatSendToRoom (room, null, oob);
    }

    /**
    * Send a system message to a galaxy
    */
    public static void sendSystemMessageGalaxy (string_id messageId)
    {
        prose_package pp = new prose_package ();
        pp.stringId = messageId;
        sendSystemMessageGalaxyProse (pp);
    }

    /**
    * Send a system message to a galaxy
    */
    public static void sendSystemMessageGalaxyProse (prose_package pp)
    {
        String oob = packOutOfBandProsePackage (null, pp);
        sendSystemMessageGalaxyOob (oob);
    }

    //--------------------------------------------------------------
    //--------------------------------------------------------------

    /**
     * Send combat spam to players.
     */
    private static native void _sendCombatSpam(long attacker, long defender, long weapon, combat_engine.hit_result result, string_id attackName, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType);
    public static void sendCombatSpam(obj_id attacker, obj_id defender, obj_id weapon, combat_engine.hit_result result, string_id attackName, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType)
    {
        _sendCombatSpam(getLongWithNull(attacker), getLongWithNull(defender), getLongWithNull(weapon), result, attackName, sendToAttacker, sendToDefender, sendToBystanders, spamType);
    }

    /**
     * Send combat spam to players. Use a string id for the weapon instead of an object.
     */
    private static native void _sendCombatSpam(long attacker, long defender, string_id weapon, combat_engine.hit_result result, string_id attackName, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType);
    public static void sendCombatSpam(obj_id attacker, obj_id defender, string_id weapon, combat_engine.hit_result result, string_id attackName, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType)
    {
        _sendCombatSpam(getLongWithNull(attacker), getLongWithNull(defender), weapon, result, attackName, sendToAttacker, sendToDefender, sendToBystanders, spamType);
    }

    /**
     * Send a string id to a player in the combat spam window.
     */
    public static void sendCombatSpamMessage(obj_id player, string_id message, int spamType)
    {
        sendCombatSpamMessage(player, null, message, true, false, false, spamType);
    }

    /**
     * Send a string id to a player in the combat spam window.
     */
    private static native void _sendCombatSpamMessage(long attacker, long defender, string_id message, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType);
    public static void sendCombatSpamMessage(obj_id attacker, obj_id defender, string_id message, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType)
    {
        _sendCombatSpamMessage(getLongWithNull(attacker), getLongWithNull(defender), message, sendToAttacker, sendToDefender, sendToBystanders, spamType);
    }

    /**
     * Send a string id to a player in the combat spam window.
     */
    private static native void _sendCombatSpamMessageCGP(long attacker, long defender, string_id message, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, boolean critical, boolean glancing, boolean proc, int spamType);
    public static void sendCombatSpamMessageCGP(obj_id attacker, obj_id defender, string_id message, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, boolean critical, boolean glancing, boolean proc, int spamType)
    {
        _sendCombatSpamMessageCGP(getLongWithNull(attacker), getLongWithNull(defender), message, sendToAttacker, sendToDefender, sendToBystanders, critical, glancing, proc, spamType);
    }

    /**
     * Send a prose package to a player in the combat spam window.
     */
    public static void sendCombatSpamMessageProse(obj_id player, prose_package pp, int spamType)
    {
        String oob = packOutOfBandProsePackage(null, pp);
        sendCombatSpamMessageOob(player, null, oob, true, false, false, spamType);
    }

    /**
     * Send a prose package to a player in the combat spam window.
     */
    public static void sendCombatSpamMessageProse(obj_id attacker, obj_id defender, prose_package pp, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType)
    {
        //@todo: send to other players
        String oob = packOutOfBandProsePackage(null, pp);
        sendCombatSpamMessageOob(attacker, defender, oob, sendToAttacker, sendToDefender, sendToBystanders, spamType);
    }

    /**
     * Send a oob message to a player in the combat spam window.
     */
    private static native void _sendCombatSpamMessageOob(long player, long defender, String oob, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType);
    public static void sendCombatSpamMessageOob(obj_id player, obj_id defender, String oob, boolean sendToAttacker, boolean sendToDefender, boolean sendToBystanders, int spamType)
    {
        _sendCombatSpamMessageOob(getLongWithNull(player), getLongWithNull(defender), oob, sendToAttacker, sendToDefender, sendToBystanders, spamType);
    }

    //--------------------------------------------------------------
    //--------------------------------------------------------------

    private static native String __packOutOfBandToken(long token, String outOfBand, int position);
    public static String _packOutOfBandToken        (obj_id token, String outOfBand, int position)
    {
        return __packOutOfBandToken(getLongWithNull(token), outOfBand, position);
    }

    /**
    * Pack a waypoint if the obj_id is a waypoint.
    * If the obj_id is not a waypoint, pack a waypoint for the location of the object
    * @param waypoint the object or waypoint to pack as a waypoint
    * @param outOfBand the oob buffer to pack into, may be null
    * @param position
    */

    private static native String __packOutOfBandWaypoint(long waypoint, String outOfBand, int position);
    public static String _packOutOfBandWaypoint     (obj_id waypoint, String outOfBand, int position)
    {
        return __packOutOfBandWaypoint(getLongWithNull(waypoint), outOfBand, position);
    }

    /**
    * Pack enough information to reconstruct a waypoint later
    * @param outOfBand the oob buffer to pack into, may be null
    * @param position
    * @param planet the canonical name of the planet.  may be null to use the current planet
    * @param nameId the string_id to use as the display name for the waypoint
    * @param name   the string to use as the display name.  Overrides nameId.  Either nameId or name must be non-null.
    */

    public static native String _packOutOfBandWaypointData (String outOfBand, int position, String planet, float x, float z, string_id nameId, String name);

    private static native String __packOutOfBandProsePackage(String target, int position, string_id stringId, long objActor, long objTarget, long objOther, string_id nameIdActor, string_id nameIdTarget, string_id nameIdOther, String nameActor, String nameTarget, String nameOther, int digitInteger, float digitFloat, boolean complexGrammar);
    public static String _packOutOfBandProsePackage(String target, int position, string_id stringId, obj_id objActor, obj_id objTarget, obj_id objOther, string_id nameIdActor, string_id nameIdTarget, string_id nameIdOther, String nameActor, String nameTarget, String nameOther, int digitInteger, float digitFloat, boolean complexGrammar)
    {
        return __packOutOfBandProsePackage(target, position, stringId, getLongWithNull(objActor), getLongWithNull(objTarget), getLongWithNull(objOther), nameIdActor, nameIdTarget, nameIdOther, nameActor, nameTarget, nameOther, digitInteger, digitFloat, complexGrammar);
    }


    public static String packOutOfBandProsePackage(String target, prose_package pp)
    {
        return packOutOfBandProsePackage(target, -1, pp);
    }

    public static String packOutOfBandProsePackage(String target, int position, prose_package pp)
    {
        return _packOutOfBandProsePackage (target,
                                            position,
                                            pp.stringId,
                                            pp.actor.id,
                                            pp.target.id,
                                            pp.other.id,
                                            pp.actor.nameId,
                                            pp.target.nameId,
                                            pp.other.nameId,
                                            pp.actor.name,
                                            pp.target.name,
                                            pp.other.name,
                                            pp.digitInteger,
                                            pp.digitFloat,
                                            pp.complexGrammar);
    }

    /**
     * Gets an emote name from its crc value.
     * @param crc the emote crc
     * @return the emote name, or null on error
     */
    public static native String getEmoteFromCrc(int crc);


    //--------------------------------------------------------------
    //--------------------------------------------------------------

    /**
     * Prints a message to the console of the player with given id.
     * @param object the object(controller) to print to
     * @param msg    the message to print
     */
    private static native void _sendConsoleMessage(long object, String msg);
    public static void sendConsoleMessage(obj_id object, String msg)
    {
        _sendConsoleMessage(getLongWithNull(object), msg);
    }

    //--------------------------------------------------------------
    //--------------------------------------------------------------

    /**
     * @}
     * @defgroup serverSystemMethods Base server system methods
     * @{
     */

    //--------------------------------------------------------------

    public static native String getGameObjectTypeName (int type);


    /**
     * Returns the GOT type integer, or 0 if the name is not found
     */
    public static native int getGameObjectTypeFromName (String gameObjectTypeName);

    //--------------------------------------------------------------

    public static string_id getGameObjectTypeStringId (int type)
    {
        return new string_id ("got_n", getGameObjectTypeName (type));
    }

    //--------------------------------------------------------------

    private static native int _getGameObjectType(long obj);
    public static int getGameObjectType (obj_id obj)
    {
        return _getGameObjectType(getLongWithNull(obj));
    }

    public static native int getGameObjectTypeFromTemplate(String templateName);
    public static native int getGameObjectTypeFromTemplate(int templateCrc);

    /**
    * Test game object type
    */

    public static boolean isGameObjectTypeOf (obj_id obj, int typeToTestAgainst)
    {
        final int type = getGameObjectType (obj);
        return isGameObjectTypeOf (type, typeToTestAgainst);
    }

    /****************************************************************
     *  Server System Support
     ****************************************************************/
    private static native boolean _sendConsoleCommand(String command, long target);
    public static boolean sendConsoleCommand(String command, obj_id target)
    {
        return _sendConsoleCommand(command, getLongWithNull(target));
    }

    /**
     * Returns the value of a config file key.
     * @param section       the config file section
     * @param key           the config file key
     * @return the key value, or null if the key doesn't exist
     */
    public static native String getConfigSetting(String section, String key);

    /**
     * @}
     * @defgroup creatureMovementMonitoring Methods for monitoring creature movement
     * @{
     */

    /****************************************************************
     *  Movement Monitoring Support
     ****************************************************************/
    /**
     * Begin monitoring creature movement.  An OnMonitoredCreatureMoved
     * trigger will be called when the creatures moves more than percentageMovement
     * of their distance from you.  So if percentageMovement is 0.10f and the
     * creature is 90m away, you will receive a notification when the creature moves
     * 9m, but if the creature is 20m away, you will receive a notification every
     * 2m.
     *
     * If the creature is destroyed or unloaded, it will silently become
     * unmonitored.  When you are done monitoring a creature, call ignoreCreatureMovement
     * for the creature.
     * @param creature The creature which receives the notification
     * @param target The creature to monitor
     * @param skittishness The magnitude of the creature's response to other creatures. A value of
     *                     1 will cause the creature's fear to increase to 100 when approached at
     *                     a speed of 1.  Any positive value is allowed.
     * @param curve        The acceleration for the creatures fear increment.  0 indicates a linear
     *                     increase, 1 is a curve where creatures get more nervous up close and
     *                     rocket through the more alert states, and -1 is a curve where the creature
     *                     initially alerts early and stays wary for a while.  Other positive and
     *                     negative values are allowed.
     * @return success code
     */
    private static native boolean _monitorCreatureMovement(long creature, long target, float skittishness, float curve);
    public static boolean monitorCreatureMovement(obj_id creature, obj_id target, float skittishness, float curve)
    {
        return _monitorCreatureMovement(getLongWithNull(creature), getLongWithNull(target), skittishness, curve);
    }
    /**
     * Stop monitoring a creature's movement.
     * @see monitorCreatureMovement
     *
     * @param creature The monitoring creature.
     * @param target The creature to begin ignoring.
     * @return success code
     */
    private static native boolean _ignoreCreatureMovement(long creature, long target);
    public static boolean ignoreCreatureMovement(obj_id creature, obj_id target)
    {
        return _ignoreCreatureMovement(getLongWithNull(creature), getLongWithNull(target));
    }
    /**
     * Calculate the approach speed for a creature.
     *
     * @param mob Yourself
     * @param mobDelta Last movement delta
     * @param target The Target
     * @param targetDelta Target movement delta
     * @param time The time of the movement
     *
     * @return the approach speed in x, the radial speed in y, and the distance in z.
     */
    private static native location _getApproachSpeed(long mob, location mobDelta, long target, location targetDelta, float time);
    public static location getApproachSpeed(obj_id mob, location mobDelta, obj_id target, location targetDelta, float time)
    {
        return _getApproachSpeed(getLongWithNull(mob), mobDelta, getLongWithNull(target), targetDelta, time);
    }
    /**
     * Get the bearing of a creature.
     *
     * @param mob yourself
     * @param target The creature to query the bearing for
     * @result The bearing of the creature in degrees (positive = right, range = -180 to 180)
     */
    private static native float _getTargetBearing(long mob, long target);
    public static float getTargetBearing(obj_id mob, obj_id target)
    {
        return _getTargetBearing(getLongWithNull(mob), getLongWithNull(target));
    }
    /**
     * Quantize a bearing into an octant
     *
     * @param bearing The angle in degrees where 0=straight ahead
     *
    public static int quantizeBearing(float bearing)
    {
        if (bearing < -157.5f)
            return BEARING_B;
        else if (bearing > 157.5f)
            return BEARING_B;
        else if (bearing < -112.5f)
            return BEARING_BL;
        else if (bearing > 112.5f)
            return BEARING_BR;
        else if (bearing < -67.5f)
            return BEARING_L;
        else if (bearing > 67.5f)
            return BEARING_R;
        else if (bearing < -22.5f)
            return BEARING_FL;
        else if (bearing > 22.5f)
            return BEARING_FR;
        else
            return BEARING_F;
    }


    /**
     * @}
     * @defgroup skillMethods Skill system methods
     * @{
     */

    /****************************************************************
     *  SKILL SYSTEM SUPPORT
     ****************************************************************/

    /** @brief retrieve the number of experience points of the requested type
         from a creature

        Experience is arbitrarily categorized. New types are specified
        at the time they are granted. Experience categorization is extended
        in script merely by granted a new named type to a creature.

        If the experience type has not been granted to the target, then
        the return value will be zero.
        \code
        int xpAmount = getEexperiencePoints(player, "Trap Detection");
        if(xpAmount > minimumNeededToDetectTrap)
            return TRAP_DETECTED;
        else
            return TRAP_SET;
        \endcode

        @param target   The creature upon which this command is operating
        @param experienceType  The type of experience to query for

        @return an integer describing the number of experience points of the
         requested type that the creature has
        @author Justin Randall <jrandall@soe.sony.com>
     */
     private static native int _getExperiencePoints(long target, String experienceType);
     public static int getExperiencePoints(obj_id target, String experienceType)
     {
        return _getExperiencePoints(getLongWithNull(target), experienceType);
     }
     private static native dictionary _getExperiencePoints(long target);
     public static dictionary getExperiencePoints(obj_id target)
     {
        return _getExperiencePoints(getLongWithNull(target));
     }

     private static native int _getExperienceCap(long target, String experienceType);
     public static int getExperienceCap(obj_id target, String experienceType)
     {
        return _getExperienceCap(getLongWithNull(target), experienceType);
     }

    /** @brief Get the list of commands that the specified skill provides

        When a skill is granted to a creature, it may grant commands for the
        creature to execute, such as a sweep-kicks in an advanced melee combat skill.

        @param skillName   The skill to query for the command list

        @return An array of strings describing the list of commands provided.
        @author Justin Randall <jrandall@soe.sony.com>
    */
    public static native String[] getSkillCommandsProvided(String skillName);

    /** @brief Get an array of skill names that indicate the skills that a player
        already has.

        @param player  The obj_id of the player from which the skills are retrieved.

        @return an array of strings indicating the skills a player has or NULL of the player
        has no skills.
     */
     private static native String[] _getSkillListingForPlayer(long player);
     public static String[] getSkillListingForPlayer(obj_id player)
     {
        return _getSkillListingForPlayer(getLongWithNull(player));
     }

    /** @brief Get a dictionary that lists the type and amount of experience a creature
        must have before the requested skill may be granted.

        @param skillName   The name of the skill to query for the prerequisite experience

        @return A dictionary of String/Integers describing the experience prerequisites for the
        requested skill.
        @author Justin Randall <jrandall@soe.sony.com>
    */
    public static native dictionary getSkillPrerequisiteExperience(String skillName);

    /** @brief Get a list of prerequisite skills required before the requested skill may
        be granted to the creature.

        @param skillName   The skill to query for the prerequisite skill listing

        @return An array of strings enumerating the skill prerequisites that must be met before
        the requested skill may be granted to a creature.
        @author Justin Randall <jrandall@soe.sony.com>
    */
    public static native String[] getSkillPrerequisiteSkills(String skillName);

    /** @brief Get a dictionary describing the species prerequisites that must be satisfied
        before this skill may be granted to a creature.

        @param skillName   The name of the skill to query for creature prerequisites

        @return A dictionary of Strings/Booleans. Todo: there is also a NOT/AND requirement to implement!
        @author Justin Randall <jrandall@soe.sony.com>
    */
    public static native dictionary getSkillPrerequisiteSpecies(String skillName);

    /** @brief Get the name of the pimary profession that the requested skill belongs to

        @param skillName   The name of the skill to query for the profession

        @return A string naming the profession that the requested skill belongs to
        @author Justin Randall <jrandall@soe.sony.com>
    */
    public static native String getSkillProfession(String skillName);

    /** @brief Get a dictionary describing the statistic modifiers that will be applied
        when this skill is granted.

        @param skillName  The name of the skill to query for stat mods

        @return A dictionary of Strings/Integers describing the stats and how they will be
        modified when the skill is applied to a creature.
        @author Justin Randall <jrandall@soe.sony.com>
    */
    public static native dictionary getSkillStatisticModifiers(String skillName);

    /** Returns the skill stat modifier value on a creature for a given skill stat modifier name.
     *
     * @param creature          the creature whose stat mod we want
     * @param skillStatName     the name of the skill stat mod we want
     *
     * @return the skill stat mod value
     */
    private static native int _getSkillStatisticModifier(long creature, String skillStatName);
    public static int getSkillStatisticModifier(obj_id creature, String skillStatName)
    {
        return _getSkillStatisticModifier(getLongWithNull(creature), skillStatName);
    }

    /** Returns an array of skill stat modifier values on a creature for a list of given skill stat modifier names.
     *
     * @param creature          the creature whose stat mod we want
     * @param skillStatNames    array of names of the skill stat mods we want
     *
     * @return the skill stat mod values, or null on error
     */
    private static native int[] _getSkillStatisticModifiers(long creature, String[] skillStatNames);
    public static int[] getSkillStatisticModifiers(obj_id creature, String[] skillStatNames)
    {
        return _getSkillStatisticModifiers(getLongWithNull(creature), skillStatNames);
    }

    /** Returns the skill stat modifier value, enhanced by equipment, on a creature for a given skill stat
     * modifier name.
     *
     * @param creature          the creature whose stat mod we want
     * @param skillStatName     the name of the skill stat mod we want
     *
     * @return the skill stat mod value
     */
    private static native int _getEnhancedSkillStatisticModifier(long creature, String skillStatName);
    public static int getEnhancedSkillStatisticModifier(obj_id creature, String skillStatName)
    {
        return _getEnhancedSkillStatisticModifier(getLongWithNull(creature), skillStatName);
    }

    /** Returns an array of skill stat modifier values, enhanced by equipment, on a creature for a list of
     * given skill stat modifier names.
     *
     * @param creature          the creature whose stat mod we want
     * @param skillStatNames    array of names of the skill stat mods we want
     *
     * @return the skill stat mod values, or null on error
     */
    private static native int[] _getEnhancedSkillStatisticModifiers(long creature, String[] skillStatNames);
    public static int[] getEnhancedSkillStatisticModifiers(obj_id creature, String[] skillStatNames)
    {
        return _getEnhancedSkillStatisticModifiers(getLongWithNull(creature), skillStatNames);
    }

    /** Returns the skill stat modifier value, enhanced by equipment, on a creature for a given skill stat
     * modifier name.  This version does not respect getMaxCreatureSkillModBonus.
     *
     * @param creature          the creature whose stat mod we want
     * @param skillStatName     the name of the skill stat mod we want
     *
     * @return the skill stat mod value
     */
    private static native int _getEnhancedSkillStatisticModifierUncapped(long creature, String skillStatName);
    public static int getEnhancedSkillStatisticModifierUncapped(obj_id creature, String skillStatName)
    {
        return _getEnhancedSkillStatisticModifierUncapped(getLongWithNull(creature), skillStatName);
    }

    /** Returns an array of skill stat modifier values, enhanced by equipment, on a creature for a list of
     * given skill stat modifier names.This version does not respect getMaxCreatureSkillModBonus.
     *
     * @param creature          the creature whose stat mod we want
     * @param skillStatNames    array of names of the skill stat mods we want
     *
     * @return the skill stat mod values, or null on error
     */
    private static native int[] _getEnhancedSkillStatisticModifiersUncapped(long creature, String[] skillStatNames);
    public static int[] getEnhancedSkillStatisticModifiersUncapped(obj_id creature, String[] skillStatNames)
    {
        return _getEnhancedSkillStatisticModifiersUncapped(getLongWithNull(creature), skillStatNames);
    }

    /** @brief Get a string describing the title that is granted by the skill

        @param skillName  The name of the skill to query for the title it provides

        @return A String describing the title that is bestowed upon the creature having
        this skill.
        @todo this should be a string id
        @author Justin Randall <jrandall@soe.sony.com>
    */
    public static native String getSkillTitleGranted(String skillName);

    /** @brief Grant a command to a creature

       A command is an arbitrary capability that a creature can execute.
       For example, a player may have acquired advanced melee combat commands
       that allows her to perform foot-sweeps or round-house punches.

       \code
        if(playerHasQuestItem)
        {
            boolean result = grantCommand(player, "HeadShot");
            // check results...
        }
        \endcode

       @param target         The creature which will receive the named command
       @param commandName    The command that the creature will have after the command executes

       @return True when the command is succesfully granted to the creature.
        @author Justin Randall <jrandall@soe.sony.com>
     */
     private static native boolean _grantCommand(long target, String commandName);
     public static boolean grantCommand(obj_id target, String commandName)
     {
        return _grantCommand(getLongWithNull(target), commandName);
     }

    /** @brief Grant a specific type of experience to a creature

        Grant the named experience to the creature object. Experience
        is divided among several categories. The categorization of experience
        is arbitrary. New experience types may be created by specifying the
        type name when granting experience.

        \code
        if(playerHasQuestItem)
        {
            boolean result = grantExperiencePoints(player, "RifleCrafting", 10);
            // check results...
        }
        \endcode

        @param target          Creature that will receive the named experience points
        @param experienceType  The name of the type of experience to grant to the creature
        @param amount          The amount of experience to grant

        @return The amount of xp granted, or XP_ERROR on error. Note that if the target is a proxy, or is offline, the
            value returned will always be amount, even if the xp is changed when the player gets it.
    */
    private static native int __grantExperiencePoints(long target, String experienceType, int amount);
    private static int _grantExperiencePoints(obj_id target, String experienceType, int amount)
    {
        return __grantExperiencePoints(getLongWithNull(target), experienceType, amount);
    }

    public static int grantExperiencePoints(obj_id target, String experienceType, int amount)
    {
        return _grantExperiencePoints(target, experienceType, amount);
    }

    /** @brief Grant a specific type of experience to a creature

        See grantExperiencePoints(obj_id target, String experienceType, int amount) for details. This
        function differs only that the experience type is a value taken from the server object_template.tdf
        file. In general you should only use this version when you have already been given the experience type
        value.

        @param target          Creature that will receive the named experience points
        @param experienceType  The id of the type of experience to grant to the creature
        @param amount          The amount of experience to grant

        @return The amount of xp granted, or XP_ERROR on error. Note that if the target is a proxy, or is offline, the
            value returned will always be amount, even if the xp is changed when the player gets it.
    */
    private static native int __grantExperiencePoints(long target, int experienceType, int amount);
    private static int _grantExperiencePoints(obj_id target, int experienceType, int amount)
    {
        return __grantExperiencePoints(getLongWithNull(target), experienceType, amount);
    }

    public static int grantExperiencePoints(obj_id target, int experienceType, int amount)
    {
        return _grantExperiencePoints(target, experienceType, amount);
    }


    /**
     * Gets the experience type in a string form from the integer
     * @param xpType integer version of the experience type
     * @returns string representing the experience type
     * if a null string is returned, then the experience type is not defined in the XpMap
     */
    public static native String getStringExperienceType(int xpType);

    /** @brief Grant a skill to a creature

        Grant the named skill to the creature. The skill system checks prerequisites and
        will refuse to grant a skill if the creature does not meet prerequisites. It does not,
        however, describe prerequisites.

        \code
        if(playerCompletedQuest)
        {
            boolean result = grantSkill(player, "Advanced Rifle Crafting");
            // check results...
        }
        \endcode

        @param target        Creature that receives the new skill
        @param skillName     Name of the skill that is granted to the creature

        @return True if the skill has been successfuly granted to the creature.
        @author Justin Randall <jrandall@soe.sony.com>
    */
    private static native boolean _grantSkill(long target, String skillName);
    public static boolean grantSkill(obj_id target, String skillName)
    {
        return _grantSkill(getLongWithNull(target), skillName);
    }

    /** @brief Determine if a character has a particular command

        A creature can jave any number of commands.
        This method will query a creature for a named command and return
        true if the creature actually has the capability.

        \code
        if(hasCommand(player, "Pick Locks"))
        {
            tryLockPick(self, player);
        }
        else
        {
            triggerAlarm(self, player);
        }
        \endcode

        @param target       Creature to query for command name
        @param commandName  Command to query for on the creature

        @return True if the creature has the command
        @author Justin Randall <jrandall@soe.sony.com>
    */
    private static native boolean _hasCommand(long target, String commandName);
    public static boolean hasCommand(obj_id target, String commandName)
    {
        return _hasCommand(getLongWithNull(target), commandName);
    }

    /** @brief Determine if a character has a particular skill

        Queries the creature's skill list for the specified skill.

        \code
        if(hasSkill(player, "Advanced Bounty Hunting"))
        {
            return rollToFindLocation(self, player);
        }
        else
        {
            return failedToLocate(self, player);
        }
        \endcode

        @param target     Creature to query for the specified skill
        @param skillName  Name of the skill to query for

        @return True if the player has the skill.
        @author Justin Randall <jrandall@soe.sony.com>
    */
    private static native boolean _hasSkill(long target, String skillName);
    public static boolean hasSkill(obj_id target, String skillName)
    {
        return _hasSkill(getLongWithNull(target), skillName);
    }

    /** @brief Remove a command from a creature

        This removes one instance of a command from a creature. Because a
        command may be provided by multiple skills or specialties, the
        command may be listed multiple times on the creature. This means that
        the after invoking revokeCommand(), the creature may still have the command.

        Repeatedly invoking revokeCommand and checking the creature with hasCommand()
        will ensure the skill is completely obliterated IF that's what the
        script is intended to do.

        @param target        Creature from whom the command is being revoked
        @param commandName   Name of the command to revoke from the creature

        @author Justin Randall <jrandall@soe.sony.com>
    */
    private static native void _revokeCommand(long target, String commandName);
    public static void revokeCommand(obj_id target, String commandName)
    {
        _revokeCommand(getLongWithNull(target), commandName);
    }

    /** @brief Remove a skill from a creature

        This removes the skill and the benefits it provides from the creature losing
        the skill.

        @param target     Creature losing the skill
        @param skillName  Name of the skill to revoke
        @author Justin Randall <jrandall@soe.sony.com>
    */
    private static native void _revokeSkill(long target, String skillName);
    public static void revokeSkill(obj_id target, String skillName)
    {
        _revokeSkill(getLongWithNull(target), skillName);
    }

    /** @brief Remove a skill from a creature

        This removes the skill and the benefits it provides from the creature losing
        the skill -- without sending spam.

        @param target     Creature losing the skill
        @param skillName  Name of the skill to revoke
        @author Robert Sitton <rsitton@soe.sony.com>
    */
    private static native void _revokeSkillSilent(long target, String skillName);
    public static void revokeSkillSilent(obj_id target, String skillName)
    {
        _revokeSkillSilent(getLongWithNull(target), skillName);
    }

    /**
     * Adds a schematic group to a creature.
     * @param target        the creature
     * @param groupName     the schematic group name
     * @return true on success, false on error
     */
    private static native boolean _grantSchematicGroup(long target, String groupName);
    public static boolean grantSchematicGroup(obj_id target, String groupName)
    {
        return _grantSchematicGroup(getLongWithNull(target), groupName);
    }
    /**
     * Removes a schematic group from a creature.
     * @param target        the creature
     * @param groupName     the schematic group name
     * @return true on success, false on error
     */
    private static native boolean _revokeSchematicGroup(long target, String groupName);
    public static boolean revokeSchematicGroup(obj_id target, String groupName)
    {
        return _revokeSchematicGroup(getLongWithNull(target), groupName);
    }
    /**
     * Adds a schematic to a creature.
     * @param target            the creature
     * @param schematicName     the schematic name
     * @return true on success, false on error
     */
    private static native boolean _grantSchematic(long target, String schematicName);
    public static boolean grantSchematic(obj_id target, String schematicName)
    {
        return _grantSchematic(getLongWithNull(target), schematicName);
    }
    /**
     * Adds a schematic to a creature.
     * @param target            the creature
     * @param schematicCrc      the schematic crc
     * @return true on success, false on error
     */
    private static native boolean _grantSchematic(long target, int schematicCrc);
    public static boolean grantSchematic(obj_id target, int schematicCrc)
    {
        return _grantSchematic(getLongWithNull(target), schematicCrc);
    }
    /**
     * Removes a schematic from a creature.
     * @param target            the creature
     * @param schematicName     the schematic name
     * @return true on success, false on error
     */
    private static native boolean _revokeSchematic(long target, String schematicName);
    public static boolean revokeSchematic(obj_id target, String schematicName)
    {
        return _revokeSchematic(getLongWithNull(target), schematicName);
    }
    /**
     * Removes a schematic from a creature.
     * @param target            the creature
     * @param schematicCrc      the schematic crc
     * @return true on success, false on error
     */
    private static native boolean _revokeSchematic(long target, int schematicCrc);
    public static boolean revokeSchematic(obj_id target, int schematicCrc)
    {
        return _revokeSchematic(getLongWithNull(target), schematicCrc);
    }
    /**
     * Tests if a creature has a given schematic.
     * @param target            the creature
     * @param schematicName     the schematic name
     * @return true on success, false on error
     */
    private static native boolean _hasSchematic(long target, String schematicName);
    public static boolean hasSchematic(obj_id target, String schematicName)
    {
        return _hasSchematic(getLongWithNull(target), schematicName);
    }
    /**
     * Tests if a creature has a given schematic.
     * @param target            the creature
     * @param schematicCrc      the schematic crc
     * @return true on success, false on error
     */
    private static native boolean _hasSchematic(long target, int schematicCrc);
    public static boolean hasSchematic(obj_id target, int schematicCrc)
    {
        return _hasSchematic(getLongWithNull(target), schematicCrc);
    }

    /**
     * Finds the skill mods attached to a player.
     * @param player        the player
     * @return the skill mod names the player has, or null on error
     */
    private static native String[] _getSkillStatModListingForPlayer(long player);
    public static String[] getSkillStatModListingForPlayer(obj_id player)
    {
        return _getSkillStatModListingForPlayer(getLongWithNull(player));
    }

    /**
     * Finds the skill commands attached to a player
     * @param player        the player
     * @return the commands the player has, or null on error
     */
    private static native String[] _getCommandListingForPlayer(long player);
    public static String[] getCommandListingForPlayer(obj_id player)
    {
        return _getCommandListingForPlayer(getLongWithNull(player));
    }

    /**
     * Finds the schematics granted by a skill.
     * @param skillName     the skill
     * @return the schematic names the skill grants
     */
    public static native int[] getSkillSchematicsGranted(String skillName);

    /**
     * Finds the draft schematics a player has.
     * @param player        the player
     * @return the schematics, or null on error
     */
    private static native int[] _getSchematicListingForPlayer(long player);
    public static int[] getSchematicListingForPlayer(obj_id player)
    {
        return _getSchematicListingForPlayer(getLongWithNull(player));
    }

    /**
     * Check whether a player has the certifications for an item
     * @param player  the player
     * @param item    the item the player is trying to use
     * @return true if the player has all the certifications the item requires, false if not or if the object ids are not valid
     */
    private static native boolean _hasCertificationsForItem(long player, long item);
    public static boolean hasCertificationsForItem(obj_id player, obj_id item)
    {
        return _hasCertificationsForItem(getLongWithNull(player), getLongWithNull(item));
    }

    /**
     * Get the list of certifications required to use an item.
     */
    private static native String[] _getRequiredCertifications(long item);
    public static String[] getRequiredCertifications(obj_id item)
    {
        return _getRequiredCertifications(getLongWithNull(item));
    }

    private static native int _getSkillStatMod(long target, String statModName);
    public static int getSkillStatMod(obj_id target, String statModName)
    {
        return _getSkillStatMod(getLongWithNull(target), statModName);
    }
    private static native boolean _applySkillStatisticModifier(long target, String statModName, int value);
    public static boolean applySkillStatisticModifier(obj_id target, String statModName, int value)
    {
        return _applySkillStatisticModifier(getLongWithNull(target), statModName, value);
    }

    /**
     * @}
     * @defgroup tokenMethods Token system methods
     * @{
     */

    /****************************************************************
    *  TOKEN SYSTEM SUPPORT
    ****************************************************************/
    /** @brief create a virtual token that contains template and/or
        location information without referring to a real instance of
        an object.

        @param templateName   The name of the object template that
                              this token refers to (e.g. good for using
                              the token to create multiple things
                              "like" the template name)
        @param loc            A location that indicates the last "known"
                              position of an object.

        @return an obj_id that may be used whever a token is valid.

        @see createToken(obj_id target)

        @author Justin Randall
    */
//  public static native obj_id createToken(String templateName, location loc);

    /** @brief create a token from an object

        @param target  The object from which a token is created

        @return The newly created token
    */
//  public static native obj_id   createToken                 (obj_id target);

    /** @brief gets a location from a token

        Tokens only store the location of an object at the time of the
        token's creation, or if the location is explicitly set later. Never
        assume that a token location value is the *current* value of the real
        object it refers to.

        @param tokenId  The object id of the token

        @return a Mocha location object containing location data about the token.

        @author Justin Randall
    */
//  public static native location getTokenTargetLocation      (obj_id tokenId);

    /** @brief get the object to which a token refers */
//  public static native obj_id   getTokenTargetObject        (obj_id tokenId);

    /** @brief get the template name of the object referred to by this token
    */
//  public static native String   getTokenTargetTemplateName  (obj_id tokenId);

    /** @brief get the waypoint associated with this token */
//  public static native obj_id   getTokenWaypoint            (obj_id tokenId);

    /** @brief return the template name of the object

        A token, which refers to some other real object that may or may
        not be loaded, contains limited information about the object so that
        abstract or virtualized representations may be made about the target
        object.

        The template name of the real object is stored with the token. This
        is useful to render an image of the object on a client, or to generalize
        the target object so that a token to it may be used to create more
        objects "like" it.

        @param id  The obj_id of the token that contains the template name of
                   the target object.

        @return A string containing the template name of the object that is
        referred to by the token.

        @author Justin Randall
    */
    private static native String _getTemplateName(long id);
    public static String getTemplateName(obj_id id)
    {
        return _getTemplateName(getLongWithNull(id));
    }

    /** @brief return the shared template name of the object

        @param id  The obj_id of the token that contains the shared template
                    name of the target object.

        @return A string containing the template name of the object that is
                referred to by the token.

        @author Robert Sitton
    */
    private static native String _getSharedObjectTemplateName(long id);
    public static String getSharedObjectTemplateName(obj_id id)
    {
        return _getSharedObjectTemplateName(getLongWithNull(id));
    }

    /** @brief return the static item name of the object

        @param id  The obj_id of the token that contains the shared template
                    name of the target object.

        @return A string containing the static item name for the object

        @author Mike Howard
    */
    private static native String _getStaticItemName(long id);
    public static String getStaticItemName(obj_id id)
    {
        return _getStaticItemName(getLongWithNull(id));
    }

    private static native void _setStaticItemName(long id, String staticItemName);
    public static void setStaticItemName(obj_id id, String staticItemName)
    {
        _setStaticItemName(getLongWithNull(id), staticItemName);
    }

    private static native int _getStaticItemVersion(long id);
    public static int getStaticItemVersion(obj_id id)
    {
        return _getStaticItemVersion(getLongWithNull(id));
    }

    private static native void _setStaticItemVersion(long id, int staticItemVersion);
    public static void setStaticItemVersion(obj_id id, int staticItemVersion)
    {
        _setStaticItemVersion(getLongWithNull(id), staticItemVersion);
    }

    private static native int _getConversionId(long id);
    public static int getConversionId(obj_id id)
    {
        return _getConversionId(getLongWithNull(id));
    }

    private static native void _setConversionId(long id, int conversionId);
    public static void setConversionId(obj_id id, int conversionId)
    {
        _setConversionId(getLongWithNull(id), conversionId);
    }

    /** @brief Create a waypoint object for a given location.

        When a waypoint is created with this method, the region
        is set for the waypoint as well. This can be overridden
        by invoking setWaypointRegion().

        @param target  Where to create the waypoint object - may either be a
                       creature whose datapad will be used, or a mission object.
        @param loc   A location that the waypoint uses to construct itself

        @see createWaypoint(obj_id target, obj_id source)
        @see setWaypointLocation
        @see setWaypointRegion

        @author Justin Randall
    */
    private static native long  _createWaypointInDatapad(long target, location loc);
    public static obj_id  createWaypointInDatapad(obj_id target, location loc)
    {
        return getObjIdWithNull(_createWaypointInDatapad(getLongWithNull(target), loc));
    }
    private static native long  _createWaypointInDatapadWithLimits(long target, location loc);
    public static obj_id  createWaypointInDatapadWithLimits(obj_id target, location loc)
    {
        return getObjIdWithNull(_createWaypointInDatapadWithLimits(getLongWithNull(target), loc));
    }
    private static native long  _createWaypointInMissionObject(long target, location loc);
    public static obj_id  createWaypointInMissionObject(obj_id target, location loc)
    {
        return getObjIdWithNull(_createWaypointInMissionObject(getLongWithNull(target), loc));
    }

    /** @brief Create a waypoint associated with the current location
        of the specified object.

        When a waypoint is created with this method, it gets the location
        of the source object, then behaves identically to
        getWaypoint(location loc).

        @param target  Where to create the waypoint object - may either be a
                       creature whose datapad will be used, or a mission object.
        @param source  An object in the world from which the waypoint will be
                       created.

        @see createWaypoint(obj_id target, location loc)
        @see setWaypointLocation
        @see setWaypointRegion

        @author Justin Randall
    */
    private static native long  _createWaypointInDatapad(long target, long source);
    public static obj_id  createWaypointInDatapad(obj_id target, obj_id source)
    {
        return getObjIdWithNull(_createWaypointInDatapad(getLongWithNull(target), getLongWithNull(source)));
    }
    private static native long  _createWaypointInMissionObject(long target, long source);
    public static obj_id  createWaypointInMissionObject(obj_id target, obj_id source)
    {
        return getObjIdWithNull(_createWaypointInMissionObject(getLongWithNull(target), getLongWithNull(source)));
    }

    private static native long  _createWaypointInMissionInternal(long target, location loc, String buildingName, String cellName);
    public static obj_id  createWaypointInMissionInternal(obj_id target, location loc, String buildingName, String cellName)
    {
        return getObjIdWithNull(_createWaypointInMissionInternal(getLongWithNull(target), loc, buildingName, cellName));
    }
    private static native long  _createWaypointInDatapadInternal(long target, location loc, String buildingName, String cellName);
    public static obj_id  createWaypointInDatapadInternal(obj_id target, location loc, String buildingName, String cellName)
    {
        return getObjIdWithNull(_createWaypointInDatapadInternal(getLongWithNull(target), loc, buildingName, cellName));
    }

    private static native void    _destroyWaypointInDatapad(long waypoint, long player);
    public static void    destroyWaypointInDatapad(obj_id waypoint, obj_id player)
    {
        _destroyWaypointInDatapad(getLongWithNull(waypoint), getLongWithNull(player));
    }

    /** @brief Determine the "active" status of a waypoint.

        Active waypoints may draw themselves in the world differently.
        A large bouncing arrow may appear in worldspace on the client
        for an active waypoint.

        @param waypoint  The waypoint to query for it's active status.

        @return a boolean indicating the active status of the waypoint.
        If the waypoint is active, it returns true, otherwise false.

        @author Justin Randall
    */
    private static native boolean _getWaypointActive(long waypoint);
    public static boolean getWaypointActive(obj_id waypoint)
    {
        return _getWaypointActive(getLongWithNull(waypoint));
    }
    private static native long[] _getWaypointsInDatapad(long player);
    public static obj_id[] getWaypointsInDatapad(obj_id player)
    {
        long[] _ret_long = _getWaypointsInDatapad(getLongWithNull(player));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

    /** @brief Get a location described by a waypoint
    */
    private static native location _getWaypointLocation(long waypoint);
    public static location getWaypointLocation(obj_id waypoint)
    {
        return _getWaypointLocation(getLongWithNull(waypoint));
    }
    private static native String _getWaypointName(long waypoint);
    public static String getWaypointName(obj_id waypoint)
    {
        return _getWaypointName(getLongWithNull(waypoint));
    }
    private static native region _getWaypointRegion(long waypoint);
    public static region getWaypointRegion(obj_id waypoint)
    {
        return _getWaypointRegion(getLongWithNull(waypoint));
    }
    private static native void __setWaypointActiveNative(long waypoint, boolean isActive);
    public static void _setWaypointActiveNative(obj_id waypoint, boolean isActive)
    {
        __setWaypointActiveNative(getLongWithNull(waypoint), isActive);
    }
    private static native void __setWaypointLocationNative(long waypoint, location loc);
    public static void _setWaypointLocationNative(obj_id waypoint, location loc)
    {
        __setWaypointLocationNative(getLongWithNull(waypoint), loc);
    }
    private static native boolean __setWaypointColorNative(long waypoint, String color);
    public static boolean _setWaypointColorNative(obj_id waypoint, String color)
    {
        return __setWaypointColorNative(getLongWithNull(waypoint), color);
    }

    /** @brief set the "active" status of a wayoint */
    public static void setWaypointActive(obj_id waypoint, boolean isActive)
    {
        if(waypoint != null)
        {
            if(getWaypointActive(waypoint) != isActive)
            {
                _setWaypointActiveNative(waypoint, isActive);
            }
        }
    }

    /** @brief set the color of a wayoint

        Acceptable colors are: red, blue, yellow, white, green, and orange

    */
    public static boolean setWaypointColor(obj_id waypoint, String color)
    {
        if(waypoint != null)
        {
            return _setWaypointColorNative(waypoint, color);
        }
        else
            return false;
    }

    /** @brief set the visibility of a waypoint in a player's datapad */
    public static void setWaypointVisible(obj_id waypoint, boolean isVisible)
    {
		// do nothing, this functionality was removed (or was never implemented in the first place)
    }

    /** @brief set the location to which a waypoint refers

        This also sets the region id for the waypoint to the default
        region for the location. Override this by invoking setWaypointRegion()

        @param waypoint  The waypoint that updates
        @param loc       The location to which the location refers

        @see getWaypointLocation
        @see setWaypointRegion

        @author Justin Randall
    */
    public static void setWaypointLocation(obj_id waypoint, location loc)
    {
        if(waypoint != null)
        {
            if(loc != null)
            {
                if(getWaypointLocation(waypoint) != loc)
                {
                    _setWaypointLocationNative(waypoint, loc);
                }
            }
        }
    }

    /** @brief set the region for a waypoint */
    public static void setWaypointRegion(obj_id w, region r)
    {
        if(w != null)
        {
            if(r != null)
            {
            }
        }
    }

    private static native void _setWaypointName(long waypoint, String name);
    public static void setWaypointName(obj_id waypoint, String name)
    {
        _setWaypointName(getLongWithNull(waypoint), name);
    }
    public static native String[] getCtsDestinationClusters();
    public static native String getCurrentSceneName();
    public static native String getClusterName();
    private static native long _getPlanetByName(String name);
    public static obj_id getPlanetByName(String name)
    {
        return getObjIdWithNull(_getPlanetByName(name));
    }
    private static native String _getNameForPlanetObject(long planet);
    public static String getNameForPlanetObject(obj_id planet)
    {
        return _getNameForPlanetObject(getLongWithNull(planet));
    }

    private static native boolean _getCollidesWithObject(location loc, float radius);
    public static boolean getCollidesWithObject(location loc, float radius)
    {
        return _getCollidesWithObject(loc, radius);
    }

    /**
     * @}
     * @defgroup missionMethods Mission system methods
     * @{
     */

    /****************************************************************
    *  MISSION SYSTEM SUPPORT
    ****************************************************************/
    /** @brief Stop mission processing if/when it is "incomplete".

        When a mission is impossible to complete, or it should end
        without penalty or reward to the mission holder, invoke
        abortMission.

        If the mission is aborted, the end mission trigger is not
        invoked.

        @param missionObject  The mission object that represents
                              the mission that will be aborted.
                              Usually, if the mission root script
                              is listening for events and it needs to
                              abort based on some trigger, missionObject
                              will be self.
        \code
        handleMissionTargetObjectDestroyed(obj_id destroyer)
        {
            // the target object for the mission has been
            // destroyed
            if(destroyer != getOwner())
                abortMission(self);
            else
                endMission(false);
        }
        \endcode

        @todo implement this
        @see endMission
        @author Justin Randall
    */
    private static native void      _abortMission(long missionObject);
    public static void      abortMission                     (obj_id missionObject)
    {
        _abortMission(getLongWithNull(missionObject));
    }

    /** @brief assign a mission to a player

        When assignMission is invoked, a message is sent to the target
        player. messageHandler OnAssignMission() with params:

        - params["messageSource"] is the obj_id of the object making the assinment
        - params["missionData"] is the obj_id created with createMissionData()
        - params["missionCreator"] is the obj_id of the player/npc/object that created the mission

        @param missionData      the obj_id of MissionData created by a call to createMissionData()
        @param playerCharacter  The obj_id of the player that should recive the mission

        \code
        void createAndAssignMissionToPlayer(obj_id player)
        {
            obj_id missionData = createMissionData(0.5f, 10000, self, "Test Mission", "justin.test_mission");
            assignMission(missionData, player);
        }
        \endcode

        @author Justin Randall
    */
    public static void             assignMission                    (obj_id missionData, obj_id playerCharacter)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            dictionary dict = new dictionary();
            dict.put("messageSource", self);
            dict.put("missionData", missionData);
            dict.put("missionCreator", self);
            messageTo(playerCharacter, "OnAssignMission", dict, 0, true);
        }
    }

    /** @brief instantiate a MissionObject in a creature's mission bag

        @see assignMission

        @author Justin Randall
    */
    private static native long  _createMissionObjectInCreatureMissionBag(long creature);
    public static obj_id  createMissionObjectInCreatureMissionBag(obj_id creature)
    {
        return getObjIdWithNull(_createMissionObjectInCreatureMissionBag(getLongWithNull(creature)));
    }

    /** @brief create a new MissionData object suitable for posting to
        the mission board or making field assignments.

        All MissionObject instances are created from MissionData objects.
        Before a mission can be posted or assigned, the MissionData
        must be populated with filtering data.

        Often, specialized scripts will also attach objvars to MissionData
        objects once they are created, but before they are posted to
        a mission board or used to assign a mission.

        @param efficiencyRequirement  The minimum success rate in this
                                      mission type one must have before
                                      they may take this mission.
        @param expireTimeDelay        The number of seconds, from the time this
                                      MissionData object was created, that the
                                      mission will expire.
        @param missionCreator         The player, NPC or other server object
                                      that created this mission (usually 'self').
        @param missionType            The type name of the mission.
        @param missionRootScriptName  The name of the script that should be
                                      attached to MissionObject instances created
                                      with this MissionData object.

        \code
        TRIGGER OnUpdateNPCMissionSpawner()
        {
            obj_id missionData = createMissionData(0.7, 1440, self, "Deliver", "missions.pickup_and_deliver");
            obj_id item = spawnRandomItem();
            obj_id chest = spawnRandomChest();
            setObjVar(missionData, "item", item);
            setObjVar(missionData, "source container", chest);
            setObjVar(missionData, "deliver to", self);
            postMission(missionData);
        }
        \endcode
        @see postMission
        @see assignMission
        @see getMissionCreator
        @see getMissionType
        @see getMissionType
        @see getMissionEfficiencyRequirement
        @see getMissionExpireTime
        @see getMissionRootScriptName
        @see setMissionCreator
        @see setMissionExpireTime
        @see setMissionEfficiencyRequirement
        @see setMissionType
        @see setMissionRootScriptName

        @todo missionType might need to be a StringId

        @author Justin Randall
    */
//  public static native obj_id    createMissionData                (float efficiencyRequirement, int expireTimeDelay, obj_id missionCreator, String missionType, String rootScriptName);

    /** @brief Complete (successfully or not) a mission. Invoke
        endMission on the MissionObject and trigger endMission on the
        mission object's root script.

        When a script determines that a mission has succeeded or
        failed, it invokes endMission(bool successState). This, in turn
        will invoke endMission on the mission object, and ultimately
        trigger endMission on the mission object root script.

        @param missionObject  The mission that is ending, often self
                              when a script is executing in the context
                              of the current MissionObject.

        @todo write example code for endMission
        @todo implement endMission JNI call in C++

        @author Justin Randall
    */
    public static void      endMission                     (obj_id missionObject)
    {
        if(missionObject != null)
        {
            dictionary d = new dictionary();
            messageTo(missionObject, "OnEndMission", d, 0, true);
            destroyObject(missionObject);
        }
    }

    private static native void _startMission(long creature, long mission);
    public static void startMission(obj_id creature, obj_id mission)
    {
        _startMission(getLongWithNull(creature), getLongWithNull(mission));
    }
    /** @brief initiate a mission

        When startMission is invoked, a message (OnStartMission) is
        sent to the MissionObject associated with the player/character
        running the mission. This is an entry point for actually
        initiating mission activity.

        @param missionObject  The mission object that will receive the
                              OnStartMission message.

        @see assignMission
        @see createMissionObject
        @see createMissionData

        @author Justin Randall
    */
    public static void             startMission                     (obj_id missionObject)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            debugServerConsoleMsg(self, "entering startMission");
            if(missionObject != null)
            {
                startMission(self, missionObject);
                dictionary d = new dictionary();
                d.put("messageSource", self);
                messageTo(missionObject, "OnStartMission", d, 0, true);
            }
            else
            {
                debugServerConsoleMsg(self, "   missionObject is NULL!!");
            }
        }
    }

    /** @brief enumerate the mission objects held by a player character

        @return an array of obj_id's that describe the MissionObjects a player current has.
        @author Justin Randall
    */
    private static native long[]  _getMissionObjects(long playerCharacter);
    public static obj_id[]  getMissionObjects                (obj_id playerCharacter)
    {
        long[] _ret_long = _getMissionObjects(getLongWithNull(playerCharacter));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
//  public static native obj_id[]  getDynamicMissionObjects         (obj_id playerCharacter);

//  public static native void      sendMissionsToClient(obj_id player, obj_id[] missions);

    /** @brief return the player character object that has the specified mission object
    */
    private static native long    _getMissionHolder(long missionObject);
    public static obj_id    getMissionHolder                 (obj_id missionObject)
    {
        return getObjIdWithNull(_getMissionHolder(getLongWithNull(missionObject)));
    }

    /** @brief return the obj_id of the object that created the mission

        For player created missions, this is the object id of the player character
        that created/posted the mission. For dynamically spawned missions, this may
        be a special group, NPC, or some ficticious entity that can be represented
        as a server object.

        @param missionData  The MissionData object that was created with createMissionData()

        @return an obj_id for the object that created the mission

        @see createMissionData
        @see setMissionCreator

        @author Justin Randall
    */
    private static native String    _getMissionCreator(long missionData);
    public static String    getMissionCreator                (obj_id missionData)
    {
        return _getMissionCreator(getLongWithNull(missionData));
    }

    /** @brief return a string id for the description of the mission

        @param missionData   The mission data object that has a description

        @return a string_id that describes the mission, or null on failure.
    */
    private static native string_id  _getMissionDescription(long missionData);
    public static string_id  getMissionDescription  (obj_id missionData)
    {
        return _getMissionDescription(getLongWithNull(missionData));
    }

    /** @brief return an integer describing the mission difficulty level

        @param missionData  The MissionData object that was created with createMissionData()

        @return an integer describing the mission difficulty level

        @see setMissionDifficulty
        @see createMissionData

        @author Justin Randall
    */
    private static native int       _getMissionDifficulty(long missionData);
    public static int       getMissionDifficulty             (obj_id missionData)
    {
        return _getMissionDifficulty(getLongWithNull(missionData));
    }

    /** @brief return the end location of the mission

        Some missions have starting and ending areas (the market place in Mos Espa, e.g.).
        This returns the end location for the current mission. For some missions, this
        is primarily informational to give the player some notion of where to go to
        complete a mission. In other cases, like escort missions, the player must arrive
        at the location to complete the mission.

        @param missionData  The MissionData object returned from createMissionData()

        @return a location object describing where the mission will end.
        @see setMissionEndLocation
        @see createMissionData

        @author Justin Randall
    */
    private static native location  _getMissionEndLocation(long missionData);
    public static location  getMissionEndLocation            (obj_id missionData)
    {
        return _getMissionEndLocation(getLongWithNull(missionData));
    }


    /** @brief Return the reward value (in credits) that will be granted by this mission
        upon completion

        @param missionData  The MissionData object returned by createMission()

        @return an int describing the amount of money this mission rewards a player upon
        successful completion

        @see setMissionReward
        @see createMissionData

        @author Justin Randall
    */
    private static native int       _getMissionReward(long missionData);
    public static int       getMissionReward                 (obj_id missionData)
    {
        return _getMissionReward(getLongWithNull(missionData));
    }

    /** @brief return the name of the first script attached to a mission object created
        with this data.

        The root script is a script that bootstraps the mission object created by the
        missionData. This script is attached, setup triggers/messages are exchanged with
        it during mission assignment. It is often responsible for attaching scripts to
        players and other objects associated with the mission.

        @param missionData  The MissionData object returned by createMission()

        @return a String that names the root script associated with this mission.

        @see setMissionRootScriptName
        @see createMissionData

        @author Justin Randall
    */
    private static native String    _getMissionRootScriptName(long missionData);
    public static String    getMissionRootScriptName         (obj_id missionData)
    {
        return _getMissionRootScriptName(getLongWithNull(missionData));
    }

    private static native int  _getMissionStatus(long missionObject);
    public static int  getMissionStatus(obj_id missionObject)
    {
        return _getMissionStatus(getLongWithNull(missionObject));
    }

    private static native void _setMissionStatus(long missionObject, int status);
    public static void setMissionStatus(obj_id missionObject, int status)
    {
        _setMissionStatus(getLongWithNull(missionObject), status);
    }

    /** @brief return a location describing where the mission "starts".

        Some missions use this location for informational purposes (e.g. get ore from my harvester
        at *this* location), others, such as dynamic missions, may use this to initiate
        spawn routines (go to the naboo swamps and kill a Snoid, bring me it's carcass).

        @param missionData  The MissionData object returned by createMission()

        @return a location object describing the start location of a mission

        @see setMissionStartLocation
        @see location
        @see createMissionData

        @author Justin Randall
    */
    private static native location  _getMissionStartLocation(long missionData);
    public static location  getMissionStartLocation          (obj_id missionData)
    {
        return _getMissionStartLocation(getLongWithNull(missionData));
    }

    /** @brief Get a string containing the target name for the mission

        @param missionData  a missionData object that has had the title set with setMissionTitle

        @return a string or null on failure
    */
    private static native String  _getMissionTargetName(long missionData);
    public static String  getMissionTargetName  (obj_id missionData)
    {
        return _getMissionTargetName(getLongWithNull(missionData));
    }

    /** @brief Get a string containing a short title for the mission

        @param missionData  a missionData object that has had the title set with setMissionTitle

        @return a string_id or null on failure
    */
    private static native string_id  _getMissionTitle(long missionData);
    public static string_id  getMissionTitle  (obj_id missionData)
    {
        return _getMissionTitle(getLongWithNull(missionData));
    }

    /** @brief Get a String describing the type of mission created by this MissionData object

        @param missionData  The MissionData object returned by createMission()

        @return the time (in seconds) the mission must be completed within from the time it is accepted.

        @see setMissionType
        @see getMissionRootScriptName
        @see setMissionRootScriptName
        @see createMissionData

        @author Justin Randall
    */
    private static native String    _getMissionType(long missionData);
    public static String    getMissionType                   (obj_id missionData)
    {
        return _getMissionType(getLongWithNull(missionData));
    }

    /** @brief Identify the creator of this mission

        If this mission is posted by a player, then the mission creator is set to this.
        Scripts that dynamically spawn missions may set other values (NPC's for example).

        @param missionData  The MissionData object returned by createMission()
        @param creator      The obj_id of the creator of this mission

        @see getMissionCreator
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionCreator(long missionData, String creator);
    public static void      setMissionCreator                (obj_id missionData, String creator)
    {
        _setMissionCreator(getLongWithNull(missionData), creator);
    }

    /** @brief set the string_id that describes the mission
    */
    private static native void  _setMissionDescription(long missionData, string_id description);
    public static void  setMissionDescription  (obj_id missionData, string_id description)
    {
        _setMissionDescription(getLongWithNull(missionData), description);
    }

    /** @brief  Set the difficulty value associated with this mission

        Players may filter by mission difficulty when browsing missions. The mission
        difficulty is an indication of how hard it will be to complete the mission. The
        dicciculty is completely design driven, and it may be difficult to assign a
        value for player generated missions. This is intended (but not restricted to)
        support dynamically generated mission content.

        @param missionData  The MissionData object returned by createMission()
        @param difficulty   A non-negative value describing the difficulty of this mission

        @see getMissionDifficulty
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionDifficulty(long missionData, int difficulty);
    public static void      setMissionDifficulty             (obj_id missionData, int difficulty)
    {
        _setMissionDifficulty(getLongWithNull(missionData), difficulty);
    }

    /** @brief set the end location of a mission

        @param missionData  The MissionData object returned by createMission()
        @param endLocation  The location describing where the mission goal will be achieved

        @see getMissionEndLocation
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionEndLocation(long missionData, location endLocation);
    public static void      setMissionEndLocation            (obj_id missionData, location endLocation)
    {
        _setMissionEndLocation(getLongWithNull(missionData), endLocation);
    }

    /** @brief Set the reward amount awarded by this mission upon successful completion


        @param missionData  The MissionData object returned by createMission()
        @param reward       The amount of money awared by the missionon success

        @see getMissionReward
        @see getMissionBondAmount
        @see setMissionBondAmount
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionReward(long missionData, int reward);
    public static void      setMissionReward                 (obj_id missionData, int reward)
    {
        _setMissionReward(getLongWithNull(missionData), reward);
    }

    /** @brief Set the name of the root script that bootstraps this
        mission object created with this mission data.

        @param missionData     The MissionData object returned by createMission()
        @param rootScriptName  The name of ths script that will bootstrap mission
                               objects created with this mission data

        @see getMissionRootScriptName
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionRootScriptName(long missionData, String rootScriptName);
    public static void      setMissionRootScriptName         (obj_id missionData, String rootScriptName)
    {
        _setMissionRootScriptName(getLongWithNull(missionData), rootScriptName);
    }

    /** @brief Set the mission starting location

        @param missionData  The MissionData object returned by createMission()
        @param start        A location describing a start location for this mission

        @see getMissionStartLocation
        @see getMissionEndLocation
        @see setMissionEndLocation
        @see getMissionEndObject
        @see setMissionEndObject
        @see getMissionStartObject
        @see setMissionStartObject
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionStartLocation(long missionData, location start);
    public static void      setMissionStartLocation          (obj_id missionData, location start)
    {
        _setMissionStartLocation(getLongWithNull(missionData), start);
    }

    /** @brief Set the target object associated with this mission

        @param missionData  The MissionData object returned by createMission()
        @param target       The target object associated with this mission

        @see getMissionTarget
        @see getMissionEndObject
        @see setMissionEndObject
        @see getMissionStartObject
        @see setMissionStartObject
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionTargetAppearance(long missionData, String target);
    public static void      setMissionTargetAppearance     (obj_id missionData, String target)
    {
        _setMissionTargetAppearance(getLongWithNull(missionData), target);
    }
    private static native void      _setMissionTargetName(long missionObject, String name);
    public static void      setMissionTargetName           (obj_id missionObject, String name)
    {
        _setMissionTargetName(getLongWithNull(missionObject), name);
    }

    /** @brief set the string_id for the mission title */
    private static native void  _setMissionTitle(long missionData, string_id title);
    public static void  setMissionTitle  (obj_id missionData, string_id title)
    {
        _setMissionTitle(getLongWithNull(missionData), title);
    }

    /** @brief Set the type name of the mission

        The type name is used to present the appropriate details for a mission in the client
        user interface. It is also used for efficiency requirement calculations.

        @param missionData  The MissionData object returned by createMission()
        @param typeName     A String describing the type of mission

        @see getMissionType
        @see createMissionData

        @author Justin Randall
    */
    private static native void      _setMissionType(long missionData, String typeName);
    public static void      setMissionType                   (obj_id missionData, String typeName)
    {
        _setMissionType(getLongWithNull(missionData), typeName);
    }

    /** @brief Watch another object.

            A watched object will be loaded and remain loaded
            until all objects that are watching it have invoked
            stopWatching().

            When an object is ready to watch, messageHandler OnObserving() will
            be invoked on the caller (whoever calls watch()), and params will contain an
            obj_id member named target that is the obj_id of the requested object.
    */
    private static native void      _watch(long target);
    public static void      watch                            (obj_id target)
    {
        _watch(getLongWithNull(target));
    }

    /** @brief Permit a watched object to unload

        @see watch
    */
    private static native void      _stopWatching(long target);
    public static void      stopWatching                     (obj_id target)
    {
        _stopWatching(getLongWithNull(target));
    }

    /** @brief Add a location target to a tangible object

        A location target is a location in the game universe that also has a name and a radius.
        If 'addLocationTarget' is used, it describes a circle of radius 'radius' around the 2d location specified.
        If 'addLocationTarget3d' is used, it describes a sphere of radius 'radius' around the 3d location specified.
        When the tangible object breaches the geometry described by the location target,
        trigger OnArrivedAtLocation(String) is invoked on all scripts attached to the
        tangible object. The location target is then destroyed and is not used again.

        \code
        void someMissionFunc()
        {
            location jaba = new location(...);
            addLocationTarget("Jaba's Palace", jaba, 50.0);
        }

        trigger OnArrivedAtLocation(String name)
        {
            // start special code when player enters Jaba's Palace
        }
        \endcode

        @param name    The name of the location target. This must be unique for all targets on an object.
        @param loc     The scene and x,y,z coordinates of the location on a planet or  space volume.
        @param radius  The radius around the point that, when the player enters the range, considers the location target breached.

        @see removeLocationTarget

        @author Justin Randall
    */
    public static void addLocationTarget(String name, location loc, float radius)
    {
        obj_id self = getSelf();
        if(self != null)
            _addLocationTarget(self, name, loc, radius, false);
    }

    public static void addLocationTarget3d(String name, location loc, float radius)
        {
        obj_id self = getSelf();
        if (self != null)
            _addLocationTarget(self, name, loc, radius, true);
        }
    // This is a function that you should not use in multiserver.
    public static void addLocationTarget3d(obj_id target, String name, location loc, float radius)
    {
        _addLocationTarget(target, name, loc, radius, true);
    }

    private static native void      __addLocationTarget(long self, String name, location loc, float radius, boolean is3d);
    private static void      _addLocationTarget                (obj_id self, String name, location loc, float radius, boolean is3d)
    {
        __addLocationTarget(getLongWithNull(self), name, loc, radius, is3d);
    }

    /** @brief remove a previously defined location target from a tangible object

        @param name  The unique (per player) name of the target to remove

        @see addLocationTarget

        @author Justin Randall
    */
    public static void  removeLocationTarget(String name)
    {
        obj_id self = getSelf();
        if(self != null)
        {
            _removeLocationTarget(self, name);
        }
    }

    public static void removeLocationTarget(obj_id target, String name)
    {
        _removeLocationTarget(target, name);
    }

    private static native void      __removeLocationTarget(long self, String name);
    private static void      _removeLocationTarget             (obj_id self, String name)
    {
        __removeLocationTarget(getLongWithNull(self), name);
    }

    /**
     * @}
     * @defgroup stringMethods String manipulation methods
     * @{
     */

    // string methods
    /**
     * Returns the string associated with a given string_id.
     * @param id        the string_id
     * @return the string
     */
    public static native String getString(string_id id);
    /**
     * Returns the strings associated with an array of string_ids.
     * @param ids       the string_ids
     * @return the strings
     */
    public static native String[] getStrings(string_id[] ids);
    /**
     * Tests if a string is considered obscene.
     * @param data      the string to test
     * @return true if the string is considered obscene, false if not
     */
    public static native boolean isObscene(String data);
    /**
     * Tests is a string is appropriate, whatever that means.
     * @param data      the string to test
     * @return true if the string is appropriate, false if not
     */
    public static native boolean isAppropriateText(String data);


    //*********************************************************************
        // string functions
        //*********************************************************************

        /**
         * Joins two string_ids.
         *
         * @param s1        the 1st string_id
         * @param s2        the 2nd string_id
         *
         * @return the combined string
         */
        public static String join(string_id s1, string_id s2)
        {
            string_id[] ids = new string_id[2];
            ids[0] = s1;
            ids[1] = s2;
            String[] strings = getStrings(ids);
            return join(strings[0], strings[1]);
        }   // join(string_id, string_id)

        /**
         * Joins a string_id and a string.
         *
         * @param s1        the string_id
         * @param s2        the string
         *
         * @return the combined string
         */
        public static String join(string_id s1, String s2)
        {
            return join(getString(s1), s2);
        }   // join(string_id, String)

        /**
         * Joins a string and a string_id.
         *
         * @param s1        the string
         * @param s2        the string_id
         *
         * @return the combined string
         */
        public static String join(String s1, string_id s2)
        {
            return join(s1, getString(s2));
        }   // join(String, string_id)

        /**
         * Joins two strings.
         *
         * @param s1        the 1st string
         * @param s2        the 2nd string
         *
         * @return the combined string
         */
        static public String join(String s1, String s2)
        {
            if (s1 != null && s2 != null)
                return s1 + s2;
            else if (s1 == null && s2 == null)
                return null;
            else if (s1 != null)
                return s1;
            return s2;
        }   // join(String, String)

        /**
         *
         */
        public static String removeLeadWords(String data, string_id keyword)
        {
            return null;
        }   // removeLeadWords(String, string_id)

        /**
         *
         */
        public static String removeLeadWords(string_id data, string_id keyword)
        {
            return null;
        }   // removeLeadWords(string_id, string_id)

        /**
         * Splits a string into separate parts based off a delimiter character.
         *
         * @param data          the string to split
         * @param delimiter     the delimiter character
         *
         * @return an array of strings that were separated by the delimiter character.
         * Note that the delimiter character is not included in the resulting strings.
         */
        static public String[] split(String data, char delimiter)
        {
            if (data == null)
                return null;

            // put delimiter into an array
            char[] delimArray = new char[1];
            delimArray[0] = delimiter;
            String delimiterString = new String(delimArray);
            delimArray = null;

            // find out how many substrings there are
            int index = 0;
            int lastIndex = 0;
            int count = 1;
            do
            {
                index = data.indexOf(delimiterString, lastIndex);
                if (index != -1)
                {
                    ++count;
                    lastIndex = index + 1;
                }
            } while (index != -1);

            // split the string
            String[] results = new String[count];
            lastIndex = 0;
            for (int i = 0; i < count; ++i)
            {
                index = data.indexOf(delimiterString, lastIndex);
                if (index != -1)
                {
                    results[i] = data.substring(lastIndex, index);
                    lastIndex = index + 1;
                }
            }
            results[count - 1] = data.substring(lastIndex);

            return results;
        }   // split(String, char)

        /**
         * Splits a string_id into separate parts based off a delimiter character.
         *
         * @param data          the string_id to split
         * @param delimiter     the delimiter character
         *
         * @return an array of strings that were separated by the delimiter character.
         * Note that the delimiter character is not included in the resulting strings.
         */
        public static String[] split(string_id data, char delimiter)
        {
            return split(getString(data), delimiter);
        }   // split(string_id, char)

        /**
         * Converts a string to uppercase.
         *
         * @param data      the string to convert
         *
         * @return the uppercase string
         */
        public static String toUpper(String data)
        {
            if (data == null)
                return null;

            // @todo: do we need locale info here?
            return data.toUpperCase();
        }   // toUpper(string)

        /**
         * Converts a string_id to uppercase.
         *
         * @param data      the string_id to convert
         *
         * @return the uppercase string
         */
        public static String toUpper(string_id data)
        {
            return toUpper(getString(data));
        }   // toUpper(string_id)

        /**
         * Converts a string to lowercase.
         *
         * @param data      the string to convert
         *
         * @return the lowercase string
         */
        public static String toLower(String data)
        {
            if (data == null)
                return null;

            // @todo: do we need locale info here?
            return data.toLowerCase();
        }   // toLower(string)

        /**
         * Converts a string_id to lowercase.
         *
         * @param data      the string_id to convert
         *
         * @return the lowercase string
         */
        public static String toLower(string_id data)
        {
            return toLower(getString(data));
        }   // toLower(string_id)

        /**
         * Converts a character in a string to uppercase.
         *
         * @param data      the string to convert
         * @param index     index of the character to convert
         *
         * @return the modified string, or null on error
         */
        public static String toUpper(String data, int index)
        {
            if (data == null || index < 0 || index >= data.length())
                return null;

            // @todo: do we need locale info here?
            return data.substring(0, index) +
                data.substring(index, index + 1).toUpperCase() +
                data.substring(index + 1);
        }   // toUpper(string, int)

        /**
         * Converts a character in a string_id to uppercase.
         *
         * @param data      the string to convert
         * @param index     index of the character to convert
         *
         * @return the modified string, or null on error
         */
        public static String toUpper(string_id data, int index)
        {
            return toUpper(getString(data), index);
        }   // toUpper(string_id, int)

        /**
         * Converts a character in a string to lowercase.
         *
         * @param data      the string to convert
         * @param index     index of the character to convert
         *
         * @return the modified string, or null on error
         */
        public static String toLower(String data, int index)
        {
            if (data == null || index < 0 || index >= data.length())
                return null;

            // @todo: do we need locale info here?
            return data.substring(0, index) +
                data.substring(index, index + 1).toLowerCase() +
                data.substring(index + 1);
        }   // toLower(string, int)

        /**
         * Converts a character in a string_id to lowercase.
         *
         * @param data      the string to convert
         * @param index     index of the character to convert
         *
         * @return the modified string, or null on error
         */
        public static String toLower(string_id data, int index)
        {
            return toLower(getString(data), index);
        }   // toLower(string_id, int)

        /**
         * Converts a character to uppercase.
         *
         * @param c     the character to convert
         *
         * @return the modified character
         */
        public static char toUpper(char c)
        {
            return Character.toUpperCase(c);
        }   // toUpper(char)

        /**
         * Converts a character to lowercase.
         *
         * @param c     the character to convert
         *
         * @return the modified character
         */
        public static char toLower(char c)
        {
            return Character.toLowerCase(c);
        }   // toLower(char)

/*@}*/


    /**
    * @defgroup objectMethods Object creation and destruction methods
    */
/*@{*/
    /**
     * Creates a new object in the world. Note the object will not be persisted unless it's template says to.
     * @param template      the template name used to create the object
     * @param pos           the location in the world of an object; currently only supports creating an object on the same scene as the object this script is attached to
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(String template, location pos);
    public static obj_id createObject(String template, location pos)
    {
        return getObjIdWithNull(_createObject(template, pos));
    }
    /**
     * Creates a new object in the world. Note the object will not be persisted unless it's template says to.
     * @param templateCrc   the template crc used to create the object
     * @param pos           the location in the world of an object; currently only supports creating an object on the same scene as the object this script is attached to
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(int templateCrc, location pos);
    public static obj_id createObject(int templateCrc, location pos)
    {
        return getObjIdWithNull(_createObject(templateCrc, pos));
    }
    /**
     * Creates a new object, given its template name, transform, and cell (or null for the world cell)
     * @param template   the template name used to create the object
     * @param transform  the transform specifying the object to parent transform for new object
     * @param cell       the cell in which to create the object, or null for the world cell
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(String template, transform transform, long cell);
    public static obj_id createObject(String template, transform transform, obj_id cell)
    {
        return getObjIdWithNull(_createObject(template, transform, getLongWithNull(cell)));
    }
    /**
     * Creates a new object, given its template crc, transform, and cell (or null for the world cell)
     * @param template   the template crc used to create the object
     * @param transform  the transform specifying the object to parent transform for new object
     * @param cell       the cell in which to create the object, or null for the world cell
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(int templateCrc, transform transform, long cell);
    public static obj_id createObject(int templateCrc, transform transform, obj_id cell)
    {
        return getObjIdWithNull(_createObject(templateCrc, transform, getLongWithNull(cell)));
    }
    /**
     * Creates a new object, based on another object's template, in the world. Note the object will not be persisted unless it's template says to.
     * @param original      the object who's template we will create the new object from
     * @param pos           the location in the world of an object; currently only supports creating an object on the same scene as the object this script is attached to
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(long original, location pos);
    public static obj_id createObject(obj_id original, location pos)
    {
        return getObjIdWithNull(_createObject(getLongWithNull(original), pos));
    }
    /**
     * Creates a new object in a container. Note the object will not be persisted unless it's template says to.
     * @param template      the template name used to create the object
     * @param container     the container to add the object to
     * @param slot          the container slot to add the object to (will be ignored for volume containers).  Use "" for volume containers or for slotted containers when you want to use the first available slot.
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(String template, long container, String slot);
    public static obj_id createObject(String template, obj_id container, String slot)
    {
        return getObjIdWithNull(_createObject(template, getLongWithNull(container), slot));
    }
    /**
     * Creates a new object in a container. Note the object will not be persisted unless it's template says to.
     * @param templateCrc   the template crc used to create the object
     * @param container     the container to add the object to
     * @param slot          the container slot to add the object to (will be ignored for volume containers).  Use "" for volume containers or for slotted containers when you want to use the first available slot.
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(int templateCrc, long container, String slot);
    public static obj_id createObject(int templateCrc, obj_id container, String slot)
    {
        return getObjIdWithNull(_createObject(templateCrc, getLongWithNull(container), slot));
    }
    /**
     * Creates a new object in a volume container, not failing if full. DOES NOT WORK!!!!
     * USE createObjectInInventoryAllowOverload TO CREATE AN OVERLOADED OBJECT IN A PLAYER'S INVENTORY!!!
     * @param template      the template name used to create the object
     * @param container     the container to add the object to
     *
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectOverloaded(String template, long container);
    public static obj_id createObjectOverloaded(String template, obj_id container)
    {
        return getObjIdWithNull(_createObjectOverloaded(template, getLongWithNull(container)));
    }
    /**
     * Creates a new object in a volume container, not failing if full. DOES NOT WORK!!!!
     * USE createObjectInInventoryAllowOverload TO CREATE AN OVERLOADED OBJECT IN A PLAYER'S INVENTORY!!!
     * @param templateCrc   the template crc used to create the object
     * @param container     the container to add the object to
     *
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectOverloaded(int templateCrc, long container);
    public static obj_id createObjectOverloaded(int templateCrc, obj_id container)
    {
        return getObjIdWithNull(_createObjectOverloaded(templateCrc, getLongWithNull(container)));
    }
    /**
     * Creates a new object in a creature's inventory, not failing if full.
     * @param template      the template name used to create the object
     * @param target        the creature to create the object in
     *
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectInInventoryAllowOverload(String template, long target);
    public static obj_id createObjectInInventoryAllowOverload(String template, obj_id target)
    {
        return getObjIdWithNull(_createObjectInInventoryAllowOverload(template, getLongWithNull(target)));
    }
    /**
     * Creates a new object in a creature's inventory, not failing if full.
     * @param templateCrc   the template crc used to create the object
     * @param target        the creature to create the object in
     *
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectInInventoryAllowOverload(int templateCrc, long target);
    public static obj_id createObjectInInventoryAllowOverload(int templateCrc, obj_id target)
    {
        return getObjIdWithNull(_createObjectInInventoryAllowOverload(templateCrc, getLongWithNull(target)));
    }
    /**
     * Creates a new object, based on another object's template, in a container. Note the object will not be persisted unless it's template says to.
     * @param original      the object who's template we will create the new object from
     * @param container     the container to add the object to
     * @param slot          the container slot to add the object to (will be ignored for volume containers).  Use "" for volume containers or for slotted containers when you want to use the first available slot.
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObject(long original, long container, String slot);
    public static obj_id createObject(obj_id original, obj_id container, String slot)
    {
        return getObjIdWithNull(_createObject(getLongWithNull(original), getLongWithNull(container), slot));
    }
    /**
     * Creates a new object, based on another object's template, in a volume container.
     * @param original      the object who's template we will create the new object from
     * @param container     the container to add the object to
     *
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectOverloaded(long original, long container);
    public static obj_id createObjectOverloaded(obj_id original, obj_id container)
    {
        return getObjIdWithNull(_createObjectOverloaded(getLongWithNull(original), getLongWithNull(container)));
    }
    /**
     * Creates a new object at exactly the location specified by target. Note the object will not be persisted unless it's template says to.
     * @param template     the template name of the new object to create
     * @param target       an object whose location and container/cell will be used to create the object.
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectAt(String template, long target);
    public static obj_id createObjectAt(String template, obj_id target)
    {
        return getObjIdWithNull(_createObjectAt(template, getLongWithNull(target)));
    }
    /**
     * Creates a new object at exactly the location specified by target. Note the object will not be persisted unless it's template says to.
     * @param templateCrc  the template crc of the new object to create
     * @param target       an object whose location and container/cell will be used to create the object.
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectAt(int templateCrc, long target);
    public static obj_id createObjectAt(int templateCrc, obj_id target)
    {
        return getObjIdWithNull(_createObjectAt(templateCrc, getLongWithNull(target)));
    }
    /**
     * Creates a manufacturing schematic from a draft schematic template.
     * @param draftSchematic    the draft schematic template to create the manufacturing schematic from
     * @param container         the container to put the manufacturing schematic in
     * @return the id of the manufacturing schematic, or null on error
     */
    private static native long _createSchematic(String draftSchematic, long container);
    public static obj_id createSchematic(String draftSchematic, obj_id container)
    {
        return getObjIdWithNull(_createSchematic(draftSchematic, getLongWithNull(container)));
    }
    /**
     * Creates a manufacturing schematic from a draft schematic template.
     * @param draftSchematicCrc the draft schematic template crc value to create the manufacturing schematic from
     * @param container         the container to put the manufacturing schematic in
     * @return the id of the manufacturing schematic, or null on error
     */
    private static native long _createSchematic(int draftSchematicCrc, long container);
    public static obj_id createSchematic(int draftSchematicCrc, obj_id container)
    {
        return getObjIdWithNull(_createSchematic(draftSchematicCrc, getLongWithNull(container)));
    }

    /**
     * Permanently removes an object from the game.
     * @param target        the object to delete
     * @return true on success, false on fail
     */
    /**
     * Creates a new object, given its template name, transform, and cell (or null for the world cell), and "hyperspaces' the object into the world
     * @param template   the template name used to create the object
     * @param transform  the transform specifying the object to parent transform for new object
     * @param cell       the cell in which to create the object, or null for the world cell
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectHyperspace(String template, transform transform, long cell);
    public static obj_id createObjectHyperspace(String template, transform transform, obj_id cell)
    {
        return getObjIdWithNull(_createObjectHyperspace(template, transform, getLongWithNull(cell)));
    }
    /**
     * Creates a new object, given its template crc, transform, and cell (or null for the world cell), and "hyperspaces' the object into the world
     * @param template   the template crc used to create the object
     * @param transform  the transform specifying the object to parent transform for new object
     * @param cell       the cell in which to create the object, or null for the world cell
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectHyperspace(int templateCrc, transform transform, long cell);
    public static obj_id createObjectHyperspace(int templateCrc, transform transform, obj_id cell)
    {
        return getObjIdWithNull(_createObjectHyperspace(templateCrc, transform, getLongWithNull(cell)));
    }

    private static native boolean __destroyObject(long target);
    private static boolean _destroyObject(obj_id target)
    {
        return __destroyObject(getLongWithNull(target));
    }

    private static native boolean __destroyObjectHyperspace(long target);
    private static boolean _destroyObjectHyperspace(obj_id target)
    {
        return __destroyObjectHyperspace(getLongWithNull(target));
    }
    /**
     * Permanently removes an object from the game.
     * @param target        the object to delete
     * @return true on success, false on fail
     */
    public static boolean destroyObject(obj_id target)
    {
        boolean result = _destroyObject(target);
        if (result)
        {
            target.flagDestroyed();
        }
        return result;
    }
    /**
     * Permanently removes an object from the game by hyperspacing it away
     * @param target        the object to delete
     * @return true on success, false on fail
     */
    public static boolean destroyObjectHyperspace(obj_id target)
    {
        boolean result = _destroyObjectHyperspace(target);
        if (result)
        {
            target.flagDestroyed();
        }
        return result;
    }
    /**
     * Creates a new simulator object in the world. Note the object will not be persisted unless it's template says to.
     * A simulator object is one that is created from a player avatar template, and is used to simulate a players' actions
     * Thus, it has a commandQueue, etc. that non-player creatures would not have
     * @param template      the template name used to create the object
     * @param pos           the location in the world of an object; currently only supports creating an object on the same scene as the object this script is attached to
     * @return the obj_id of the created object, or null on error
     */
    private static native long _createObjectSimulator(String template, location pos);
    public static obj_id createObjectSimulator(String template, location pos)
    {
        return getObjIdWithNull(_createObjectSimulator(template, pos));
    }
    /**
     * Destroys a simulator object in the world.
     * A simulator object is one that is created from a player avatar template, and is used to simulate a players' actions
     * Thus, it has a commandQueue, etc. that non-player creatures would not have
     * @param obj_id        the object id of the simulator object
     * @return true on success, false on failure
     */
    private static native boolean _destroyObjectSimulator(long target);
    public static boolean destroyObjectSimulator(obj_id target)
    {
        return _destroyObjectSimulator(getLongWithNull(target));
    }
    /**
     * Persists an object to the database.
     * @param target        the object to persist
     * @return true on success, false on error
     */
    private static native boolean _persistObject(long target);
    public static boolean persistObject(obj_id target)
    {
        return _persistObject(getLongWithNull(target));
    }
    /**
     * Checks if an object has been persisted to the database.
     * @param target        the object to check
     * @return JNI_TRUE if the object is persisted, JNI_FALSE if not
     */
    private static native boolean _isObjectPersisted(long target);
    public static boolean isObjectPersisted(obj_id target)
    {
        return _isObjectPersisted(getLongWithNull(target));
    }

    /**
     * Reloads path node data for all the path waypoint objects in the array
     * @param target        the array of obj_ids to reload
     */

    private static native boolean _reloadPathNodes(long[] target);
    public static boolean reloadPathNodes(obj_id[] target)
    {
        long[] _target = null;
        if (target != null)
        {
            _target = new long[target.length];
            for (int _i = 0; _i < target.length; ++_i)
                _target[_i] = getLongWithNull(target[_i]);
        }
        return _reloadPathNodes(_target);
    }

    /**
     * Create a temporary path graph for use with POIs. The path graph will
     * be destroyed when the creator object (passed in as "target") is removed
     * from the world
     * @param target        The creator object of the path graph
     * @param radius        The radius of the area to pathfind in, centered on the creator object
     * @param nodeLocations Where (in world space) to put the path nodes
     */

    private static native boolean _createPathGraph(long target, float radius, location[] nodeLocations );
    public static boolean createPathGraph (obj_id target, float radius, location[] nodeLocations )
    {
        return _createPathGraph(getLongWithNull(target), radius, nodeLocations);
    }

    /**
     * Get an object template's name given its crc.
     * @param crc  the crc to look up the name for
     * @return     the name of the template
     */
    public static native String getObjectTemplateName(int crc);

    /**
     * Get an object template's crc given its name.
     * @param name the name of the template to look up the crc for
     * @return     the crc of the template
     */
    public static native int getObjectTemplateCrc(String name);

    public static native int     getNumAI();
    public static native int     getNumCreatures();
    public static native int     getNumPlayers();
    public static native int     getNumRunTimeRules();
	public static native int     getNumDynamicAI();
	public static native int     getNumStaticAI();
	public static native int     getNumCombatAI();
	public static native int     getNumHibernatingAI();

    /**
     * @defgroup theaterMethods Theater creation methods
     *
     * Theaters are a group of objects under the control of a master object. Some things to note:
     * - When all the objects have been created and are visible in the game, OnTheaterCreated() will be triggered
     *   on the master object.
     * - Creating a theater will almost certainly occur over multiple frames. The amount of time we allow for
     *   theater creation per frame can be controlled by the config setting [GameServer] theaterCreationLimitMilliseconds.
     *   Currently it takes about 5.5ms to create a tangible object (not including the time to create the 1st instance
     *   from the object's template, when all its assets are loaded).
     * - The master object is not currently visible in the game.
     * - Destroying the master object will cause all the controlled objects to be destroyed.
     * - Persisting the master object will cause all the controlled objects to be persisted.
     * - HOWEVER, DO NOT persist the master object until all the controlled objects have been created. The best
     *   time to persist a theater is during OnTheaterCreated(). Trying to persist a theater before this will fail
     *   (a warning log entry will be generated).
     * - In general, do not start any behavior in the theater objects until OnTheaterCreated() has been triggered,
     *   especially if the behavior will depend on another object in the theater.
     * - Only one theater can have a given name. If you try to create a theater with the name of an existing theater,
     *   the function will fail. Any number of theaters with no name can be created.
     *
    **@{*/

        // Theater Location Types - how we determine where to spawn a theater
        // NOTE: If you change these values, change the corresponding ones in serverGame/IntangibleObject.h!
        public static final int TLT_none = 0;             // spawn at the location passed to the function, regardless of terrain
        public static final int TLT_getGoodLocation = 1;  // use getGoodLocation to try and find a flat area (this is the default)
        public static final int TLT_flatten = 2;          // spawn at the location passed to the function, using a flattening layer

        /**
         * Creates a group of objects centered at a given position. The first entry in the datatable will define
         * the base position of the theater and an optional script to be attached to the master theater object.
         * Note that the "template" entry for the first entry must be "THEATER".
         * @param datatable     file name of the datatable to read the objects from
         * @param name          name of the theater
         * @param locationType  how to create the theater
         * @return the id of the master theater object, or null on error (bad datatable name)
         */
        public static obj_id createTheater(String datatable, String name, int locationType)
        {
            return createTheater(datatable, getSelf(), name, locationType);
        }
        public static obj_id createTheater(String datatable, String name)
        {
            return createTheater(datatable, getSelf(), name, TLT_getGoodLocation);
        }
        public static obj_id createTheater(String datatable, int locationType)
        {
            return createTheater(datatable, getSelf(), null, locationType);
        }
        public static obj_id createTheater(String datatable)
        {
            return createTheater(datatable, getSelf(), null, TLT_getGoodLocation);
        }
        private static native long _createTheater(String datatable, long self, String name, int locationType);
        public static obj_id createTheater(String datatable, obj_id self, String name, int locationType)
        {
            return getObjIdWithNull(_createTheater(datatable, getLongWithNull(self), name, locationType));
        }
        /**
         * Creates a group of objects centered at a given position.
         * @param datatable     file name of the datatable to read the objects from
         * @param basePosition  the base position of the theater; all objects will be placed relative to here
         * @param script        optional script to be attached to the master theater object; the trigger OnTheaterCreated
         *                      will be called when all the theater objects have been created
         * @param name          the name of the theater
         * @param locationType  how to create the theater
         * @return the id of the master theater object, or null on error (bad datatable name or center)
         */
        public static obj_id createTheater(String datatable, location basePosition, String script, String name, int locationType)
        {
            return createTheater(datatable, basePosition, script, getSelf(), name, locationType);
        }
        public static obj_id createTheater(String datatable, location basePosition, String script, String name)
        {
            return createTheater(datatable, basePosition, script, getSelf(), name, TLT_getGoodLocation);
        }
        public static obj_id createTheater(String datatable, location basePosition, String script, int locationType)
        {
            return createTheater(datatable, basePosition, script, getSelf(), null, locationType);
        }
        public static obj_id createTheater(String datatable, location basePosition, String script)
        {
            return createTheater(datatable, basePosition, script, getSelf(), null, TLT_getGoodLocation);
        }
        private static native long _createTheater(String datatable, location basePosition, String script, long self, String name, int locationType);
        public static obj_id createTheater(String datatable, location basePosition, String script, obj_id self, String name, int locationType)
        {
            return getObjIdWithNull(_createTheater(datatable, basePosition, script, getLongWithNull(self), name, locationType));
        }
        /**
         * Creates a group of objects centered at a given position. The first entry in the datatable will define
         * the base position of the theater and an optional script to be attached to the master theater object.
         * The difference between this command and createTheater is that this will work if the theater is created
         * on a different server than the one the command is called from, although the caller and the theater must
         * still be on the same planet. Note that the "template" entry for the first entry must be "THEATER".
         * @param datatable     file name of the datatable to read the objects from
         * @param name          the name of the theater
         * @param locationType  how to create the theater
         * @return true on success, or false on error (bad datatable name)
         */
        public static boolean createRemoteTheater(String datatable, String name, int locationType)
        {
            return createRemoteTheater(datatable, getSelf(), name, locationType);
        }
        public static boolean createRemoteTheater(String datatable, String name)
        {
            return createRemoteTheater(datatable, getSelf(), name, TLT_getGoodLocation);
        }
        public static boolean createRemoteTheater(String datatable, int locationType)
        {
            return createRemoteTheater(datatable, getSelf(), null, locationType);
        }
        public static boolean createRemoteTheater(String datatable)
        {
            return createRemoteTheater(datatable, getSelf(), null, TLT_getGoodLocation);
        }
        private static native boolean _createRemoteTheater(String datatable, long self, String name, int locationType);
        public static boolean createRemoteTheater(String datatable, obj_id self, String name, int locationType)
        {
            return _createRemoteTheater(datatable, getLongWithNull(self), name, locationType);
        }
        /**
         * Creates a group of objects centered at a given position. The difference between this command and createTheater
         * is that this will work if the theater is created on a different server than the one the command is called from,
         * although the caller and the theater must still be on the same planet.
         * @param datatable     file name of the datatable to read the objects from
         * @param basePosition  the base position of the theater; all objects will be placed relative to here
         * @param script        optional script to be attached to the master theater object; the trigger OnTheaterCreated
         *                      will be called when all the theater objects have been created
         * @param name          the name of the theater
         * @param locationType  how to create the theater
         * @return true on success, or false on error (bad datatable name)
         */
        public static boolean createRemoteTheater(String datatable, location basePosition, String script, String name, int locationType)
        {
            return createRemoteTheater(datatable, basePosition, script, getSelf(), name, locationType);
        }
        public static boolean createRemoteTheater(String datatable, location basePosition, String script, String name)
        {
            return createRemoteTheater(datatable, basePosition, script, getSelf(), name, TLT_getGoodLocation);
        }
        public static boolean createRemoteTheater(String datatable, location basePosition, String script, int locationType)
        {
            return createRemoteTheater(datatable, basePosition, script, getSelf(), null, locationType);
        }
        public static boolean createRemoteTheater(String datatable, location basePosition, String script)
        {
            return createRemoteTheater(datatable, basePosition, script, getSelf(), null, TLT_getGoodLocation);
        }
        private static native boolean _createRemoteTheater(String datatable, location basePosition, String script, long self, String name, int locationType);
        public static boolean createRemoteTheater(String datatable, location basePosition, String script, obj_id self, String name, int locationType)
        {
            return _createRemoteTheater(datatable, basePosition, script, getLongWithNull(self), name, locationType);
        }
        /**
         * Creates a group of objects centered at a given position.
         * @param crcs          template crcs of the objects to create
         * @param positions     where to create the objects, relative to the theater center
         * @param basePosition  the base position of the theater; all objects will be placed relative to here
         * @param script            optional script to be attached to the master theater object; the trigger OnTheaterCreated
         *                      will be called when all the theater objects have been created
         * @return the id of the master theater object, or null on error
         */
        public static obj_id createTheater(int[] crcs, location[] positions, location basePosition, String script)
        {
            return createTheater(crcs, positions, basePosition, script, getSelf());
        }
        private static native long _createTheater(int[] crcs, location[] positions, location basePosition, String script, long self);
        public static obj_id createTheater(int[] crcs, location[] positions, location basePosition, String script, obj_id self)
        {
            return getObjIdWithNull(_createTheater(crcs, positions, basePosition, script, getLongWithNull(self)));
        }
        /**
         * Creates a group of objects centered at a given position.
         * @param templates     template names of the objects to create
         * @param positions     where to create the objects, relative to the theater center
         * @param basePosition  the base position of the theater; all objects will be placed relative to here
         * @param script            optional script to be attached to the master theater object; the trigger OnTheaterCreated
         *                       will be called when all the theater objects have been created
         * @return the id of the master theater object, or null on error
         */
        public static obj_id createTheater(String[] templates, location[] positions, location basePosition, String script)
        {
            return createTheater(templates, positions, basePosition, script, getSelf());
        }
        private static native long _createTheater(String[] templates, location[] positions, location basePosition, String script, long self);
        public static obj_id createTheater(String[] templates, location[] positions, location basePosition, String script, obj_id self)
        {
            return getObjIdWithNull(_createTheater(templates, positions, basePosition, script, getLongWithNull(self)));
        }

        /**
         * Causes a theater to be created when a player gets near its location. We only allow one theater to
         * be assigned to a player at a time.
         * @param player        the player who will cause the theater to be created
         * @param datatable     the datatable to read the theater data from; the 1st entry in the
         *                      datatable defines its location, see createTheater(datatable) above
         * @param name          the theater name
         * @param locationType  how to create the theater
         * @return true on success, false on error
         */
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, String name, int locationType)
        {
            return assignTheaterToPlayer(player, datatable, getSelf(), name, locationType);
        }
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, String name)
        {
            return assignTheaterToPlayer(player, datatable, getSelf(), name, TLT_getGoodLocation);
        }
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, int locationType)
        {
            return assignTheaterToPlayer(player, datatable, getSelf(), null, locationType);
        }
        public static boolean assignTheaterToPlayer(obj_id player, String datatable)
        {
            return assignTheaterToPlayer(player, datatable, getSelf(), null, TLT_getGoodLocation);
        }
        private static native boolean _assignTheaterToPlayer(long player, String datatable, long self, String name, int locationType);
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, obj_id self, String name, int locationType)
        {
            return _assignTheaterToPlayer(getLongWithNull(player), datatable, getLongWithNull(self), name, locationType);
        }

        /**
         * Causes a theater to be created when a player gets near its location.
         * @param player        the player who will cause the theater to be created
         * @param datatable     the datatable to read the theater data from
         * @param basePosition  the base position of the theater; all objects will be placed relative to here
         * @param script        optional script to be attached to the master theater object; the trigger OnTheaterCreated
         *                      will be called when all the theater objects have been created
         * @param name          the theater name
         * @param locationType  how to create the theater
         * @return true on success, false on error
         */
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, location basePosition, String script, String name, int locationType)
        {
            return assignTheaterToPlayer(player, datatable, basePosition, script, getSelf(), name, locationType);
        }
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, location basePosition, String script, String name)
        {
            return assignTheaterToPlayer(player, datatable, basePosition, script, getSelf(), name, TLT_getGoodLocation);
        }
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, location basePosition, String script, int locationType)
        {
            return assignTheaterToPlayer(player, datatable, basePosition, script, getSelf(), null, locationType);
        }
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, location basePosition, String script)
        {
            return assignTheaterToPlayer(player, datatable, basePosition, script, getSelf(), null, TLT_getGoodLocation);
        }
        private static native boolean _assignTheaterToPlayer(long player, String datatable, location basePosition, String script, long self, String name, int locationType);
        public static boolean assignTheaterToPlayer(obj_id player, String datatable, location basePosition, String script, obj_id self, String name, int locationType)
        {
            return _assignTheaterToPlayer(getLongWithNull(player), datatable, basePosition, script, getLongWithNull(self), name, locationType);
        }

        /**
         * Causes any theater assigned to a player to be unassigned.
         * @param player     the player to remove the theater from
         * @return true on success, false on error
         */
        private static native boolean _unassignTheaterFromPlayer(long player);
        public static boolean unassignTheaterFromPlayer(obj_id player)
        {
            return _unassignTheaterFromPlayer(getLongWithNull(player));
        }

        /**
         * Checks if a player has a theater assigned to him.
         * @param player     the player to check
         * @return true if the player is assigned a theater, false if not
         */
        private static native boolean _hasTheaterAssigned(long player);
        public static boolean hasTheaterAssigned(obj_id player)
        {
            return _hasTheaterAssigned(getLongWithNull(player));
        }

        /**
         * Returns the id of the last theater spawned for a player. Note that we do not
         * keep track of any theaters spawned except for the last one.
         * @param player        the player to check
         * @return the theater id, or null on error
         */
        private static native long _getLastSpawnedTheater(long player);
        public static obj_id getLastSpawnedTheater(obj_id player)
        {
            return getObjIdWithNull(_getLastSpawnedTheater(getLongWithNull(player)));
        }

        /**
         * Returns the name of a theater.
         * @param theater    the theater id
         * @return the theater's name, or null if it doesn't have one
         */
        private static native String _getTheaterName(long theater);
        public static String getTheaterName(obj_id theater)
        {
            return _getTheaterName(getLongWithNull(theater));
        }

        /**
         * Finds a theater with a given name.
         * @param name    the theater name to look for
         * @return the theater's id, or null if the theater doesn't exist
         */
        private static native long _findTheater(String name);
        public static obj_id findTheater(String name)
        {
            return getObjIdWithNull(_findTheater(name));
        }

    /*@}*/

    /** @deprecated Do not use.*/
//  public static native boolean addObjectToWorld(obj_id target);
/*@}*/

//-----------------------------------------------------------------------------------------

    /**
    * @defgroup containerMethods Container access methods
    */
    /*@{*/

    /** @brief Get the type of container (if any) that this object is.
     *
     *      This method returns the type of container that the given object is.  This method can also be used to determine if the object is a container.
     *      @param container     The id of the obejct to query.
     *
     *      @return The type of container.
    */
    private static native int         _getContainerType(long container);
    public static int         getContainerType(obj_id container)
    {
        return _getContainerType(getLongWithNull(container));
    }
    /** @brief Get the contents of a container
     *
     *      This method gets the contents of a container.  For nested searches, each of the contents should be queried.
     *      @param container     The id of the obejct to query.
     *
     *      @return A list of objects the container contains.  It will be empty for non-containers.
    */
    private static native long[] _getContents(long container);
    public static obj_id[] getContents(obj_id container)
    {
        long[] _ret_long = _getContents(getLongWithNull(container));
        obj_id[] _ret_obj_id = null;
        if(_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for(int _i = 0; _i < _ret_long.length; ++_i)
            {
				if(!_exists(_ret_long[_i]))
					continue;

                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
			}
        }
        return _ret_obj_id;
    }
    /** @brief Get the contents of a container
     *
     *      This method gets the contents of a container.  For nested searches, each of the contents should be queried.
     *      @param container     The id of the obejct to query.
     *
     *      @return A list of objects the container contains.  It will be empty for non-containers.
    */
    public static Vector getResizeableContents(obj_id container)
    {
        obj_id[] contents = getContents(container);
        if (contents != null)
            return new Vector(Arrays.asList(contents));
        return null;
    }

    /**
     * Returns all the objects that are in a player's (or creature's) inventory and equipment. Special items,
     * such as hair and Trandoshan feet, will not be returned. Items that are not visible to the player will
     * also not be returned.
     *
     * @param player        the player whose stuff to get
     *
     * @return an array of the player's stuff, or null on error
     */
    private static native long[] _getInventoryAndEquipment(long player);
    public static obj_id[] getInventoryAndEquipment(obj_id player)
    {
        long[] _ret_long = _getInventoryAndEquipment(getLongWithNull(player));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

    /** @brief Get the object (if any) that contains this object.
     *
     *      This method returns the object (if any) that contains this object.  0 will be returned if the object is not contained.
     *      @param item     The id of the obejct to query.
     *
     *      @return The object that contains 'item'.  0 if 'item' is not contained.
    */

    private static native long      _getContainedBy(long item);
    public static obj_id      getContainedBy(obj_id item)
    {
        return getObjIdWithNull(_getContainedBy(getLongWithNull(item)));
    }

    /** @brief Query whether a given object resides inside of a container.
     *
     *      This method is used to determine whether a given object resides inside of a container.
     *      @param container     The id of the container to query.
     *      @param item          The id of the contained object to query
     *
     *      @return True if item resides inside of container.  False otherwise.
    */
    private static native boolean     _contains(long container, long item);
    public static boolean     contains(obj_id container, obj_id item)
    {
        return _contains(getLongWithNull(container), getLongWithNull(item));
    }
/** @brief Get the object that resides inside a given slot of a container.
     *
     *      This method returns the object that resides inside a given slot of a container.
     *      @param container     The id of the container to query.
     *      @param slot          The slot of the container to query.
     *
     *      @return The object that resides in the slot of the given container.  0 if there is no item equipped there.
    */
    private static native long      _getObjectInSlot(long container, String slot);
    public static obj_id      getObjectInSlot(obj_id container, String slot)
    {
        return getObjIdWithNull(_getObjectInSlot(getLongWithNull(container), slot));
    }

    /** @brief Get the first parent container the item resides in that is in the world or a cell.
     *
     *      This method returns the first parent container the item resides in that is in the world or a cell.
     *      @param item     The id of the obejct to query.
     *
     *      @return The first parent in the world contain item.  It returns item if the item is in the world directly.  0 if item is not contained or not in the world.
    */

    private static native long      _getFirstParentInWorld(long item);
    public static obj_id      getFirstParentInWorld(obj_id item)
    {
        return getObjIdWithNull(_getFirstParentInWorld(getLongWithNull(item)));
    }

    /** @brief Get the topmost container the item resides in.
     *
     *      This method returns the topmost container the item resides in.  It will return 0 if the item is not contained.
     *      @param item     The id of the obejct to query.
     *
     *      @return The topmost containing object of item.  0 if item is not contained.
    */

    private static native long      _getTopMostContainer(long item);
    public static obj_id      getTopMostContainer(obj_id item)
    {
        return getObjIdWithNull(_getTopMostContainer(getLongWithNull(item)));
    }
    /** @brief Get the number of items in a container.
     *
     *      This method returns the number of items in a container.
     *      @param container     The id of the obejct to query.
     *
     *      @return The number of items in a container.
    */
    private static native int         _getNumItemsIn(long container);
    public static int         getNumItemsIn(obj_id container)
    {
        return _getNumItemsIn(getLongWithNull(container));
    }
/** @brief Destroy the contents of a container.
     *
     *      This method destroys the contents of a container.
     *      @param container     The id of the container whose contents we should zap.
     *
     *      @bug This function doesn't actually work yet.
     *
    */
    private static native void        _destroyContents(long container);
    public static void        destroyContents(obj_id container)
    {
        _destroyContents(getLongWithNull(container));
    }
    /** @brief Place the given item inside a container.
     *
     *      This method places the given item inside a container.
     *      @param item          The id of the item to place.
     *  @param container     The id of the container to receive the item.
     *
     *  @return True indicates the transfer was succesful.
    */

    private static native boolean     _putIn(long item, long container, long player);
    public static boolean     putIn(obj_id item, obj_id container, obj_id player)
    {
        return _putIn(getLongWithNull(item), getLongWithNull(container), getLongWithNull(player));
    }
	/** @brief Place the given item inside a container.
	 *
	 *      This method places the given item inside a container.
	 *      @param item          The id of the item to place.
	 *  @param container     The id of the container to receive the item.
	 *
	 *  @return True indicates the transfer was succesful.
	*/

	private static native boolean _putInPosition(long item, long container, location pos);
	public static boolean putInPosition(obj_id item, obj_id container, location pos)
	{
		return _putInPosition(getLongWithNull(item), getLongWithNull(container), pos);
	}
	/** @brief Place the given item inside a container.  Send any errors to player.
	 *
	 *      This method places the given item inside a container.
	 *      @param item          The id of the item to place.
	 *  @param container     The id of the container to receive the item.
	 *      @param player        The id of a player to send any error messages to.
	 *
	 *  @return True indicates the transfer was succesful.
	*/

    private static native boolean     _putIn(long item, long container);
    public static boolean     putIn(obj_id item, obj_id container)
    {
        return _putIn(getLongWithNull(item), getLongWithNull(container));
    }
    /** @brief Place the given item inside a volume container and don't fail if full.
     *
     *      This method places the given item inside a volume container overloading it if necessary.
     *      @param item          The id of the item to place.
     *  @param container     The id of the container to receive the item.
     *
     *  @return True indicates the transfer was succesful.This can still fail for other reasons.
    */

    private static native boolean     _putInOverloaded(long item, long container);
    public static boolean     putInOverloaded(obj_id item, obj_id container)
    {
        return _putInOverloaded(getLongWithNull(item), getLongWithNull(container));
    }

    /** @brief Place the given item inside a slotted container.
         *
         *      This method places the given item inside a slotted container.  It will attempt to place the item in the first available slot that the item is allowed to reside in.
         *      @param item          The id of the item to place.
         *      @param container     The id of the container to receive the item.
         *
         *      @return True indicates the transfer was succesful.
    */
    private static native boolean     _equip(long item, long container);
    public static boolean     equip(obj_id item, obj_id container)
    {
        return _equip(getLongWithNull(item), getLongWithNull(container));
    }
    /** @brief Place the given item inside a slotted container in a given slot.
         *
         *      This method places the given item inside a slotted container at the specified slot.
         *      @param item          The id of the item to place.
         *      @param container     The id of the container to receive the item.
         *      @param slot          The slot at which to place the object.
         *
         *      @return True indicates the transfer was succesful.
    */
    private static native boolean     _equip(long item, long container, String slot);
    public static boolean     equip(obj_id item, obj_id container, String slot)
    {
        return _equip(getLongWithNull(item), getLongWithNull(container), slot);
    }
    /**     @brief  This function will equip and object into the first valid arrangement, deleting objects if necessary.

     *
     *      This function will equip and object into the first valid arrangement, deleting objects if necessary.
     *      Before it deletes things, it looks for a valid unoccupied arrangement.
     *      @param item          The id of the item to place.
     *  @param container     The id of the container to receive the item.
     *
     *  @return True indicates the transfer was succesful.
    */
    private static native boolean     _equipOverride(long item, long container);
    public static boolean     equipOverride(obj_id item, obj_id container)
    {
        return _equipOverride(getLongWithNull(item), getLongWithNull(container));
    }
    /** @brief Get the total volume usage by the container.
         *
         *      This method returns the total volume taken up by items in the container.  It must be a volume container.
         *      @param container     The id of the volume container.
         *
         *      @return The amount of space taken up.
    */

    private static native int _getFilledVolume(long container);
    public static int getFilledVolume(obj_id container)
    {
        return _getFilledVolume(getLongWithNull(container));
    }

    /** @brief Get the target item's secure trade flag.
         *
         *      Returns true if the object is currently being traded.
         *      @param container     The id of the volume container.
         *
         *      @return true if the item is in secure trade.
    */

    private static native boolean _isInSecureTrade(long item);
    public static boolean isInSecureTrade(obj_id item)
    {
        return _isInSecureTrade(getLongWithNull(item));
    }

    /** @brief Get the total volume capacity the container.
         *
         *      This method returns the total volume capacity of the container.  It must be a volume container.
         *      @param container     The id of the volume container.
         *
         *      @return The amount of space this container can hold.
    */

    private static native int _getTotalVolume(long container);
    public static int getTotalVolume(obj_id container)
    {
        return _getTotalVolume(getLongWithNull(container));
    }
    /** @brief Get the total volume free in the container.
         *
         *      This method returns the total free volume in the container.  It must be a volume container.
         *      @param container     The id of the volume container.
         *
         *      @return The amount of space free.
    */

    private static native int _getVolumeFree(long container);
    public static int getVolumeFree(obj_id container)
    {
        return _getVolumeFree(getLongWithNull(container));
    }
    /** @brief Check to see if a given item is allowed to be in the container.
         *
         *      This method checks to see if the item can be in the container.  It will fail if the container cannot hold it because:
         *        a. There is no available slot
         *        b. The mx volume of the container would be exceeded.
         *      @param item          The id of the item to place.
         *      @param container     The id of the container to receive the item.
         *
         *      @return True indicates the transfer would succeed.
    */

    private static native int _canPutIn(long item, long container);
    public static int canPutIn(obj_id item, obj_id container)
    {
        return _canPutIn(getLongWithNull(item), getLongWithNull(container));
    }
    /** @brief Check to see if a given item is allowed to be in the slotted container.
         *
         *      This method checks to see if the item can be in the container.  It will fail if the container cannot hold it because:
         *        a. There is no available slot
         *        b. The container is not a slotted container.
         *
         *      @param item          The id of the item to place.
         *      @param container     The id of the container to receive the item.
         *      @param slot          The slot at which to place the object.
         *
         *      @return True indicates the transfer would be succesful.
    */
    private static native int _canPutInSlot(long item, long container, String slot);
    public static int canPutInSlot(obj_id item, obj_id container, String slot)
    {
        return _canPutInSlot(getLongWithNull(item), getLongWithNull(container), slot);
    }

    /** @brief Move the contents of one container to another.
         *
         *      This method moves the contents of one container to another.
         *      @param srcContainer      The id of the source container.
         *      @param destContainer     The id of the destination container.
         *
         *
         *      @return True indicates the transfer was succesful.
    */
    private static native int _moveContents(long srcContainer, long destContainer);
    public static int moveContents(obj_id srcContainer, obj_id destContainer)
    {
        return _moveContents(getLongWithNull(srcContainer), getLongWithNull(destContainer));
    }
    /** @brief Move a list of objects into a container.
         *
         *      This method moves a list of objects into a container.
         *      @param targets       The list of objects.
         *      @param container     The id of the container to receive the items.
         *
         *
         *      @return the number of items actually transfered.
    */

    private static native int _moveObjects(long[] targets, long container);
    public static int moveObjects(obj_id[] targets, obj_id container)
    {
        long[] _targets = null;
        if (targets != null)
        {
            _targets = new long[targets.length];
            for (int _i = 0; _i < targets.length; ++_i)
                _targets[_i] = getLongWithNull(targets[_i]);
        }
        return _moveObjects(_targets, getLongWithNull(container));
    }
    /** @brief Send a container code returned from canPutIn to a client
    *
    *   This method notifies a player of a container transfer failure from canPutIn.
    *       you need only call this function if the return code is not CEC_Success (0).
    *       @param player    The player to send the message to
    *       @param errorCode The value returned from canPutIn
    */
    private static native void _sendContainerErrorToClient(long player, int errorCode);
    public static void sendContainerErrorToClient(obj_id player, int errorCode)
    {
        _sendContainerErrorToClient(getLongWithNull(player), errorCode);
    }
    private static native int _getVolume(long target);
    public static int getVolume(obj_id target)
    {
        return _getVolume(getLongWithNull(target));
    }
    private static native void _moveToOfflinePlayerInventoryAndUnload(long target, long player);
    public static void moveToOfflinePlayerInventoryAndUnload(obj_id target, obj_id player)
    {
        _moveToOfflinePlayerInventoryAndUnload(getLongWithNull(target), getLongWithNull(player));
    }
    private static native void _moveToOfflinePlayerBankAndUnload(long target, long player);
    public static void moveToOfflinePlayerBankAndUnload(obj_id target, obj_id player)
    {
        _moveToOfflinePlayerBankAndUnload(getLongWithNull(target), getLongWithNull(player));
    }
    private static native void _moveToOfflinePlayerDatapadAndUnload(long target, long player, int maxDepth);
    public static void moveToOfflinePlayerDatapadAndUnload(obj_id target, obj_id player, int maxDepth)
    {
        _moveToOfflinePlayerDatapadAndUnload(getLongWithNull(target), getLongWithNull(player), maxDepth);
    }

    /**
     * Fix the load_with for topmostObject and its contents by setting them to startingLoadWith.
     * @param topmostObject     the object whose load_with to fix
     * @param startingLoadWith  the new load_with value to use
     * @param maxDepth          how far down the containment chain to update load_with (-1=all, 0=self, 1=1st children, etc.)
     */
    private static native void _fixLoadWith(long topmostObject, long startingLoadWith, int maxDepth);
    public static void fixLoadWith(obj_id topmostObject, obj_id startingLoadWith, int maxDepth)
    {
        _fixLoadWith(getLongWithNull(topmostObject), getLongWithNull(startingLoadWith), maxDepth);
    }

/*@}*/
//-----------------------------------------------------------------------------------------

/**
* @defgroup cellMethods Cell/Interior methods
*/
/*@{*/
    /**
     * Creates a new object in a cell with a given cell name. Note the object will not be persisted unless it's template says to.
     * @param template      the template name used to create the object
     * @param building      the object id of the top level building in which to create the object.
     * @param cellName      the name of the cell in which to create the object.
     * @param pos           the location in the world of an object; currently only supports creating an object on the same scene as the object this script is attached to
     * @return the obj_id of the created object, or null on error
     */
    private static native long   _createObjectInCell(String template, long building, String cellName, location pos);
    public static obj_id   createObjectInCell(String template, obj_id building, String cellName, location pos)
    {
        return getObjIdWithNull(_createObjectInCell(template, getLongWithNull(building), cellName, pos));
    }
    /**
     * Creates a new object in a cell with a given cell name., based on another object's template. Note the object will not be persisted unless it's template says to.
     * @param original      the object who's template we will create the new object from
     * @param building      the object id of the top level building in which to create the object.
     * @param cellName      the name of the cell in which to create the object.
     * @param pos           the location in the world of an object; currently only supports creating an object on the same scene as the object this script is attached to
     * @return the obj_id of the created object, or null on error
     */
    private static native long   _createObjectInCell(long original, long building, String cellName, location pos);
    public static obj_id   createObjectInCell(obj_id original, obj_id building, String cellName, location pos)
    {
        return getObjIdWithNull(_createObjectInCell(getLongWithNull(original), getLongWithNull(building), cellName, pos));
    }
    /**
     * Creates a new object in a cell at a good random location within the cell with a given cell name. Note the object will not be persisted unless it's template says to.
     * @param template      the template name used to create the object
     * @param building      the object id of the top level building in which to create the object.
     * @param cellName      the name of the cell in which to create the object.
     * @return the obj_id of the created object, or null on error
     */
    private static native long   _createObjectInCell(String template, long building, String cellName);
    public static obj_id   createObjectInCell(String template, obj_id building, String cellName)
    {
        return getObjIdWithNull(_createObjectInCell(template, getLongWithNull(building), cellName));
    }
    /**
     * Creates a new object in a cell at a good random location within the cell with a given cell name. Note the object will not be persisted unless it's template says to.
     * @param original      the object who's template we will create the new object from
     * @param building      the object id of the top level building in which to create the object.
     * @param cellName      the name of the cell in which to create the object.
     * @return the obj_id of the created object, or null on error
     */
    private static native long   _createObjectInCell(long original, long building, String cellName);
    public static obj_id   createObjectInCell(obj_id original, obj_id building, String cellName)
    {
        return getObjIdWithNull(_createObjectInCell(getLongWithNull(original), getLongWithNull(building), cellName));
    }
    /**
     * Gets a list of cell name from a given object.
     * @param target        the id of the building from which to get the cell name list.
     * @return the list of the names of cells in the target, or null if the taget has no cells
     */
    private static native String[] _getCellNames(long building);
    public static String[] getCellNames(obj_id building)
    {
        return _getCellNames(getLongWithNull(building));
    }
    /**
     * Returns the cell name for a given cell object.
     * @param target        the id of the cell
     * @return the cell's name, or null on error
     */
    private static native String _getCellName(long target);
    public static String getCellName(obj_id target)
    {
        return _getCellName(getLongWithNull(target));
    }
    /**
     * Sets the minimap label for a cell
     * @param target        the id of the cell
     * @param cellLabel     the text to show on the minimap
     */
    private static native boolean _setCellLabel(long target, String cellLabel);
    public static boolean setCellLabel(obj_id target, String cellLabel)
    {
        return _setCellLabel(getLongWithNull(target), cellLabel);
    }
    /**
     * Returns the minimap label for a given cell
     * @param target        the id of the cell
     * @return the cell's label, or null on error
     */
    private static native String _getCellLabel(long target);
    public static String getCellLabel(obj_id target)
    {
        return _getCellLabel(getLongWithNull(target));
    }
    /**
     * Sets the minimap label offset for a cell. This is relative to the center of the floor.
     * Adding a y value is not recommended as the text will move strangely when the minimap is zoomed in.
     * @param target        the id of the cell
     * @param x             the x offset
     * @param y             the y offset
     * @param z             the z offset
     */
    private static native boolean _setCellLabelOffset(long target, float x, float y, float z);
    public static boolean setCellLabelOffset(obj_id target, float x, float y, float z)
    {
        return _setCellLabelOffset(getLongWithNull(target), x, y, z);
    }
    /**
     * Gets the object id of a cell in a building given a cell name.
     * @param building      the object id of the top level building.
     * @param cellName      the name of the cell whose id we are getting.
     * @return the id of the cell corresponding to the name or nil if it cannot be found.
     */
    private static native long   _getCellId(long building, String cellName);
    public static obj_id   getCellId(obj_id building, String cellName)
    {
        return getObjIdWithNull(_getCellId(getLongWithNull(building), cellName));
    }
    /**
     * Gets the object id of a cell at a given world coordinate
     * @param location      the coordinates to query
     * @return the id of the cell corresponding to the coordinates or nil if it cannot be found.
     */
    public static native location getLocationForWorldCoordinate(float x, float y, float z);
    /**
     * Checks whether a building has a cell of the specified name.
     * @param building      the object id of the top level building.
     * @param cellName      the name of the cell we are looking for.
     * @return whether the cell was found.
     */
    private static native boolean _hasCell(long building, String cellName);
    public static boolean hasCell(obj_id building, String cellName)
    {
        return _hasCell(getLongWithNull(building), cellName);
    }
    /**
     * Gets a list of cell ids from a given building.
     * @param target        the id of the building from which to get the cell name list.
     * @return the list of the ids of cells in the target, or null if the taget has no cells
     */
    private static native long[] _getCellIds(long building);
    public static obj_id[] getCellIds(obj_id building)
    {
        long[] _ret_long = _getCellIds(getLongWithNull(building));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Gets a valid random location in the given cell
     * @param building      the object id of the top level building.
     * @param cellName      the name of the cell whose id we are getting.
     * @return The valid location
     */
    private static native location _getGoodLocation(long building, String cellName);
    public static location getGoodLocation(obj_id building, String cellName)
    {
        return _getGoodLocation(getLongWithNull(building), cellName);
    }
    /**
     * Gets the ejection location for a building
     * @param building      the object id of the building.
     * @return The valid location, or null if the obj_id does not point to a building
     */
    private static native location _getBuildingEjectLocation(long building);
    public static location getBuildingEjectLocation(obj_id building)
    {
        return _getBuildingEjectLocation(getLongWithNull(building));
    }
    /**
     * Test a location to see if it fits on the floor of a building
     * @param loc           the location to test
     * @return true if the location is valid
     */
    public static native boolean isValidInteriorLocation(location loc);
    /**
     * @return the obj_id of the object that was moved
     */
    private static native long _moveHouseItemToPlayer(long building, long player, int index);
    public static obj_id moveHouseItemToPlayer(obj_id building, obj_id player, int index)
    {
        return getObjIdWithNull(_moveHouseItemToPlayer(getLongWithNull(building), getLongWithNull(player), index));
    }
    /**
     * @return the obj_id of the object that was moved
     */
    private static native long _moveHouseItemToPlayer(long building, long player, long item);
    public static obj_id moveHouseItemToPlayer(obj_id building, obj_id player, obj_id item)
    {
        return getObjIdWithNull(_moveHouseItemToPlayer(getLongWithNull(building), getLongWithNull(player), getLongWithNull(item)));
    }
    private static native void _deleteAllHouseItems(long building, long player);
    public static void deleteAllHouseItems(obj_id building, obj_id player)
    {
        _deleteAllHouseItems(getLongWithNull(building), getLongWithNull(player));
    }

    /**
     * Returns if all the contents of a building are loaded or not.
     * @param building      the building to check
     * @return true if the contents are loaded, false if not or there was an error
     */
    private static native boolean _areAllContentsLoaded(long building);
    public static boolean areAllContentsLoaded(obj_id building)
    {
        return _areAllContentsLoaded(getLongWithNull(building));
    }

	/**
	 * Starts load of building objects, if not already started.
	 * @param player player initiating load of building
	 * @param building building to load contents
	 */
	private static native void _loadBuildingContents(long player, long building);
	public static void loadBuildingContents(obj_id player, obj_id building)
	{
		_loadBuildingContents(getLongWithNull(player), getLongWithNull(building));
	}

    /**
     * Returns the base item limit of pob
     * @param building - the building to check
     * @return the base item limit - 0 returned on error
     */
     private static native int _getPobBaseItemLimit(long building);
     public static int getPobBaseItemLimit(obj_id building)
     {
		 return _getPobBaseItemLimit(getLongWithNull(building));
     }

    /**
     * Returns whether or not the game server is at its pending load request limit
     * @return true if no more content load requests should be made
     */
     public static native boolean isAtPendingLoadRequestLimit();

/*@}*/
//-----------------------------------------------------------------------------------------

    /**
    * @defgroup attributeMethods Attribute methods
    */
    /*@{*/
    /**
     * Gets an attribute of a creature.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to get
     * @return the attribute value, or ATTRIB_ERROR on error
     */
    private static native int _getAttrib(long target, int attrib);
    public static int getAttrib(obj_id target, int attrib)
    {
        return _getAttrib(getLongWithNull(target), attrib);
    }
    /**
     * Gets an attribute of a creature, unmodified by encumbrance or attrib mods.
     * Damage will still be applied.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to get
     * @return the attribute value, or ATTRIB_ERROR on error
     */
    private static native int _getUnmodifiedAttrib(long target, int attrib);
    public static int getUnmodifiedAttrib(obj_id target, int attrib)
    {
        return _getUnmodifiedAttrib(getLongWithNull(target), attrib);
    }
    public static int getUnencumberedAttrib(obj_id target, int attrib)
    {
        return getUnmodifiedAttrib(target, attrib);
    }
    /**
     * Gets the max value for an attribute of a creature.
     * @param target        the creature
     * @param attrib        attribute id of the max value attribute to get
     * @return the attribute max value, or ATTRIB_ERROR on error
     */
    private static native int _getMaxAttrib(long target, int attrib);
    public static int getMaxAttrib(obj_id target, int attrib)
    {
        return _getMaxAttrib(getLongWithNull(target), attrib);
    }
    /**
     * Gets the max value for an attribute of a creature, modified by wounds.
     * @param target        the creature
     * @param attrib        attribute id of the max value attribute to get
     * @return the attribute max value, or ATTRIB_ERROR on error
     */
    private static native int _getWoundedMaxAttrib(long target, int attrib);
    public static int getWoundedMaxAttrib(obj_id target, int attrib)
    {
        return _getWoundedMaxAttrib(getLongWithNull(target), attrib);
    }
    /**
     * Gets the unmodified max value for an attribute of a creature.
     * @param target        the creature
     * @param attrib        attribute id of the max value attribute to get
     * @return the attribute max value, or ATTRIB_ERROR on error
     */
    private static native int _getUnmodifiedMaxAttrib(long target, int attrib);
    public static int getUnmodifiedMaxAttrib(obj_id target, int attrib)
    {
        return _getUnmodifiedMaxAttrib(getLongWithNull(target), attrib);
    }
    /**
     * Gets the damage currently applied to a creature's attribute. This damage
     * can be healed normally, and will regenerate over time.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to get
     * @return the damage, or ATTRIB_ERROR on error
     */
    public static int getAttribDamage(obj_id target, int attrib)
    {
        int max = getWoundedMaxAttrib(target, attrib);
        int current = getUnmodifiedAttrib(target, attrib);
        if ( max == ATTRIB_ERROR || current == ATTRIB_ERROR )
            return ATTRIB_ERROR;
        return max - current;
    }
    /**
     * Gets the wounds currently applied to a creature's attribute. This damage
     * must be healed by other players.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to get
     * @return the damage, or ATTRIB_ERROR on error
     */
    public static int getAttribWound(obj_id target, int attrib)
    {
        int wound = getWoundedMaxAttrib(target, attrib);
        int max = getMaxAttrib(target, attrib);
        if ( max == ATTRIB_ERROR || wound == ATTRIB_ERROR )
            return ATTRIB_ERROR;
        return max - wound;
    }

    /**
     * Sets an attribute of a creature.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to set
     * @param value         the value to set the attribute to
     * @return true on success, false on fail
     */
    private static native boolean _setAttrib(long target, int attrib, int value);
    public static boolean setAttrib(obj_id target, int attrib, int value)
    {
        return _setAttrib(getLongWithNull(target), attrib, value);
    }
    /**
     * Sets a max attribute of an creature.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to set
     * @param value         the value to set the max attribute to
     * @return true on success, false on fail
     */
    private static native boolean _setMaxAttrib(long target, int attrib, int value);
    public static boolean setMaxAttrib(obj_id target, int attrib, int value)
    {
        return _setMaxAttrib(getLongWithNull(target), attrib, value);
    }
    /**
     * Adds a delta to an attribute of a creature.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to change
     * @param value         the value to add to the attribute
     * @return true on success, false on fail
     */
    private static native boolean _addToAttrib(long target, int attrib, int value);
    public static boolean addToAttrib(obj_id target, int attrib, int value)
    {
        return _addToAttrib(getLongWithNull(target), attrib, value);
    }
    /**
     * Adds a delta to a max attribute of a creature.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to change
     * @param value         the value to add to the max attribute
     * @return true on success, false on fail
     */
    private static native boolean _addToMaxAttrib(long target, int attrib, int value);
    public static boolean addToMaxAttrib(obj_id target, int attrib, int value)
    {
        return _addToMaxAttrib(getLongWithNull(target), attrib, value);
    }
    /**
     * Adds an old-style attribute modifier to a creature.
     * @param target        the creature
     * @param attrib        attribute id of the attribute to modify
     * @param value         the full strength value of the modifier
     * @param duration      time in secs that the modifier will last at full strength
     * @param attackRate    time in secs for the modifier to go from 0 to full strength
     * @param decayRate     time in secs for the modifier to go from full strength to 0; may also be a MOD constant
     * @return true on success, false on fail
     * @see #MOD_POOL
     * @see #MOD_WOUND
     * @see #MOD_ANTIDOTE
     */
    public static boolean addAttribModifier(obj_id target, int attrib, int value, float duration, float attackRate, float decayRate)
    {
        return addAttribModifier(target, new attrib_mod(attrib, value, duration, attackRate, decayRate));
    }
    /**
     * Adds a new-style attribute modifier to a creature.
     * @param target            the creature
     * @param name              the mod name
     * @param attrib            modifier attribute
     * @param value             modifier value
     * @param duration          how long it lasts
     * @param attackRate        time it takes to go from 0 to m_value
     * @param decayRate         time it takes to go from m_value to 0 (MOD_WOUND = wound, MOD_FAUCET = use attrib faucet)
     * @param changeCurrent     flag to update the current value before the decay time is reached
     * @param triggerOnDone     flag to trigger OnAttribModDone(string modName) when the mod is removed from the creature
     * @param visible           flag to send a message to the player giving info about the mod
     * @return true on success, false on fail
     * @see #MOD_POOL
     * @see #MOD_WOUND
     * @see #MOD_ANTIDOTE
     */
    public static boolean addAttribModifier(obj_id target, String name, int attrib, int value, float duration,
        float attackRate, float decayRate, boolean changeCurrent, boolean triggerOnDone, boolean visible)
    {
        return addAttribModifier(target, new attrib_mod(name, attrib, value, duration, attackRate, decayRate, changeCurrent,
            triggerOnDone, visible));
    }
    /**
     * Adds a damage/heal over time modifier to a creature.
     * @param target            the creature
     * @param attrib            modifier attribute
     * @param value             modifier value
     * @param duration          how long it lasts
     * @return true on success, false on fail
     */
    public static boolean addDotModifier(obj_id target, int attrib, int value, float duration)
    {
        if (attrib == HEALTH || attrib == ACTION || attrib == MIND)
            return addAttribModifier(target, new attrib_mod(attrib, value, duration));
        System.err.println("[script bug] addDotModifier called for non-pool attrib " + attrib);
        return false;
    }
    /**
     * Adds a skillmod modifier to a creature.
     * @param target            the creature
     * @param name              the mod name
     * @param skill             the skill to effect
     * @param value             modifier value
     * @param duration          how long it lasts
     * @param triggerOnDone     flag to trigger OnSkillModDone(string modName) when the mod is removed from the creature
     * @param visible           flag to send a message to the player giving info about the mod
     * @return true on success, false on fail
     */
    public static boolean addSkillModModifier(obj_id target, String name, String skill, int value, float duration,
        boolean triggerOnDone, boolean visible)
    {
        return addAttribModifier(target, new attrib_mod(name, skill, value, duration, triggerOnDone, visible));
    }
    /**
     * Adds an attribute modifier to a creature.
     * @param target        the creature
     * @param mod          the attrib_mod to add
     * @return true on success, false on fail
     */
    private static native boolean _addAttribModifier(long target, attrib_mod mod);
    public static boolean addAttribModifier(obj_id target, attrib_mod mod)
    {
        return _addAttribModifier(getLongWithNull(target), mod);
    }
    /**
     * Adds a series of attribute modifiers to a creature.
     * @param target        the creature
     * @param mods          the attrib_mods to add
     * @return true on success, false on fail
     */
    private static native boolean _addAttribModifiers(long target, attrib_mod[] mods);
    public static boolean addAttribModifiers(obj_id target, attrib_mod[] mods)
    {
        return _addAttribModifiers(getLongWithNull(target), mods);
    }
    /**
     * Tests to see if a creature has a given attrib mod or mod group.
     * @param target        id of creature to test
     * @param modName       name of the mod we want
     * @return true if the creature has the mod, false if not
     */
    private static native boolean _hasAttribModifier(long target, String modName);
    public static boolean hasAttribModifier(obj_id target, String modName)
    {
        return _hasAttribModifier(getLongWithNull(target), modName);
    }
    /**
     * Tests to see if a creature has a given skillmod mod or mod group.
     * @param target        id of creature to test
     * @param modName       name of the mod we want
     * @return true if the creature has the mod, false if not
     */
    private static native boolean _hasSkillModModifier(long target, String modName);
    public static boolean hasSkillModModifier(obj_id target, String modName)
    {
        return _hasSkillModModifier(getLongWithNull(target), modName);
    }
    /**
     * Gets a list of all attribute modifiers for a given attribute currently attached to a creature.
     * @param target        the creature
     * @param attrib        the attribute who's modifiers to get
     * @return an array of attrib_mods, or null on error
     */
    private static native attrib_mod[] _getAttribModifiers(long target, int attrib);
    public static attrib_mod[] getAttribModifiers(obj_id target, int attrib)
    {
        return _getAttribModifiers(getLongWithNull(target), attrib);
    }
    /**
     * Gets a list of all attribute modifiers currently attached to a creature.
     * @param target        the creature
     * @return an array of attrib_mods, or null on error
     */
    private static native attrib_mod[] _getAllAttribModifiers(long target);
    public static attrib_mod[] getAllAttribModifiers(obj_id target)
    {
        return _getAllAttribModifiers(getLongWithNull(target));
    }
    /**
     * Removes the attrib/skill mod(s) with a given name.
     * @param target        id of creature
     * @param modName       name of the mod we want to remove
     * @return true on success, false on fail
     */
    private static native boolean _removeAttribOrSkillModModifier(long target, String modName);
    public static boolean removeAttribOrSkillModModifier(obj_id target, String modName)
    {
        return _removeAttribOrSkillModModifier(getLongWithNull(target), modName);
    }
    /**
     * Removes all the attribute modifiers currently attached to an creature.
     * @param target        the creature
     * @return true on success, false on error
     */
    private static native boolean _removeAllAttribModifiers(long target);
    public static boolean removeAllAttribModifiers(obj_id target)
    {
        return _removeAllAttribModifiers(getLongWithNull(target));
    }
    /**
     * Gets all the attributes of a creature.
     * @param target        the creature
     * @return an array of attribute values, or null on error; use the proper attribute id as an index into the array to get a specific attribute
     */
    private static native attribute[] _getAttribs(long target);
    public static attribute[] getAttribs(obj_id target)
    {
        return _getAttribs(getLongWithNull(target));
    }
    /**
     * Gets all the unmodified attributes of a creature.
     * @param target        the creature
     * @return an array of attribute values, or null on error; use the proper attribute id as an index into the array to get a specific attribute
     */
    private static native attribute[] _getUnmodifiedAttribs(long target);
    public static attribute[] getUnmodifiedAttribs(obj_id target)
    {
        return _getUnmodifiedAttribs(getLongWithNull(target));
    }
    /**
     * Gets all the max attributes of a creature.
     * @param target        the creature
     * @return an array of max attribute values, or null on error; use the proper attribute id as an index into the array to get a specific attribute
     */
    private static native attribute[] _getMaxAttribs(long target);
    public static attribute[] getMaxAttribs(obj_id target)
    {
        return _getMaxAttribs(getLongWithNull(target));
    }
    /**
     * Gets all the max attributes of a creature, modified by wounds.
     * @param target        the creature
     * @return an array of max attribute values, or null on error; use the proper attribute id as an index into the array to get a specific attribute
     */
    private static native attribute[] _getWoundedMaxAttribs(long target);
    public static attribute[] getWoundedMaxAttribs(obj_id target)
    {
        return _getWoundedMaxAttribs(getLongWithNull(target));
    }
    /**
     * Gets all the unmodified max attributes of a creature.
     * @param target        the creature
     * @return an array of max attribute values, or null on error; use the proper attribute id as an index into the array to get a specific attribute
     */
    private static native attribute[] _getUnmodifiedMaxAttribs(long target);
    public static attribute[] getUnmodifiedMaxAttribs(obj_id target)
    {
        return _getUnmodifiedMaxAttribs(getLongWithNull(target));
    }
    /**
     * Sets the attributes of a creature.
     * @param target        the creature
     * @param values        array of attribute values to set
     * @return true on success, false on fail
     */
    private static native boolean _setAttribs(long target, attribute[] values);
    public static boolean setAttribs(obj_id target, attribute[] values)
    {
        return _setAttribs(getLongWithNull(target), values);
    }
    /**
     * Sets the max attributes of a creature.
     * @param target        the creature
     * @param values        array of max attribute values to set
     * @return true on success, false on fail
     */
    private static native boolean _setMaxAttribs(long target, attribute[] values);
    public static boolean setMaxAttribs(obj_id target, attribute[] values)
    {
        return _setMaxAttribs(getLongWithNull(target), values);
    }
    /**
     * Adds deltas to the attributes of an creature.
     * @param target        the creature
     * @param values        array of attribute values to set
     * @return true on success, false on fail
     */
    private static native boolean _addToAttribs(long target, attribute[] values);
    public static boolean addToAttribs(obj_id target, attribute[] values)
    {
        return _addToAttribs(getLongWithNull(target), values);
    }
    /**
     * Adds deltas to the max attributes of a creature.
     * @param target        the creature
     * @param values        array of max attribute values to set
     * @return true on success, false on fail
     */
    private static native boolean _addToMaxAttribs(long target, attribute[] values);
    public static boolean addToMaxAttribs(obj_id target, attribute[] values)
    {
        return _addToMaxAttribs(getLongWithNull(target), values);
    }
    /**
     * Gets the hitpoints of an object.
     * @param target        id of object
     * @return the object's hitpoints, or ATTRIB_ERROR on error
     */
    private static native int _getHitpoints(long target);
    public static int getHitpoints(obj_id target)
    {
        return _getHitpoints(getLongWithNull(target));
    }
    /**
     * Gets the max hitpoints of an object.
     * @param target        id of object
     * @return the object's max hitpoints, or ATTRIB_ERROR on error
     */
    private static native int _getMaxHitpoints(long target);
    public static int getMaxHitpoints(obj_id target)
    {
        return _getMaxHitpoints(getLongWithNull(target));
    }
    /**
     * Gets the total hitpoints of an object, including component hitpoints.
     * @param target        id of object
     * @return the object's total hitpoints, or ATTRIB_ERROR on error
     */
    private static native int _getTotalHitpoints(long target);
    public static int getTotalHitpoints(obj_id target)
    {
        return _getTotalHitpoints(getLongWithNull(target));
    }
    /**
     * Sets the hitpoints of an object. Note that is this is used to damage an
     * object it will bypass the object's armor!
     * @param target        id of object
     * @param hitPoints     the hitpoints to set
     * @return true on success, false on fail
     */
    private static native boolean _setHitpoints(long target, int hitPoints);
    public static boolean setHitpoints(obj_id target, int hitPoints)
    {
        return _setHitpoints(getLongWithNull(target), hitPoints);
    }
    /**
     * Sets the hitpoints of an object, ignoring the invulnerable flag of the object.
     * Note that is this is used to damage an object it will bypass the object's armor!
     * @param target        id of object
     * @param hitPoints     the hitpoints to set
     * @return true on success, false on fail
     */
    private static native boolean _setInvulnerableHitpoints(long target, int hitPoints);
    public static boolean setInvulnerableHitpoints(obj_id target, int hitPoints)
    {
        return _setInvulnerableHitpoints(getLongWithNull(target), hitPoints);
    }
    /**
     * Sets the max hitpoints of an object.
     * @param target        id of object
     * @param hitPoints     the hitpoints to set
     * @return true on success, false on fail
     */
    private static native boolean _setMaxHitpoints(long target, int hitPoints);
    public static boolean setMaxHitpoints(obj_id target, int hitPoints)
    {
        return _setMaxHitpoints(getLongWithNull(target), hitPoints);
    }

    /**
     * Returns the shock wound value of a creature.
     *
     * @param target        id of creature
     *
     * @return the shock wound value, or ATTRIB_ERROR on error
     */
    private static native int _getShockWound(long target);
    public static int getShockWound(obj_id target)
    {
        return _getShockWound(getLongWithNull(target));
    }
    /**
     * Sets the shock wound value of a creature.
     *
     * @param target        id of creature
     * @param wound         the shock wound value
     *
     * @return true on success, false on fail
     */
    private static native boolean _setShockWound(long target, int wound);
    public static boolean setShockWound(obj_id target, int wound)
    {
        return _setShockWound(getLongWithNull(target), wound);
    }
    /**
     * Adds to the shock wound value of a creature.
     *
     * @param target        id of creature
     * @param wound         the amount to add
     *
     * @return true on success, false on fail
     */
    private static native boolean _addShockWound(long target, int wound);
    public static boolean addShockWound(obj_id target, int wound)
    {
        return _addShockWound(getLongWithNull(target), wound);
    }
    /**
     * Heals the shock wound value of a creature.
     *
     * @param target        id of creature
     * @param value         the amount to heal
     *
     * @return true on success, false on fail
     */
    private static native boolean _healShockWound(long target, int value);
    public static boolean healShockWound(obj_id target, int value)
    {
        return _healShockWound(getLongWithNull(target), value);
    }

    /**
     * Drains a creature's action and/or mind.
     * @param target        creature we want to drain
     * @param action        amount to drain the creature's action
     * @param mind          amount to drain the creature's mind
     * @return true on success, false on fail
     */
    private static native boolean _drainAttributes(long target, int action, int mind);
    public static boolean drainAttributes(obj_id target, int action, int mind)
    {
        return _drainAttributes(getLongWithNull(target), action, mind);
    }

    /**
     * Determines how much a creature's attributes would be drained.
     * @param target        creature we want to drain
     * @param attribute     the attribute to test (ACTION, MIND only)
     * @param value         the amount to drain the sa by
     * @return the amount the sa would be drained by, or -1 on error
     */
    private static native int _testDrainAttribute(long target, int attribute, int value);
    public static int testDrainAttribute(obj_id target, int attribute, int value)
    {
        return _testDrainAttribute(getLongWithNull(target), attribute, value);
    }

	public static float getHealthRegenRate(obj_id target)
	{
		return getRegenRate(target, HEALTH);
	}

	public static float getActionRegenRate(obj_id target)
	{
		return getRegenRate(target, ACTION);
	}

	public static float getMindRegenRate(obj_id target)
	{
		return getRegenRate(target, MIND);
	}

	public static void getHealthRegenRate(obj_id target, float rate)
	{
		setRegenRate(target, HEALTH, rate);
	}

	public static void getActionRegenRate(obj_id target, float rate)
	{
		setRegenRate(target, ACTION, rate);
	}

	public static void getMindRegenRate(obj_id target, float rate)
	{
		setRegenRate(target, MIND, rate);
	}

	/**
 	* Returns the regeneration rate of the attribute of a creature.
 	* @param target		player to send the info to
 	* @param attrib		index of the attrib to get (health, action, mind)
 	* @return the regeneration rate, in units/sec
 	*/
	public static float getRegenRate(obj_id target, int attrib)
	{
		return _getRegenRate(getLongWithNull(target), attrib);
	}
	private static native float _getRegenRate(long target, int attrib);

	/**
 	* Sets the regeneration rate of the attribute of a creature.
 	* @param target		player to send the info to
 	* @param attrib		index of the attrib to set (health, action, mind)
 	* @param rate 		the regen rate, in units/sec
 	*/
	public static void setRegenRate(obj_id target, int attrib, float rate)
	{
		_setRegenRate(getLongWithNull(target), attrib, rate);
	}
	private static native void _setRegenRate(long target, int attrib, float rate);

    /**
     * Returns the maximum force power of a creature.
     * @param target        the creature who's power to get
     * @return the max force power
     */
    private static native int _getMaxForcePower(long target);
    public static int getMaxForcePower(obj_id target)
    {
        return _getMaxForcePower(getLongWithNull(target));
    }
    /**
     * Sets the maximum force power of a creature.
     * @param target        the creature who's power to set
     * @param value         the new maximum force power value
     * @return true on success, false if the target isn't a creature
     */
    private static native boolean _setMaxForcePower(long target, int value);
    public static boolean setMaxForcePower(obj_id target, int value)
    {
        return _setMaxForcePower(getLongWithNull(target), value);
    }
    /**
     * Changes the maximum force power of a creature.
     * @param target        the creature who's power to change
     * @param value         the value to add to the creature's maximum force power
     * @return true on success, false if the target isn't a creature
     */
    private static native boolean _alterMaxForcePower(long target, int delta);
    public static boolean alterMaxForcePower(obj_id target, int delta)
    {
        return _alterMaxForcePower(getLongWithNull(target), delta);
    }
    /**
     * Returns the force power of a creature.
     * @param target        the creature who's power to get
     * @return the force power
     */
    private static native int _getForcePower(long target);
    public static int getForcePower(obj_id target)
    {
        return _getForcePower(getLongWithNull(target));
    }
    /**
     * Sets the force power of a creature.
     * @param target        the creature who's power to set
     * @param value         the new force power value
     * @return true on success, false if the target isn't a creature
     */
    private static native boolean _setForcePower(long target, int value);
    public static boolean setForcePower(obj_id target, int value)
    {
        return _setForcePower(getLongWithNull(target), value);
    }
    /**
     * Changes the force power of a creature.
     * @param target        the creature who's power to change
     * @param value         the value to add to the creature's force power
     * @return true on success, false if the target isn't a creature
     */
    private static native boolean _alterForcePower(long target, int delta);
    public static boolean alterForcePower(obj_id target, int delta)
    {
        return _alterForcePower(getLongWithNull(target), delta);
    }
    /**
     * Returns the regeneration rate for the force power of a creature.
     * @param target        the creature who's regen rate to get
     * @return the regen rate, in units/sec
     */
    private static native float _getForcePowerRegenRate(long target);
    public static float getForcePowerRegenRate(obj_id target)
    {
        return _getForcePowerRegenRate(getLongWithNull(target));
    }
    /**
     * Sets the regeneration rate for the force power of a creature.
     * @param target        the creature who's regen rate to set
     * @param rate          the regen rate, in units/sec
     * @return true on success, false if the target wasn't a creature
     */
    private static native boolean _setForcePowerRegenRate(long target, float rate);
    public static boolean setForcePowerRegenRate(obj_id target, float rate)
    {
        return _setForcePowerRegenRate(getLongWithNull(target), rate);
    }
    /**
     * Sends a message to a player telling the ui to add a mod icon for a given
     * amount of time. The name passed to this function should be from the visible
     * attrib mod datatable.
     * @param target        player to send the info to
     * @param modName       the mod datatable entry name for the icon to show
     * @param time          how long to show the icon (<0 = indefinite)
     * @return true on success, false on error
     */
    private static native boolean _addBuffIcon(long target, String modName, float time);
    public static boolean addBuffIcon(obj_id target, String modName, float time)
    {
        return _addBuffIcon(getLongWithNull(target), modName, time);
    }
    /**
     * Sends a message to a player telling the ui to remove a mod icon. The name
     * passed to this function should be from the visible attrib mod datatable.
     * @param target        player to send the info to
     * @param modName       the mod datatable entry name for the icon to show
     * @return true on success, false on error
     */
    private static native boolean _clearBuffIcon(long target, String modName);
    public static boolean clearBuffIcon(obj_id target, String modName)
    {
        return _clearBuffIcon(getLongWithNull(target), modName);
    }
/*@} attributeMethods */

    /**
     * @defgroup mentalStateMethods Methods used for querying and setting mental states and targetted mental states.
     * @{
     */

    /**
     * Get the mental state of an creature
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @return The current mental state of the creature
     */
    private static native float _getMentalState(long creature, int state);
    public static float getMentalState(obj_id creature, int state)
    {
        return _getMentalState(getLongWithNull(creature), state);
    }
    /**
     * Gets the maximum mental state for a creature.
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @return The maximum mental state of the creature.
     */
    private static native float _getMaxMentalState(long creature, int state);
    public static float getMaxMentalState(obj_id creature, int state)
    {
        return _getMaxMentalState(getLongWithNull(creature), state);
    }
    /**
     * Gets the decay time (in seconds) of the mental state.
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @return The time in seconds for the mental state to decay to the baseline.
     */
    private static native float _getMentalStateDecay(long creature, int state);
    public static float getMentalStateDecay(obj_id creature, int state)
    {
        return _getMentalStateDecay(getLongWithNull(creature), state);
    }
    /**
     * Sets the mental state for the creature.  If you attempt to set a value
     * higher than the maximum or lower than zero it will be clipped.
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @param value The new value of the mental state
     * @return A success code
     */
    private static native boolean _setMentalState(long creature, int state, float value);
    public static boolean setMentalState(obj_id creature, int state, float value)
    {
        return _setMentalState(getLongWithNull(creature), state, value);
    }
    /**
     * Sets the mental state decay for a creature.
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @param value The new decay value
     * @return A success code
     */
    private static native boolean _setMentalStateDecay(long creature, int state, float value);
    public static boolean setMentalStateDecay(obj_id creature, int state, float value)
    {
        return _setMentalStateDecay(getLongWithNull(creature), state, value);
    }
    /**
     * Adds to the mental state value for a creature.  If the new value is below zero or
     * above the maximum it will be clipped.
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @param value The amount to add to the mental state.
     * @return A success code
     */
    private static native boolean _addToMentalState(long creature, int state, float value);
    public static boolean addToMentalState(obj_id creature, int state, float value)
    {
        return _addToMentalState(getLongWithNull(creature), state, value);
    }
    /**
     * Adds a time-decaying mental state modifier to a creature. Mental state modifiers can
     * cause a mental state to go beyond it's set maximum value or below zero.
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @param value The amount to add to the mental state.
     * @param duration The time to hold the mental state.  This does not include attack and decay time.
     * @param attackTime The time before the modifier is fully active.
     * @param decayTime The time for the modifier to decay to zero.
     * @return A success code
     */
    private static native boolean _addMentalStateModifier(long creature, int state, float value, float duration, float attackTime, float decayTime);
    public static boolean addMentalStateModifier(obj_id creature, int state, float value, float duration, float attackTime, float decayTime)
    {
        return _addMentalStateModifier(getLongWithNull(creature), state, value, duration, attackTime, decayTime);
    }
    /**
     * Gets a list of the mental state modifiers currently active on a creature.
     *
     * @param creature The ID of the creature
     * @param state The index of the mental state to get
     * @return The list of modifiers or null if there is an error.
     */
    private static native mental_state_mod[] _getMentalStateModifiers(long creature, int state);
    public static mental_state_mod[] getMentalStateModifiers(obj_id creature, int state)
    {
        return _getMentalStateModifiers(getLongWithNull(creature), state);
    }
    /**
     * Gets a complete list of mental states for a creature.
     *
     * @param creature The ID of the creature
     * @return The list of mental states or null if there is an error.
     */
    private static native mental_state[] _getMentalStates(long creature);
    public static mental_state[] getMentalStates(obj_id creature)
    {
        return _getMentalStates(getLongWithNull(creature));
    }
    /**
     * Gets a complete list of the maximum mental states for a creature.
     *
     * @param creature The ID of the creature
     * @return The list of mental states or null if there is an error.
     */
    private static native mental_state[] _getMaxMentalStates(long creature);
    public static mental_state[] getMaxMentalStates(obj_id creature)
    {
        return _getMaxMentalStates(getLongWithNull(creature));
    }
    /**
     * Sets a number of mental states for a creature.
     *
     * @param creature The ID of the creature
     * @param values The mental states to set
     * @return a success indicator
     */
    private static native boolean _setMentalStates(long creature, mental_state[] values);
    public static boolean setMentalStates(obj_id creature, mental_state[] values)
    {
        return _setMentalStates(getLongWithNull(creature), values);
    }
    /**
     * Adds to a number of mental states for a creature.
     *
     * @param creature The ID of the creature
     * @param values The mental states to add
     * @return a success indicator
     */
    private static native boolean _addToMentalStates(long creature, mental_state[] values);
    public static boolean addToMentalStates(obj_id creature, mental_state[] values)
    {
        return _addToMentalStates(getLongWithNull(creature), values);
    }

    /**
     * Gets the mental state toward another creature.  The returned mental state is the
     * sum of the creatures base mental state and the targetted mental state.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The mental state to get
     * @return The mental state toward the creature.
     */
    private static native float _getMentalStateToward(long creature, long target, int state);
    public static float getMentalStateToward(obj_id creature, obj_id target, int state)
    {
        return _getMentalStateToward(getLongWithNull(creature), getLongWithNull(target), state);
    }
    /**
     * Sets the mental state toward another creature.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The mental state to set
     * @param value The new value of the mental state.
     * @return a success code
     */
    private static native boolean _setMentalStateToward(long creature, long target, int state, float value);
    public static boolean setMentalStateToward(obj_id creature, obj_id target, int state, float value)
    {
        return _setMentalStateToward(getLongWithNull(creature), getLongWithNull(target), state, value);
    }
    /**
     * Sets the mental state toward another creature.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The mental state to set
     * @param value The new value of the mental state.
     * @return a success code
     */
    private static native boolean _setMentalStateToward(long creature, long target, int state, float value, int behavior);
    public static boolean setMentalStateToward(obj_id creature, obj_id target, int state, float value, int behavior)
    {
        return _setMentalStateToward(getLongWithNull(creature), getLongWithNull(target), state, value, behavior);
    }
    /**
     * Adds to the targetted mental state toward another creature.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The mental state to set
     * @param value The value to add
     * @return a success code
     */
    private static native boolean _addToMentalStateToward(long creature, long target, int state, float value);
    public static boolean addToMentalStateToward(obj_id creature, obj_id target, int state, float value)
    {
        return _addToMentalStateToward(getLongWithNull(creature), getLongWithNull(target), state, value);
    }
    /**
     * Adds to the targetted mental state toward another creature, preventing the creature from transitioning past a certain behavior.
     * Adding a negative value does no behavior clipping.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The mental state to set
     * @param value The value to add
     * @param behavior The behavior beyond which the addition will not take you.
     * @return a success code
     */
    private static native boolean _addToMentalStateToward(long creature, long target, int state, float value, int behavior);
    public static boolean addToMentalStateToward(obj_id creature, obj_id target, int state, float value, int behavior)
    {
        return _addToMentalStateToward(getLongWithNull(creature), getLongWithNull(target), state, value, behavior);
    }
    /**
     * Adds a mental state modifier toward another creature.  NOT IMPLEMENTED.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The index of the mental state to get
     * @param value The amount to add to the mental state.
     * @param duration The time to hold the mental state.  This does not include attack and decay time.
     * @param attackTime The time before the modifier is fully active.
     * @param decayTime The time for the modifier to decay to zero.
     * @return a success code
     */
    private static native boolean _addMentalStateModifierToward(long creature, long target, int state, float value, float duration, float attackRate, float decayRate);
    public static boolean addMentalStateModifierToward(obj_id creature, obj_id target, int state, float value, float duration, float attackRate, float decayRate)
    {
        return _addMentalStateModifierToward(getLongWithNull(creature), getLongWithNull(target), state, value, duration, attackRate, decayRate);
    }
    /**
     * Gets the mental state modifiers toward another creature.  NOT IMPLEMENTED.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The mental state to fetch modifiers for.
     * @return an array of mental state modifiers, or null if there is an error
     */
    private static native mental_state_mod[] _getMentalStateModifiersToward(long creature, long target, int state);
    public static mental_state_mod[] getMentalStateModifiersToward(obj_id creature, obj_id target, int state)
    {
        return _getMentalStateModifiersToward(getLongWithNull(creature), getLongWithNull(target), state);
    }
    /**
     * Gets the mental states toward another creature
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @return an array of mental states or null if there is an error
     */
    private static native mental_state[] _getMentalStatesToward(long creature, long target);
    public static mental_state[] getMentalStatesToward(obj_id creature, obj_id target)
    {
        return _getMentalStatesToward(getLongWithNull(creature), getLongWithNull(target));
    }
    /**
     * Sets a number of  mental states toward another creature.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param values The mental states to set
     * @return a success code
     */
    private static native boolean _setMentalStatesToward(long creature, long target, mental_state[] values);
    public static boolean setMentalStatesToward(obj_id creature, obj_id target, mental_state[] values)
    {
        return _setMentalStatesToward(getLongWithNull(creature), getLongWithNull(target), values);
    }
    /**
     * Sets the mental state toward another creature.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param values The mental states to add
     * @return a success code
     */
    private static native boolean _addToMentalStatesToward(long creature, long target, mental_state[] values);
    public static boolean addToMentalStatesToward(obj_id creature, obj_id target, mental_state[] values)
    {
        return _addToMentalStatesToward(getLongWithNull(creature), getLongWithNull(target), values);
    }

    /**
     * Sets the mental state toward a list of other creatures.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param targets The IDs of the target creatures
     * @param state The mental state to set
     * @param value The new value of the mental state.
     * @return a success code
     */
    private static native boolean _setMentalStateToward(long creature, long[] target, int state, float value);
    public static boolean setMentalStateToward(obj_id creature, obj_id[] target, int state, float value)
    {
        long[] _target = null;
        if (target != null)
        {
            _target = new long[target.length];
            for (int _i = 0; _i < target.length; ++_i)
                _target[_i] = getLongWithNull(target[_i]);
        }
        return _setMentalStateToward(getLongWithNull(creature), _target, state, value);
    }
    /**
     * Adds to the targetted mental state toward a list of other creatures.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param targets The IDs of the target creatures
     * @param state The mental state to set
     * @param value The value to add
     * @return a success code
     */
    private static native boolean _addToMentalStateToward(long creature, long[] target, int state, float value);
    public static boolean addToMentalStateToward(obj_id creature, obj_id[] target, int state, float value)
    {
        long[] _target = null;
        if (target != null)
        {
            _target = new long[target.length];
            for (int _i = 0; _i < target.length; ++_i)
                _target[_i] = getLongWithNull(target[_i]);
        }
        return _addToMentalStateToward(getLongWithNull(creature), _target, state, value);
    }
    /**
     * Adds a mental state modifier towards a list of other creatures.  NOT IMPLEMENTED.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @param state The index of the mental state to get
     * @param value The amount to add to the mental state.
     * @param duration The time to hold the mental state.  This does not include attack and decay time.
     * @param attackTime The time before the modifier is fully active.
     * @param decayTime The time for the modifier to decay to zero.
     * @return a success code
     */
    private static native boolean _addMentalStateModifierToward(long creature, long[] target, int state, float value, float duration, float attackTime, float decayTime);
    public static boolean addMentalStateModifierToward(obj_id creature, obj_id[] target, int state, float value, float duration, float attackTime, float decayTime)
    {
        long[] _target = null;
        if (target != null)
        {
            _target = new long[target.length];
            for (int _i = 0; _i < target.length; ++_i)
                _target[_i] = getLongWithNull(target[_i]);
        }
        return _addMentalStateModifierToward(getLongWithNull(creature), _target, state, value, duration, attackTime, decayTime);
    }
    /**
     * Sets a number of  mental states toward a list of other creatures.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param targets The IDs of the target creatures
     * @param values The mental states to set
     * @return a success code
     */
    private static native boolean _setMentalStatesToward(long creature, long[] target, mental_state[] values);
    public static boolean setMentalStatesToward(obj_id creature, obj_id[] target, mental_state[] values)
    {
        long[] _target = null;
        if (target != null)
        {
            _target = new long[target.length];
            for (int _i = 0; _i < target.length; ++_i)
                _target[_i] = getLongWithNull(target[_i]);
        }
        return _setMentalStatesToward(getLongWithNull(creature), _target, values);
    }
    /**
     * Adds a number of targetted mental states toward a list of other creatures.  If the sum of the targetted and base
     * mental state would exceed the maximum, the targetted mental state is clipped.
     *
     * @param creature The ID of the creature
     * @param targets The IDs of the target creatures
     * @param value The mental states to add
     * @return a success code
     */
    private static native boolean _addToMentalStatesToward(long creature, long[] target, mental_state[] values);
    public static boolean addToMentalStatesToward(obj_id creature, obj_id[] target, mental_state[] values)
    {
        long[] _target = null;
        if (target != null)
        {
            _target = new long[target.length];
            for (int _i = 0; _i < target.length; ++_i)
                _target[_i] = getLongWithNull(target[_i]);
        }
        return _addToMentalStatesToward(getLongWithNull(creature), _target, values);
    }

    /**
     * Gets the creatures overall behavior.
     *
     * @param creature The ID of the creature
     * @return The behavior
     */
    private static native int _getBehavior(long creature);
    public static int getBehavior(obj_id creature)
    {
        return _getBehavior(getLongWithNull(creature));
    }
    /**
     * Gets the behavior toward a specific creature.
     *
     * @param creature The ID of the creature
     * @param target The ID of the target creature
     * @return The behavior
     */
    private static native int _getBehaviorToward(long creature, long target);
    public static int getBehaviorToward(obj_id creature, obj_id target)
    {
        return _getBehaviorToward(getLongWithNull(creature), getLongWithNull(target));
    }
    /**
     * Gets a list of creatures whom the creature has a behavior toward.
     *
     * @param creature The ID fo the creature
     * @param behavior The behavior to query
     * @return a list of creatures for the behavior, or null if there is an error.
     */
    private static native long[] _getBehaviorTargets(long creature, int behavior);
    public static obj_id[] getBehaviorTargets(obj_id creature, int behavior)
    {
        long[] _ret_long = _getBehaviorTargets(getLongWithNull(creature), behavior);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
     /// @}

    /**
     * @defgroup actionStates Methods to make the creature do smart looking stuff
     * @{
     */
    /**
     * Get the home location for the creature.
     *
     * @param creature The ID of the creature
     * @return The home location of the creature if it was set, otherwise the current location of the creature.
     */
    public static location getHomeLocation(obj_id ai)
    {
        return aiGetHomeLocation(ai);
    }
    /**
     * Sets the home location of the creature.
     *
     * @param creature The ID of the creature
     * @param loc The location of the creature
     */
    public static void setHomeLocation(obj_id ai, location homeLocation)
    {
        aiSetHomeLocation(ai, homeLocation);
    }
    /**
     * Sets the home location of the creature to the creature's current position.
     *
     * @param creature The ID of the creature.
     */
    public static void setHomeLocation(obj_id creature)
    {
        setHomeLocation(creature, getLocation(creature));
    }
    /**
     * Tells the engine that this creature will not move.
     *
     * @param creature the creature to become static
     * @param value true if the creature will not move.
     *
     */
    private static native void _setCreatureStatic(long creature, boolean value);
    public static void setCreatureStatic(obj_id creature, boolean value)
    {
        _setCreatureStatic(getLongWithNull(creature), value);
    }

    /**
     * Stop the creature from moving.  It will still receive script triggers but will not move.
     *
     * @param creature The ID of the creature.
     */
    private static native void _stop(long ai);
    public static void stop(obj_id ai)
    {
        _stop(getLongWithNull(ai));
    }

    /**
     * Make the AI plot a path toward a destination.
     * This call may trigger: OnMoveMoving, OnMovePathComplete, and OnMovePathNotFound
     *
     * @param ai       The ID of the AI
     * @param target   The destination of the AI
     * @return nothing
     */
    private static native void _pathTo(long ai, location target);
    public static void pathTo(obj_id ai, location target)
    {
        _pathTo(getLongWithNull(ai), target);
    }

    /**
     * Make the AI plot a path toward a city path node with the given name.
     * This call may trigger: OnMoveMoving, OnMovePathComplete, and OnMovePathNotFound
     *
     * @param ai       The ID of the AI
     * @param target   The destination of the AI
     * @return nothing
     */
    private static native void _pathTo(long ai, String targetName);
    public static void pathTo(obj_id ai, String targetName)
    {
        _pathTo(getLongWithNull(ai), targetName);
    }

    /**
     * Causes an AI to move along a series of points. The ai will move along a list of points in order,
     * and when it gets to the last point, go to the first one and start over.
     * @param ai        	the AI to move
     * @param targets   	the points the AI will move along
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrol(obj_id ai, location[] targets)
    {
        patrol(ai, targets, 0);
    }
	public static void patrol(obj_id ai, location[] targets, int startPoint)
    {
        patrol(ai, targets, false, false, true, startPoint);
    }

    /**
     * Causes an AI to move along a series of points. The ai will move along a list of points in order,
     * and when it gets to the last point, stop.
     * @param ai        	the AI to move
     * @param targets   	the points the AI will move along
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrolOnce(obj_id ai, location[] targets)
    {
        patrolOnce(ai, targets, 0);
    }
	public static void patrolOnce(obj_id ai, location[] targets, int startPoint)
    {
        patrol(ai, targets, false, false, false, startPoint);
    }

    /**
     * Causes an AI to move along a series of points. The order of points it moves to will be random.
     * @param ai        the AI to move
     * @param targets   the points the AI will move along
     */
    public static void patrolRandom(obj_id ai, location[] targets)
    {
        patrol(ai, targets, true, false, true, 0);
    }

    /**
     * Causes an AI to move along a series of points. The order of points it moves to will be random. When all
     * the points have been moved to, it will stop.
     * @param ai        the AI to move
     * @param targets   the points the AI will move along
     */
	public static void patrolRandomOnce(obj_id ai, location[] targets)
    {
        patrol(ai, targets, true, false, false, 0);
    }

    /**
     * Causes an AI to move along a series of points. The points will be moved to in order, then in reverse order, then back again, etc.
     * @param ai        	the AI to move
     * @param targets   	the points the AI will move along
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrolFlip(obj_id ai, location[] targets)
    {
        patrolFlip(ai, targets, 0);
    }
	public static void patrolFlip(obj_id ai, location[] targets, int startPoint)
    {
        patrol(ai, targets, false, true, true, startPoint);
    }

    /**
     * Causes an AI to move along a series of points. The points will be moved to in order, then in reverse order.
     * @param ai        	the AI to move
     * @param targets   	the points the AI will move along
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrolFlipOnce(obj_id ai, location[] targets)
    {
        patrolFlipOnce(ai, targets, 0);
    }
	public static void patrolFlipOnce(obj_id ai, location[] targets, int startPoint)
    {
        patrol(ai, targets, false, true, false, startPoint);
    }

    /**
     * Causes an AI to move along a series of points.
     * @param ai        	the AI to move
     * @param targets   	the points the AI will move along
     * @param random    	flag to tell the AI to choose a random target to move to next, instead of the next one in the targets array
     * @param flip      	if true, when the AI gets to the last point in the targets array, it will then go along them in reverse order
     * @param repeat    	if true, the AI will go back to the first point after reaching the last one; if false, the ai will stop at the last point
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrol(obj_id ai, location[] targets, boolean random, boolean flip, boolean repeat)
    {
        patrol(ai, targets, random, flip, repeat, 0);
    }
	public static void patrol(obj_id ai, location[] targets, boolean random, boolean flip, boolean repeat, int startPoint)
    {
        _patrol(getLongWithNull(ai), targets, random, flip, repeat, 0);
    }
    private static native void _patrol(long ai, location[] targets, boolean random, boolean flip, boolean repeat, int startPoint);

    /**
     * Causes an AI to move along a series of points. The ai will move along a list of points in order,
     * and when it gets to the last point, go to the first one and start over.
     * @param ai            the AI to move
     * @param targetNames   the points the AI will move along; the ai will go along each target in the array in order,
     *                      and then start over from the beginning
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrol(obj_id ai, String[] targetNames)
    {
        patrol(ai, targetNames, 0);
    }
	public static void patrol(obj_id ai, String[] targetNames, int startPoint)
    {
        patrol(ai, targetNames, false, false, true, startPoint);
    }

    /**
     * Causes an AI to move along a series of points. The ai will move along a list of points in order,
     * and when it gets to the last point, stop.
     * @param ai            the AI to move
     * @param targetNames   the points the AI will move along; the ai will go along each target in the array in order,
     *                      and then start over from the beginning
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrolOnce(obj_id ai, String[] targetNames)
    {
        patrolOnce(ai, targetNames, 0);
    }
	public static void patrolOnce(obj_id ai, String[] targetNames, int startPoint)
    {
        patrol(ai, targetNames, false, false, false, startPoint);
    }

    /**
     * Causes an AI to move along a series of points. The order of points it moves to will be random.
     * @param ai        the AI to move
     * @param targets   the waypoint names the AI will move along
     * @param random    flag to tell the AI to choose a random target to move to next, instead of the next one in the targets array
     */
    public static void patrolRandom(obj_id ai, String[] targetNames)
    {
        patrol(ai, targetNames, true, false, true);
    }

    /**
     * Causes an AI to move along a series of points. The order of points it moves to will be random. When all
     * the points have been moved to, it will stop.
     * @param ai        the AI to move
     * @param targets   the waypoint names the AI will move along
     * @param random    flag to tell the AI to choose a random target to move to next, instead of the next one in the targets array
     */
    public static void patrolRandomOnce(obj_id ai, String[] targetNames)
    {
        patrol(ai, targetNames, true, false, false);
    }

    /**
     * Causes an AI to move along a series of points. The points will be moved to in order, then in reverse order, then back again, etc.
     * @param ai        	the AI to move
     * @param targets   	the points the AI will move along
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrolFlip(obj_id ai, String[] targetNames)
    {
        patrolFlip(ai, targetNames, 0);
    }
	public static void patrolFlip(obj_id ai, String[] targetNames, int startPoint)
    {
        patrol(ai, targetNames, false, true, true, startPoint);
    }

    /**
     * Causes an AI to move along a series of points. The points will be moved to in order, then in reverse order.
     * @param ai        	the AI to move
     * @param targets   	the points the AI will move along
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrolFlipOnce(obj_id ai, String[] targetNames)
    {
        patrolFlipOnce(ai, targetNames, 0);
    }
	public static void patrolFlipOnce(obj_id ai, String[] targetNames, int startPoint)
    {
        patrol(ai, targetNames, false, true, false, startPoint);
    }

    /**
     * Causes an AI to move along a series of points.
     * @param ai        	the AI to move
     * @param targets   	the waypoint names the AI will move along
     * @param random    	flag to tell the AI to choose a random target to move to next, instead of the next one in the targets array
     * @param flip      	if true, when the AI gets to the last point in the targets array, it will then go along them in reverse order
     * @param repeat    	if true, the AI will go back to the first point after reaching the last one; if false, the ai will stop at the last point
	 * @param startPoint    optional point to start the patrol at
     */
    public static void patrol(obj_id ai, String[] targetNames, boolean random, boolean flip, boolean repeat)
    {
        patrol(ai, targetNames, random, flip, repeat, 0);
    }
	public static void patrol(obj_id ai, String[] targetNames, boolean random, boolean flip, boolean repeat, int startPoint)
    {
        _patrol(getLongWithNull(ai), targetNames, random, flip, repeat, startPoint);
    }
    private static native void _patrol(long ai, String[] targetNames, boolean random, boolean flip, boolean repeat, int startPoint);

//  /**
    /**
     * Makes the creature loiter around an indicated anchorLocation.
     * The creature will wait a period of time between each leg of it's loitering.
     * minDelay can be less than zero; if a random delay is picked that is less than zero
     * no waiting will occur.
     * Does not reset the saved loiter target.
     * It is an error for minDistance to be greater than maxDistance.
     * It is an error for minDistance to be less than zero.
     * This call may trigger OnLoiterMoving, OnLoiterWaiting, OnLoiterWaypoint, and OnLoiterPathNotFound.
     *
     * @param creature The ID of the creature
     * @param anchorLocation The position to loiter around
     * @param minDistance The creature will attempt to stay this distance from the location
     * @param maxDistance The creature will attempt to stay within this distance of the location.
     * @param minDelay The minimum duration to wait
     * @param maxDelay The maximum duration to wait
     * @return a success code
     */

    private static native void _loiterTarget(long ai, long target, float minDistance, float maxDistance, float minDelay, float maxDelay);
    public static void loiterTarget(obj_id ai, obj_id target, float minDistance, float maxDistance, float minDelay, float maxDelay)
    {
        _loiterTarget(getLongWithNull(ai), getLongWithNull(target), minDistance, maxDistance, minDelay, maxDelay);
    }

    private static native void _loiterLocation(long ai, location anchorLocation, float minDistance, float maxDistance, float minDelay, float maxDelay);
    public static void loiterLocation(obj_id ai, location anchorLocation, float minDistance, float maxDistance, float minDelay, float maxDelay)
    {
        _loiterLocation(getLongWithNull(ai), anchorLocation, minDistance, maxDistance, minDelay, maxDelay);
    }

    /**
     * Makes the creature wander around.
     * He will choose a leg at any point within the loiter range and pathfind to it.
     * He will not pause between legs.
     * There is no restriction on the angle he turns between legs.
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @return a success code
     */
    public static boolean wander(obj_id creature)
    {
        return wanderAngleDelay(creature, getWanderRangeMin(creature), getWanderRangeMax(creature), getWanderAngleMin(creature), getWanderAngleMax(creature), getWanderDelayMin(creature), getWanderDelayMax(creature));
    }
    /**
     * Makes the creature wander around.
     * He will choose a random length leg in the indicated range.  maxDist must be greater and minDist, and minDist must be greater than zero.
     * He will not pause between legs.
     * There is no restriction on the angle he turns between legs.
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @param minDist The minimum length of a leg
     * @param maxDist The maximum length of a leg
     * @return a success code
     */
    public static boolean wander(obj_id creature, float minDist, float maxDist)
    {
        return wanderAngleDelay(creature, minDist, maxDist, getWanderAngleMin(creature), getWanderAngleMax(creature), getWanderDelayMin(creature), getWanderDelayMax(creature));
    }
    /**
     * Makes the creature wander around.
     * He will choose a leg at any point within the loiter range and pathfind to it.
     * He will not pause between legs.
     * He will turn either left or right a random number of degrees after each leg (between minAngle and maxAngle degrees)
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @param minDist The minimum length of a leg
     * @param maxDist The maximum length of a leg
     * @return a success code
     */
    public static boolean wanderAngle(obj_id creature, float minAngle, float maxAngle)
    {
        return wanderAngleDelay(creature, getWanderRangeMin(creature), getWanderRangeMax(creature), minAngle, maxAngle, getWanderDelayMin(creature), getWanderDelayMax(creature));
    }
    /**
     * Makes the creature wander around.
     * He will choose a random length leg in the indicated range.  maxDist must be greater and minDist, and minDist must be greater than zero.
     * He will not pause between legs.
     * He will turn either left or right a random number of degrees after each leg (between minAngle and maxAngle degrees)
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @param minDist The minimum length of a leg
     * @param maxDist The maximum length of a leg
     * @return a success code
     */
    public static boolean wanderAngle(obj_id creature, float minDistance, float maxDistance, float minAngle, float maxAngle)
    {
        return wanderAngleDelay(creature, minDistance, maxDistance, minAngle, maxAngle, getWanderDelayMin(creature), getWanderDelayMax(creature));
    }
    /**
     * Makes the creature wander around.
     * He will choose a leg at any point within the loiter range and pathfind to it.
     * The creature will wait a period of time between each leg of it's loitering.
     * minDelay can be less than zero; if a random delay is picked that is less than zero
     * no waiting will occur.
     * There is no restriction on the angle he turns between legs.
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @param minDelay The minimum amount of time to wait after each leg.
     * @param maxDelay The maximum amount of time to wait after each leg.
     * @return a success code
     */
    public static boolean wanderDelay(obj_id creature, float minDelay, float maxDelay)
    {
        return wanderAngleDelay(creature, getWanderRangeMin(creature), getWanderRangeMax(creature), getWanderAngleMin(creature), getWanderAngleMax(creature), minDelay, maxDelay);
    }
    /**
     * Makes the creature wander around.
     * He will choose a random length leg in the indicated range.  maxDist must be greater and minDist, and minDist must be greater than zero.
     * The creature will wait a period of time between each leg of it's loitering.
     * minDelay can be less than zero; if a random delay is picked that is less than zero
     * no waiting will occur.
     * There is no restriction on the angle he turns between legs.
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @param minDist The minimum length of a leg
     * @param maxDist The maximum length of a leg
     * @return a success code
     */
    public static boolean wanderDelay(obj_id creature, float minDist, float maxDist, float minDelay, float maxDelay)
    {
        return wanderAngleDelay(creature, minDist, maxDist, getWanderAngleMin(creature), getWanderAngleMax(creature), minDelay, maxDelay);
    }
    /**
     * Makes the creature wander around.
     * He will choose a leg at any point within the loiter range and pathfind to it.
     * The creature will wait a period of time between each leg of it's loitering.
     * minDelay can be less than zero; if a random delay is picked that is less than zero
     * no waiting will occur.
     * He will turn either left or right a random number of degrees after each leg (between minAngle and maxAngle degrees)
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @param minDist The minimum length of a leg
     * @param maxDist The maximum length of a leg
     * @return a success code
     */
    public static boolean wanderAngleDelay(obj_id creature, float minAngle, float maxAngle, float minDelay, float maxDelay)
    {
        return wanderAngleDelay(creature, getWanderRangeMin(creature), getWanderRangeMax(creature), minAngle, maxAngle, minDelay, maxDelay);
    }
    /**
     * Makes the creature wander around.
     * He will choose a random length leg in the indicated range.  maxDist must be greater and minDist, and minDist must be greater than zero.
     * The creature will wait a period of time between each leg of it's loitering.
     * minDelay can be less than zero; if a random delay is picked that is less than zero
     * no waiting will occur.
     * He will turn either left or right a random number of degrees after each leg (between minAngle and maxAngle degrees)
     * This call may trigger OnWanderMoving, OnWanderWaiting, OnWanderWaypoint, and OnWanderPathNotFound.
     *
     * @param creature The ID of the creature.
     * @param minDist The minimum length of a leg
     * @param maxDist The maximum length of a leg
     * @return a success code
     */
    private static native boolean _wanderAngleDelay(long creature, float minDist, float maxDist, float minAngle, float maxAngle, float minDelay, float maxDelay);
    public static boolean wanderAngleDelay(obj_id creature, float minDist, float maxDist, float minAngle, float maxAngle, float minDelay, float maxDelay)
    {
        return _wanderAngleDelay(getLongWithNull(creature), minDist, maxDist, minAngle, maxAngle, minDelay, maxDelay);
    }

    /**
     * Makes the creature flee another creature, reevaluating his path at specified intervals.
     * This call may trigger OnFleeWaypoint, OnFleeTargetLost, and OnFleePathNotFound
     *
     * @param creature The ID of the fleeing creature
     * @param target The ID of the fearsome oppressor
     * @param minDistance The minimum length of a leg
     * @param maxDistance The maximum length of a leg
     * @return a success code
     */
    private static native boolean _flee(long creature, long target, float minDistance, float maxDistance);
    public static boolean flee(obj_id creature, obj_id target, float minDistance, float maxDistance)
    {
        return _flee(getLongWithNull(creature), getLongWithNull(target), minDistance, maxDistance);
    }

	/**
	 * Sets a delay on a creature before it goes into hibernation after being unobserved.
	 *
	 * @param creature		the creature to delay
	 * @param delay			time in secs to delay before putting the creature into hibernation
	 * @return true on success, false if the creature id isn't a creature
	 */
	private static native boolean _setHibernationDelay(long creature, float delay);
	public static boolean setHibernationDelay(obj_id creature, float delay)
	{
		return _setHibernationDelay(getLongWithNull(creature), delay);
	}

	/*@}*/
    /**
    * @defgroup nameMethods Name methods
    */
    /*@{*/


    /**
     * Changes the name of an object.
     * @param target    the object
     * @param name      the new name of the object
     * @return true on success, false on fail
     */
    private static native boolean _setName(long target, String name);
    public static boolean setName(obj_id target, String name)
    {
        return _setName(getLongWithNull(target), name);
    }
    /**
     * Changes the name of an object.
     * @param target    the object
     * @param nameId    the string_id giving the new name of the object
     * @return true on success, false on fail
     */
    private static native boolean _setName(long target, string_id nameId);
    public static boolean setName(obj_id target, string_id nameId)
    {
        return _setName(getLongWithNull(target), nameId);
    }

    /**
     * Changes the description of an object.
     * @param target    the object
     * @param descriptionId    the string_id giving the new description of the object
     * @return true on success, false on fail
     */
    private static native void _setDescriptionStringId(long target, string_id descriptionId);
    public static void setDescriptionStringId(obj_id target, string_id descriptionId)
    {
        _setDescriptionStringId(getLongWithNull(target), descriptionId);
    }

    /**
     * Returns the name of an object.
     * @param target        the object
     * @return the object's name, or null on error
     */
    private static native String _getName(long target);
    public static String getName(obj_id target)
    {
        return _getName(getLongWithNull(target));
    }

    /**
     * Returns the description of an object.
     * @param target        the object
     * @return the object's description, or null on error
     */
    private static native string_id _getDescriptionStringId(long target);
    public static string_id getDescriptionStringId(obj_id target)
    {
        return _getDescriptionStringId(getLongWithNull(target));
    }

    /**
     * Returns the base name of a player. The base name is the player's first name,
     * all lowercase. This function will work on an online or offline player.
     * @param player        the player
     * @return the player's base name, or null on error
     */
    private static native String _getPlayerName(long player);
    public static String getPlayerName(obj_id player)
    {
        return _getPlayerName(getLongWithNull(player));
    }

    /**
     * Returns the full name of a player. This function will work on an online or offline player.
     * @param player        the player
     * @return the player's full name, or null on error
     */
    private static native String _getPlayerFullName(long player);
    public static String getPlayerFullName(obj_id player)
    {
        return _getPlayerFullName(getLongWithNull(player));
    }

    /**
     * Returns the name of an object.
     * @param target        the object
     * @return the object's name, or null on error
     */
    private static native String _getAssignedName(long target);
    public static String getAssignedName(obj_id target)
    {
        return _getAssignedName(getLongWithNull(target));
    }

	/**
	 * Makes the creature follow another creature, trying to stay between minDistance and maxDistance from the target.
	 *
	 * @param creature The ID of the creature
	 * @param target The ID of the lovely and desirable object of affection or detraction.
	 * @param minDistance the minimum distance to be from the target
	 * @param maxDistance The maximum distance to be from the target
	 * @return a success code
	 */
	private static native boolean _follow(long creature, long target, float minDistance, float maxDistance);
	public static boolean follow(obj_id creature, obj_id target, float minDistance, float maxDistance)
	{
		return _follow(getLongWithNull(creature), getLongWithNull(target), minDistance, maxDistance);
	}
	/**
	 * Makes the creature follow another creature at an offset.
	 *
	 * @param creature The ID of the creature
	 * @param target The ID of the lovely and desirable object of affection or detraction.
	 * @return a success code
	 */
	private static native boolean _follow(long creature, long target, location offset);
	public static boolean follow(obj_id creature, obj_id target, location offset)
	{
		return _follow(getLongWithNull(creature), getLongWithNull(target), offset);
	}
	/**
	 * Makes the creature follow a creature without intersecting other creatures following the same one.
	 * The creatures will try and get as close as possible to the target creature.
	 *
	 * @param creature The ID of the creature
	 * @param target The ID of the lovely and desirable object of affection or detraction.
	 * @return a success code
	 */
	private static native boolean _swarm(long creature, long target);
	public static boolean swarm(obj_id creature, obj_id target)
	{
		return _swarm(getLongWithNull(creature), getLongWithNull(target));
	}
	/**
	 * Makes the creature follow a creature without intersecting other creatures following the same one.
	 *
	 * @param creature The ID of the creature
	 * @param target The ID of the lovely and desirable object of affection or detraction.
	 * @param offset The distance from the target to try and stay at
	 * @return a success code
	 */
	private static native boolean _swarm(long creature, long target, float offset);
	public static boolean swarm(obj_id creature, obj_id target, float offset)
	{
		return _swarm(getLongWithNull(creature), getLongWithNull(target), offset);
	}

	/**
 	 * Stops the current movement type of the creature, allowing it to be resumed at a
 	 * later time (via resumeMovement()).
 	 *
 	 * NOTE: Only one movement can be suspended at a time. If this function
 	 * is called while a previous movement is suspended, it will fail. Use
	 * hasSuspendedMovement() to check if a creature already has movment suspended.
 	 *
	 * @param mob		the creature whose moment to suspend
 	 * @return true if the movement has been suspended, false if not.
 	 */
	public static boolean suspendMovement(obj_id mob)
	{
		return _suspendMovement(getLongWithNull(mob));
	}
	private static native boolean _suspendMovement(long mob);
	/**
 	 * Resumes a previously suspended movement.
 	 *
	 * @param mob		the creature whose moment to resume
 	 * @return true if the movement was resumed, false if there was no previous movement.
 	 */
	public static boolean resumeMovement(obj_id mob)
	{
		return _resumeMovement(getLongWithNull(mob));
	}
	private static native boolean _resumeMovement(long mob);
	/**
 	 * Returns if a creature has movement suspended or not.
 	 *
	 * @param mob		the creature to test
 	 * @return true there is suspended movement, false if not
 	 */
	public static boolean hasSuspendedMovement(obj_id mob)
	{
		return _hasSuspendedMovement(getLongWithNull(mob));
	}
	private static native boolean _hasSuspendedMovement(long mob);

	/**
	 * Makes the creature stop floating
	 *
	 * @param creature The ID of the creature
	 * @return a success code
	 */
	private static native boolean _stopFloating(long creature);
	public static boolean stopFloating(obj_id creature)
	{
		return _stopFloating(getLongWithNull(creature));
	}
	/**
	 * Sets the amount of time a creature will float before snapping to the terrain
	 *
	 * @param creature The ID of the creature
	 * @param seconds The time the creature will float
	 * @return a success code
	 */
	private static native boolean _setFloatingTime(long creature, int seconds);
	public static boolean setFloatingTime(obj_id creature, int seconds)
	{
		return _setFloatingTime(getLongWithNull(creature), seconds);
	}
	/**
	 * Sets the location of an object.
	 * @param target		the object to move
	 * @param to			the location to move the object to. Currently we cannot move an object from one scene to another.
	 * @return true on success, false on fail
	 */
	private static native boolean _setLocation(long target, location to);
	public static boolean setLocation(obj_id target, location to)
	{
		return _setLocation(getLongWithNull(target), to);
	}
	/**
	 * Sets the location of an object to the location of another object.
	 * @param target		the object to move
	 * @param toId			the object we want to move to. Currently we cannot move an object from one scene to another.
	 * @return true on success, false on fail
	 */
	private static native boolean _setLocation(long target, long toId);
	public static boolean setLocation(obj_id target, obj_id toId)
	{
		return _setLocation(getLongWithNull(target), getLongWithNull(toId));
	}
	/**
	 * Returns the location of an object. (cell and local location if in a cell)
	 * @param target		the object
	 * @return the object's location, or null on error
	 */
	private static native location _getLocation(long target);
	public static location getLocation(obj_id target)
	{
		return _getLocation(getLongWithNull(target));
	}
	/**
	 * Returns the world location of an object. (not cell location if in a cell)
	 * @param target		the object
	 * @return the object's world location, or null on error
	 */
	private static native location _getWorldLocation(long target);
	public static location getWorldLocation(obj_id target)
	{
		return _getWorldLocation(getLongWithNull(target));
	}
	/**
	 * Returns the heading of an object in the object's current coordinate system.
	 * @param target		the object
	 * @return the object's location, or null on error
	 */
	private static native location _getHeading(long target);
	public static location getHeading(obj_id target)
	{
		return _getHeading(getLongWithNull(target));
	}
	/**
	 * Get the object to world transform of an object.
	 * @param target  the object
	 * @return the object's transform in world space
	 */
	private static native transform _getTransform_o2w(long target);
	public static transform getTransform_o2w(obj_id target)
	{
		return _getTransform_o2w(getLongWithNull(target));
	}
	/**
	 * Get the object to parent transform of an object.
	 * @param target  the object
	 * @return the object's transform in parent space
	 */
	private static native transform _getTransform_o2p(long target);
	public static transform getTransform_o2p(obj_id target)
	{
		return _getTransform_o2p(getLongWithNull(target));
	}
	/**
	 * Get the attachedTo (parent) of an object.
	 *
	 * @param target  the object
	 * @return the attachedTo (parent) of an object
	 */
	private static native long _getAttachedTo(long target);
	public static obj_id getAttachedTo(obj_id target)
	{
		return getObjIdWithNull(_getAttachedTo(getLongWithNull(target)));
	}
	/**
	 * Set the object to parent transform of an object.
	 * @param target  the object
	 * @param newTransform  the object's new transform in parent space
	 */
	private static native void _setTransform_o2p(long target, transform newTransform);
	public static void setTransform_o2p(obj_id target, transform newTransform)
	{
		_setTransform_o2p(getLongWithNull(target), newTransform);
	}
	/**
	 * Warp a player to a specified place.
	 * @param player      the player to warp
	 * @param sceneName   the scene to warp to
	 * @param x_w         the world x coordinate to warp to
	 * @param y_w         the world y coordinate to warp to
	 * @param z_w         the world z coordinate to warp to
	 * @param cell        the cell object to warp to
	 * @param x_p         the parent x coordinate to warp to
	 * @param y_p         the parent y coordinate to warp to
	 * @param z_p         the parent z coordinate to warp to
	 * @param callback    messageHandler function to call when the player arrives
	 * @param forceLoadScreen  whether to require a loading screen regardless of scene change or distance
	 */
	private static native void _warpPlayer(long player, String sceneName, float x_w, float y_w, float z_w, long cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen);
	public static void warpPlayer(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen)
	{
		_warpPlayer(getLongWithNull(player), sceneName, x_w, y_w, z_w, getLongWithNull(cell), x_p, y_p, z_p, callback, forceLoadScreen);
	}
	/**
	 * Warp a player to a specified place.
	 * @param player      the player to warp
	 * @param sceneName   the scene to warp to
	 * @param x_w         the world x coordinate to warp to
	 * @param y_w         the world y coordinate to warp to
	 * @param z_w         the world z coordinate to warp to
	 * @param building    the building object to warp to
	 * @param cell        the building cell name to warp to
	 * @param x_p         the parent x coordinate to warp to
	 * @param y_p         the parent y coordinate to warp to
	 * @param z_p         the parent z coordinate to warp to
	 * @param callback    messageHandler function to call when the player arrives
	 * @param forceLoadScreen  whether to require a loading screen regardless of scene change or distance
	 */
	private static native void _warpPlayer(long player, String sceneName, float x_w, float y_w, float z_w, long building, String cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen);
	public static void warpPlayer(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id building, String cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen)
	{
		_warpPlayer(getLongWithNull(player), sceneName, x_w, y_w, z_w, getLongWithNull(building), cell, x_p, y_p, z_p, callback, forceLoadScreen);
	}
	public static void warpPlayer(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id cell, float x_p, float y_p, float z_p)
	{
		warpPlayer(player, sceneName, x_w, y_w, z_w, cell, x_p, y_p, z_p, null, false);
	}
	public static void warpPlayer(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id cell, float x_p, float y_p, float z_p, String callback)
	{
		warpPlayer(player, sceneName, x_w, y_w, z_w, cell, x_p, y_p, z_p, callback, false);
	}
	public static void warpPlayer(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id building, String cell, float x_p, float y_p, float z_p)
	{
		warpPlayer(player, sceneName, x_w, y_w, z_w, building, cell, x_p, y_p, z_p, null, false);
	}
	public static void warpPlayer(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id building, String cell, float x_p, float y_p, float z_p, String callback)
	{
		warpPlayer(player, sceneName, x_w, y_w, z_w, building, cell, x_p, y_p, z_p, callback, false);
	}
	/**
	 * Disconnects a player.  If the safeLogout objvar is set on them, logs them out too.
	 * @param player  the player to disconnect
	 * @return
	 */
	private static native void _disconnectPlayer(long player);
	public static void disconnectPlayer(obj_id player)
	{
		_disconnectPlayer(getLongWithNull(player));
	}

	/**
	 * Returns true if the player character is currently connected
	 * (to the game client running on a player's PC)
	 *
	 * this function works cluster wide
	 *
	 * @param player  the player to check
	 * @return true or false
	 */
	private static native boolean _isPlayerConnected(long player);
	public static boolean isPlayerConnected(obj_id player)
	{
		return _isPlayerConnected(getLongWithNull(player));
	}

	/**
	 * If the player is currently connected, returns a dictionary
	 * containing the player's current location, or returns null
	 * if the player is not connected
	 *
	 * the fields in the dictionary is as follows:
	 *     planet - the name of the planet the player is currently on
	 *     region - the planet region name that the player is currently in
	 *          which can be null
	 *     playerCity - the name of the player city that the player is currently in
	 *          which can be null
	 */
	private static native dictionary _getConnectedPlayerLocation(long player);
	public static dictionary getConnectedPlayerLocation(obj_id player)
	{
		return _getConnectedPlayerLocation(getLongWithNull(player));
	}

	/**
	 * Returns true if the player character is currently active
	 * (i.e. connected *AND* has provided input to the game client via
	 * input devices in the past 15 minutes; SWG macro *DOES NOT* count
	 * as an "input device")
	 *
	 * this function works cluster wide
	 *
	 * @param player  the player to check
	 * @return true or false
	 */
	private static native boolean _isPlayerActive(long player);
	public static boolean isPlayerActive(obj_id player)
	{
		return _isPlayerActive(getLongWithNull(player));
	}

    /**
	 * Sends a player to the initial tutorial area safely.
	 * @param player  the player
	 * @return
	 */
	private static native void _sendPlayerToTutorial(long player);
	public static void sendPlayerToTutorial(obj_id player)
	{
		_sendPlayerToTutorial(getLongWithNull(player));
	}

    /**
	 * Checks to see if the specified player is in a tutorial area
	 * @param player  the player
	 * @return boolean representing whether the player is in the tutorial area
	 */
	private static native boolean _isInTutorialArea(long player);
	public static boolean isInTutorialArea(obj_id player)
	{
		return _isInTutorialArea(getLongWithNull(player));
	}

    /** Sets the creatureName of the creature which corresponds to the "creatureName" column used in creation from creatures_datatable.xml
     * @param creature: the creature object id
     * @param creatureName: the "creatureName" column as defined in creatures_datatable.xml
     */
    private static native void _setCreatureName(long creature, String creatureName);
    public static void setCreatureName(obj_id creature, String creatureName)
    {
        _setCreatureName(getLongWithNull(creature), creatureName);
    }

    /**
     * Returns the "creatureName" column used to create the creature from creatures_datatable.xml
     * @param creature: the creature object id
     * @return the creature's name, or null if this object does not have an AiCreatureController
     */
    private static native String _getCreatureName(long creature);
    public static String getCreatureName(obj_id creature)
    {
        return _getCreatureName(getLongWithNull(creature));
    }

    /**
     * Returns the default name of an object.
     * @param target        the object
     * @return the object's name, or null on error
     */
    private static native string_id _getNameStringId(long target);
    public static string_id getNameStringId(obj_id target)
    {
        return _getNameStringId(getLongWithNull(target));
    }

    /**
     * Returns the default name of an object that would be created by a given template.
     * @param template      the template name
     * @return the name, or null if the template doesn't exist
     */
    public static native string_id getNameFromTemplate(String template);

    /**
     * Returns the default name of an object that would be created by a given template.
     * @param templateCrc       the template crc value
     * @return the name, or null if the template doesn't exist
     */
    public static native string_id getNameFromTemplate(int templateCrc);

    /**
     * Returns the default name of objects that would be created by given templates.
     * @param templates     the template names
     * @return the names, or null on error
     */
    public static native string_id[] getNamesFromTemplates(String[] templates);

    /**
     * Returns the default name of objects that would be created by given templates.
     * @param templateCrcs      the template crc values
     * @return the names, or null on error
     */
    public static native string_id[] getNamesFromTemplates(int[] templateCrcs);

    /**
    * This is the only form of an object's name you should ever display to the client.
    */
    public static String getEncodedName (obj_id target)
    {
        final String name = getAssignedName (target);

        if (name != null && name.length () > 0)
            return name;

        final string_id sid = getNameStringId (target);
        if (sid != null && !sid.isEmpty ())
            return "@" + sid.toString ();

        return "";
    }

    /**
    * Returns the first name
    * @return the object's first name, or null on error
    */


    public static String getFirstName (obj_id target)
    {
        String name = getName(target);
        if (name != null)
        {
            java.util.StringTokenizer tok = new java.util.StringTokenizer (name);

            if (tok.hasMoreTokens ())
                return tok.nextToken ();
        }
        return null;
    }

    /**
    * Returns the avatar's chat name
    */
    public static String getChatName (obj_id target)
    {
        String firstName = getFirstName (target);
        if (firstName != null)
        {
            final String prefix = getGameChatCode () + "." + getGalaxyName () + ".";
            return prefix + firstName;
        }
        return null;
    }

    /**
     * Generates a random name given a template.
     * @param template     the path to the template.
     * @return a random name, or an empty string on error
     */
    public static native String generateRandomName(String template);

    /**
     * Generates a random name given a directory and name table
     * @param directory The name generator directory
     * @param table The table name to use
     * @return a random name, or an empty string on error
     */
    public static native String generateRandomName(String directory, String table);

    /**
     * Check a player-entered name against the reserved/obscene name list
     * @param name The name to check
     * @return true if the name is reserved, false if it is OK
     */
    public static native boolean isNameReserved(String name);

    /**
     * Check a player-entered name against the reserved/obscene name list with exceptions
     * @param name The name to check
     * @param ignoreRules Array of rules to ignore taken from "reserved.tab"
     * @return true if the name is reserved, false if it is OK
     */
    public static native boolean isNameReserved(String name, String[] ignoreRules);
/*@}*/

    /**
    * @defgroup objectInfoMethods Generic Object information methods
    */
    /*@{*/

        // object generic info methods
        /**
         * Returns the gender of an object.
         * @param target        the object
         * @return the gender, or -1 on fail
         */
        private static native int _getGender(long target);
        public static int getGender(obj_id target)
        {
            return _getGender(getLongWithNull(target));
        }
        /**
         * Tests to see if two objects have the same gender.
         * @param target1       the first object
         * @param target2       the second object
         * @return true if the objects are the same gender, false if not
         */
        private static native boolean _isSameGender(long target1, long target2);
        public static boolean isSameGender(obj_id target1, obj_id target2)
        {
            return _isSameGender(getLongWithNull(target1), getLongWithNull(target2));
        }
        /**
         * Tests to see if an object is a given niche.
         * @param target        the object
         * @param niche         the niche id to test for
         * @return true if the object is the niche, false if not
         */
        private static native boolean _isNiche(long target, int niche);
        public static boolean isNiche(obj_id target, int niche)
        {
            return _isNiche(getLongWithNull(target), niche);
        }
        /**
         * Tests to see if an object is a given species.
         * @param target        the object
         * @param race          the species id to test for
         * @return true if the object is the species, false if not
         */
        private static native boolean _isSpecies(long target, int race);
        public static boolean isSpecies(obj_id target, int race)
        {
            return _isSpecies(getLongWithNull(target), race);
        }
        /**
         * Tests to see if an object is a given species and race.
         * @param target        the object
         * @param species       the species id to test for
         * @param race          the race id to test for
         * @return true if the object is the species, false if not
         */
        private static native boolean _isRace(long target, int species, int race);
        public static boolean isRace(obj_id target, int species, int race)
        {
            return _isRace(getLongWithNull(target), species, race);
        }
        /**
         * Returns the niche of an object.
         * @param target        the object
         * @return the niche, or -1 on fail
         */
        private static native int _getNiche(long target);
        public static int getNiche(obj_id target)
        {
            return _getNiche(getLongWithNull(target));
        }
        /**
         * Returns the species of an object.
         * @param target        the object
         * @return the species, or -1 on fail
         */
        private static native int _getSpecies(long target);
        public static int getSpecies(obj_id target)
        {
            return _getSpecies(getLongWithNull(target));
        }
        /**
         * Returns the race of an object.
         * @param target        the object
         * @return the race, or -1 on fail
         */
        private static native int _getRace(long target);
        public static int getRace(obj_id target)
        {
            return _getRace(getLongWithNull(target));
        }
        /**
         * Tests if an object is a mobile/creature.
         * @param target        the object
         * @return true if the object is a mobile, false if not
         */
        private static native boolean _isMob(long target);
        public static boolean isMob(obj_id target)
        {
            return _isMob(getLongWithNull(target));
        }
        /**
         * Tests if an object is a tangible.
         * @param target        the object
         * @return true if the object is a tangible, false if not
         */
        private static native boolean _isTangible(long target);
        public static boolean isTangible(obj_id target)
        {
            return _isTangible(getLongWithNull(target));
        }
        /**
         * Tests if an object is a player.
         * @param target        the object
         * @return true if the object is a mobile, false if not
         */
        private static native boolean _isPlayer(long target);
        public static boolean isPlayer(obj_id target)
        {
            return _isPlayer(getLongWithNull(target));
        }
        /**
         * Checks if a player is currently away from keyboard (AFK)
         * @param player     the player to check
         * @return true if the player is currently AFK, false if not
         */
        private static native boolean _isAwayFromKeyBoard(long player);
        public static boolean isAwayFromKeyBoard(obj_id player)
        {
            return _isAwayFromKeyBoard(getLongWithNull(player));
        }
        /**
         * Returns the object type of an object.
         * @param target        the object
         * @return the object type, or -1 on error
         */
        private static native int _getObjType(long target);
        public static int getObjType(obj_id target)
        {
            return _getObjType(getLongWithNull(target));
        }
        /**
         * Returns the venue type of an object.
         * @param target        the object
         * @return the venue type, or -1 on error
         */
//      public static native int getVenueType(obj_id target);
         /**
         * Returns the lookat target of an object
         * @param object the object currently must be a creature to have a lookat target
         * @return the target, or null
         */
        private static native long _getLookAtTarget(long object);
        public static obj_id getLookAtTarget (obj_id object)
        {
            return getObjIdWithNull(_getLookAtTarget(getLongWithNull(object)));
        }
        /**
         * Sets the lookat target of a creature or ship
         * @param object    the object
         * @param target    the new target
         * @return true on success, false on error
         */
        private static native boolean _setLookAtTarget(long object, long target);
        public static boolean setLookAtTarget(obj_id object, obj_id target)
        {
            return _setLookAtTarget(getLongWithNull(object), getLongWithNull(target));
        }
         /**
         * Returns the combat target of an object
         * @param object the object currently must be a creature to have a combat
         * @return the target, or null
         */
        public static obj_id getCombatTarget (obj_id object)
        {
            return getLookAtTarget(object);
        }

        /**
         * Returns the intended target of an object
         * @param object the object currently must be a creature to have a intended target
         * @return the target, or null
         */
        private static native long _getIntendedTarget(long object);
        public static obj_id getIntendedTarget (obj_id object)
        {
            return getObjIdWithNull(_getIntendedTarget(getLongWithNull(object)));
        }

        /**
         * Sets the combat target of a creature
         * @param object    the object
         * @param target    the new target
         * @return true on success, false on error
         */
        public static boolean setCombatTarget(obj_id object, obj_id target)
        {
            return setLookAtTarget(object, target);
        }

        /**
         * Returns the posture of an object.
         * @param target        the object
         * @return the posture, or -1 on error
         */
        private static native int _getPosture(long target);
        public static int getPosture(obj_id target)
        {
            return _getPosture(getLongWithNull(target));
        }
        /**
         * Changes the posture of an object.
         *
         * The servers maintain the authoritative posture for a creature; however,
         * the client does not immediately display the latest server posture unless
         * explicitly told to.  This function does not instruct the client to change
         * posture immediately.  See setPostureClientImmediate() for that functionality.
         * This function is most useful for when the creature posture is getting
         * set during combat, a time when the client must carefully manage the current
         * visual posture and is quite frequently different than the logical server posture.
         *
         * @param target        the object
         * @param posture       the new posture
         * @return true on success, false on error
         */
        private static native boolean _setPosture(long target, int posture);
        public static boolean setPosture(obj_id target, int posture)
        {
            return _setPosture(getLongWithNull(target), posture);
        }
        /**
         * Changes the posture of an object and have all observing clients change to the
         * posture immediately
         *
         * If you are changing the posture of a client and you are not in combat, this
         * probably is the function you want to use.
         *
         * Use setPosture() rather than setPostureClientImmediate() if the creature is in
         * combat and you are not prepared to disturb the visuals of combat.
         *
         * @param target        the object
         * @param posture       the new posture
         * @return true on success, false on error
         */
        private static native boolean _setPostureClientImmediate(long target, int posture);
        public static boolean setPostureClientImmediate(obj_id target, int posture)
        {
            return _setPostureClientImmediate(getLongWithNull(target), posture);
        }
        /**
         * Returns the locomotion of an object.
         * @param target        the object
         * @return the locomotion, or -1 on error
         */
        private static native int _getLocomotion(long target);
        public static int getLocomotion(obj_id target)
        {
            return _getLocomotion(getLongWithNull(target));
        }
        /**
         * Changes the locomotion of an object.  If the locomotion is a moving locomtion,
         * the objects speed will be set to run or walk as necessary.  If it's a non-
         * moving locomotion, the object will be stopped.
         * @param target        the object
         * @param posture       the new locomotion
         * @return true on success, false on error
         */
        private static native boolean _setLocomotion(long target, int locomotion);
        public static boolean setLocomotion(obj_id target, int locomotion)
        {
            return _setLocomotion(getLongWithNull(target), locomotion);
        }
        /**
         * Returns whether a state is set on a creature
         * @param target      the creature
         * @param whichState  the state identifier
         * @return 1 if the state is set, 0 if not, -1 on error
         */
        private static native int _getState(long target, int whichState);
        public static int getState(obj_id target, int whichState)
        {
            return _getState(getLongWithNull(target), whichState);
        }
        /**
         * Changes whether a state is set on an object. NOTE: Do not call this function with state
         * STATE_COMBAT. Use the startCombat() and stopCombat() functions instead.
         * @param target       the object
         * @param whichState   the state identifier
         * @param value        whether to set or clear the state
         * @return true on success, false on error
         */
        private static native boolean _setState(long target, int whichState, boolean value);
        public static boolean setState(obj_id target, int whichState, boolean value)
        {
            return _setState(getLongWithNull(target), whichState, value);
        }
        /**
         * Returns the owner of a tangible object.
         * @param target  the object to get the owner of
         * @return        the owner
         */
        private static native long _getOwner(long target);
        public static obj_id getOwner(obj_id target)
        {
            return getObjIdWithNull(_getOwner(getLongWithNull(target)));
        }
        /**
         * Sets the owner of a tangible object
         * @param target       the object
         * @param owner        the new owner
         * @return true on success, false on error
         */
        private static native boolean _setOwner(long target, long owner);
        public static boolean setOwner(obj_id target, obj_id owner)
        {
            return _setOwner(getLongWithNull(target), getLongWithNull(owner));
        }
        /**
         * Returns if a creature is incapacitated.
         * @param target        the object
         * @return the true if incapacitated, false if not or error
         */
        private static native boolean _isIncapacitated(long target);
        public static boolean isIncapacitated(obj_id target)
        {
            return _isIncapacitated(getLongWithNull(target));
        }
        /**
         * Returns if a creature is dead.
         * @param target        the object
         * @return the true if dead, false if not or error
         */
        private static native boolean _isDead(long target);
        public static boolean isDead(obj_id target)
        {
            return _isDead(getLongWithNull(target));
        }
        /**
         * Kills a creature.
         * @param target        the object
         * @return true if the creature was killed or already dead
         */
        private static native boolean _kill(long target);
        public static boolean kill(obj_id target)
        {
            return _kill(getLongWithNull(target));
        }
        /**
         * Kills a player.
         * @param player        the player
         * @param killer        who killed the player (may be null)
         * @return the corpse id of the player, or null on error
         */
//      public static native obj_id killPlayer(obj_id player, obj_id killer);
        /**
         * Resurrects a creature.
         * @param target        the object
         * @return true if the creature was resurrected or already akive
         */
        private static native boolean _resurrect(long target);
        public static boolean resurrect(obj_id target)
        {
            return _resurrect(getLongWithNull(target));
        }
        /**
         * Removes all attribute and skill mod modifications on a creature.  Does NOT remove buffs so it is possible for a buff icon to be left behind even after its attribute and skill mods have been removed.
         * Does not respect the REMOVE_ON_DEAD flag.
         * @param target        the creature
         * @return true if the creature's mods were removed
         */
        private static native boolean _removeAllAttributeAndSkillmodMods(long target);
        public static boolean removeAllAttributeAndSkillmodMods(obj_id target)
        {
			return _removeAllAttributeAndSkillmodMods(getLongWithNull(target));
        }
        /**
         * Returns if a creature is an npc (i.e. not a player)
         * @param target        the object
         * @return true if the creature is an npc, false if not or error
         */
        private static native boolean _isNpcCreature(long target);
        public static boolean isNpcCreature(obj_id target)
        {
            return _isNpcCreature(getLongWithNull(target));
        }
        /**
         * Sets a creature's cover value.
         * @param target        creature we want to set
         * @param cover         the cover value
         * @return true on success, false on error
         */
        private static native boolean _setCreatureCover(long target, int cover);
        public static boolean setCreatureCover(obj_id target, int cover)
        {
            return _setCreatureCover(getLongWithNull(target), cover);
        }
        /**
         * Sets a creature's cover value based on it's current chunk.
         * @param target        creature we want to set
         * @return true on success, false on error
         */
        private static native boolean _setCreatureCover(long target);
        public static boolean setCreatureCover(obj_id target)
        {
            return _setCreatureCover(getLongWithNull(target));
        }

        private static native void _setCreatureCoverVisibility(long target, boolean isVisible);
        public static void setCreatureCoverVisibility(obj_id target, boolean isVisible)
        {
            _setCreatureCoverVisibility(getLongWithNull(target), isVisible);
        }
        private static native boolean _getCreatureCoverVisibility(long target);
        public static boolean getCreatureCoverVisibility(obj_id target)
        {
            return _getCreatureCoverVisibility(getLongWithNull(target));
        }

        // object movement methods
        /**
         * Causes an object to turn and face another object.
         * @param mob       the object to turn
         * @param target    the object we want to face
         * @return true on success, false on fail
         */
        private static native boolean _faceTo(long mob, long target);
        public static boolean faceTo(obj_id mob, obj_id target)
        {
            return _faceTo(getLongWithNull(mob), getLongWithNull(target));
        }
        /**
         * Causes an object to turn and face a given location.
         * @param mob       the object to turn
         * @param target    the location we want to face
         * @return true on success, false on fail
         */
        private static native boolean _faceTo(long mob, location target);
        public static boolean faceTo(obj_id mob, location target)
        {
            return _faceTo(getLongWithNull(mob), target);
        }
        /**
         * Causes an object to always face another object.
         * @param mob       the object to turn
         * @param target    the object we want to face
         * @return true on success, false on fail
         */
        private static native boolean _faceToBehavior(long mob, long target);
        public static boolean faceToBehavior(obj_id mob, obj_id target)
        {
            return _faceToBehavior(getLongWithNull(mob), getLongWithNull(target));
        }
        /**
         * Is an object in the world?
         * @param target The object
         * @return true if the object is in the world
         */
        private static native boolean _isInWorld(long target);
        public static boolean isInWorld(obj_id target)
        {
            return _isInWorld(getLongWithNull(target));
        }
        /**
         * Is an object in the world cell?
         * @param target The object
         * @return true if the object is in the world cell
         */
        private static native boolean _isInWorldCell(long target);
        public static boolean isInWorldCell(obj_id target)
        {
            return _isInWorldCell(getLongWithNull(target));
        }

        private static native int _elevatorMove(long object, int nFloors);
        public static int elevatorMove(obj_id object, int nFloors)
        {
            return _elevatorMove(getLongWithNull(object), nFloors);
        }

        // The speed the mob is currently moving including all movement modifiers
        private static native float _getMovementSpeed(long object);
        public static float getMovementSpeed(obj_id object)
        {
            return _getMovementSpeed(getLongWithNull(object));
        }

        // The maximum speed the mob can walk == getBaseWalkSpeed() + movement modifiers
        private static native float _getWalkSpeed(long object);
        public static float getWalkSpeed(obj_id object)
        {
            return _getWalkSpeed(getLongWithNull(object));
        }

        // The maximum speed the mob can run == getBaseRunSpeed() + movement modifiers
        private static native float _getRunSpeed(long object);
        public static float getRunSpeed(obj_id object)
        {
            return _getRunSpeed(getLongWithNull(object));
        }

        // The non-modified speed a mob walks
        private static native void _setBaseWalkSpeed(long object, float speed);
        public static void setBaseWalkSpeed(obj_id object, float speed)
        {
            _setBaseWalkSpeed(getLongWithNull(object), speed);
        }
        private static native float _getBaseWalkSpeed(long object);
        public static float getBaseWalkSpeed(obj_id object)
        {
            return _getBaseWalkSpeed(getLongWithNull(object));
        }

        // The non-modified speed an object runs
        private static native void _setBaseRunSpeed(long object, float speed);
        public static void setBaseRunSpeed(obj_id object, float speed)
        {
            _setBaseRunSpeed(getLongWithNull(object), speed);
        }
        private static native float _getBaseRunSpeed(long object);
        public static float getBaseRunSpeed(obj_id object)
        {
            return _getBaseRunSpeed(getLongWithNull(object));
        }

        // Set the object's maximum speed to either running or walking
        private static native void _setMovementWalk(long object);
        public static void setMovementWalk(obj_id object)
        {
            _setMovementWalk(getLongWithNull(object));
        }
        private static native void _setMovementRun(long object);
        public static void setMovementRun(obj_id object)
        {
            _setMovementRun(getLongWithNull(object));
        }

        /**
         * Returns if an object is disabled or not.
         *
         * @param object        the object
         *
         * @return true if the object is disabled, false if not
         */
        private static native boolean _isDisabled(long object);
        public static boolean isDisabled(obj_id object)
        {
            return _isDisabled(getLongWithNull(object));
        }

        /**
        * Sets the source id an object will be marked as crafted with. If the id is 0 or null,
        * the object will be considered not crafted.
        * @param target     object we want to set as (not)crafted
        * @param id         the id that will be used as the crafted id
        * @return true in success, true if the target is invalid
        */
        private static native boolean _setCraftedId(long target, long id);
        public static boolean setCraftedId(obj_id target, obj_id id)
        {
            return _setCraftedId(getLongWithNull(target), getLongWithNull(id));
        }

        /**
         * Returns if an object is crafted or not.
         *
         * @param object        the object
         *
         * @return true if the object is crafted, false if not
         */
        private static native boolean _isCrafted(long object);
        public static boolean isCrafted(obj_id object)
        {
            return _isCrafted(getLongWithNull(object));
        }

        /**
         * Returns the id of the player who crafted an object.
         *
         * @param object        the object
         *
         * @return the crafter id, or null on error or if the item was not crafted
         */
        private static native long _getCrafter(long object);
        public static obj_id getCrafter(obj_id object)
        {
            return getObjIdWithNull(_getCrafter(getLongWithNull(object)));
        }

        /**
         * Changes the id of the player who crafted an object.
         *
         * @param target        object we want to know about
         * @param crafter       the id of the crafter (null not allowed)
         *
         * @return true on success, false on fail
         */
        private static native boolean _setCrafter(long target, long crafter);
        public static boolean setCrafter(obj_id target, obj_id crafter)
        {
            return _setCrafter(getLongWithNull(target), getLongWithNull(crafter));
        }

        /**
         * Returns the scale of a creature.
         * @param target        creature we want to know about
         * @return the scale, or -1 on error
         */
        private static native float _getScale(long target);
        public static float getScale(obj_id target)
        {
            return _getScale(getLongWithNull(target));
        }

        /**
         * Sets the scale of a creature.
         * @param target        creature we want to set
         * @param scale         the creature's new scale
         * @return true on success, false on error
         */
        private static native boolean _setScale(long target, float scale);
        public static boolean setScale(obj_id target, float scale)
        {
            return _setScale(getLongWithNull(target), scale);
        }

        /**
         * Returns the default scale of a creature given a server object template name.
         *
         * This function throws a Java exception if the associated server or shared object
         * template is not found or on any other error.
         *
         * @param serverObjectTemplateName  the TreeFile-relative path to the server object
         *                                  template for which default scale info is retrieved.
         *
         * @return  the default scale from the object template.
         */
        public static native float getDefaultScaleFromObjectTemplate(String serverObjectTemplateName);

        /**
         * Returns the default scale of a creature given a shared object template name.
         *
         * This function throws a Java exception if the associated shared object
         * template is not found or on any other error.
         *
         * @param serverObjectTemplateName  the TreeFile-relative path to the shared object
         *                                  template for which default scale info is retrieved.
         *
         * @return  the default scale from the object template.
         */
	public static native float getDefaultScaleFromSharedObjectTemplate(String sharedObjectTemplateName);

        /**
         * Returns the yaw (rotaion) of an object.
         * @param target        object we want to know about
         * @return the yaw in degrees, or -1 on error
         */
        private static native float _getYaw(long target);
        public static float getYaw(obj_id target)
        {
            return _getYaw(getLongWithNull(target));
        }

        /**
         * Sets the scale of a creature.
         * @param target        creature we want to set
         * @param yaw           the creature's new yaw (rotation) in degrees
         * @return true on success, false on error
         */
        private static native boolean _setYaw(long target, float degrees);
        public static boolean setYaw(obj_id target, float degrees)
        {
            return _setYaw(getLongWithNull(target), degrees);
        }

        /**
         * Modify the yaw (rotation) of an object by some number of degrees
         * @param target        object to modify yaw (rotation)
         * @param degrees       the object's yaw (rotation) modification in degrees
         */
        private static native void _modifyYaw(long target, float degrees);
        public static void modifyYaw(obj_id target, float degrees)
        {
            _modifyYaw(getLongWithNull(target), degrees);
        }

        /**
         * Modify the pitch (rotation) of an object by some number of degrees
         * @param target        object to modify pitch (rotation)
         * @param degrees       the object's pitch (rotation) modification in degrees
         */
        private static native void _modifyPitch(long target, float degrees);
        public static void modifyPitch(obj_id target, float degrees)
        {
            _modifyPitch(getLongWithNull(target), degrees);
        }

        /**
         * Modify the roll (rotation) of an object by some number of degrees
         * @param target        object to modify roll (rotation)
         * @param degrees       the object's roll (rotation) modification in degrees
         */
        private static native void _modifyRoll(long target, float degrees);
        public static void modifyRoll(obj_id target, float degrees)
        {
            _modifyRoll(getLongWithNull(target), degrees);
        }

        /**
         * Get the quaternion (rotation) values for an object
         * @param target        object to get the quaternion (rotation) values
         * @return a float array containing the 4 quaternion values (qw, qx, qy, qz)
         */
        private static native float[] _getQuaternion(long target);
        public static float[] getQuaternion(obj_id target)
        {
            return _getQuaternion(getLongWithNull(target));
        }

        /**
         * Set the quaternion (rotation) values for an object
         * @param target        object to set the quaternion (rotation) values
         * @qw, qx, qy, qz      the quaternion (rotation) values
         */
        private static native void _setQuaternion(long target, float qw, float qx, float qy, float qz);
        public static void setQuaternion(obj_id target, float qw, float qx, float qy, float qz)
        {
            _setQuaternion(getLongWithNull(target), qw, qx, qy, qz);
        }

        /**
         * Returns the default number of degrees (set in the client Misc Options page)
         * that an object should be rotated by when using the Rotate radial sub-menu
         * @param player        player object where the option is set
         * @return the number of degrees
         */
        private static native int _getFurnitureRotationDegree(long player);
        public static int getFurnitureRotationDegree(obj_id player)
        {
            return _getFurnitureRotationDegree(getLongWithNull(player));
        }

        /**
         * save the decoration layout of the specified pob into the
         * specified save slot number on the specified player character
         */
        private static native void _saveDecorationLayout(long player, long pob, int saveSlotNumber, String description);
        public static void saveDecorationLayout(obj_id player, obj_id pob, int saveSlotNumber, String description)
        {
            _saveDecorationLayout(getLongWithNull(player), getLongWithNull(pob), saveSlotNumber, description);
        }

        /**
         * restore the specified saved decoration layout into the specified pob
         */
        private static native void _restoreDecorationLayout(long player, long pob, int saveSlotNumber);
        public static void restoreDecorationLayout(obj_id player, obj_id pob, int saveSlotNumber)
        {
            _restoreDecorationLayout(getLongWithNull(player), getLongWithNull(pob), saveSlotNumber);
        }

        /**
         * Sets the invulnerable flag on an object.
         * @param target            object we want to set
         * @param invulnerable      the new invulnerable state of the object
         * @return true on success, false on error
         */
        private static native boolean _setInvulnerable(long target, boolean invulnerable);
        public static boolean setInvulnerable(obj_id target, boolean invulnerable)
        {
            return _setInvulnerable(getLongWithNull(target), invulnerable);
        }

        /**
         * Returns the invulnerable flag of an object.
         * @param target        object we want to get
         * @return the invulnerable flag on success, false on error
         */
        private static native boolean _isInvulnerable(long target);
        public static boolean isInvulnerable(obj_id target)
        {
            return _isInvulnerable(getLongWithNull(target));
        }

        /**
         * Sets the insured flag on an object.
         * @param target            object we want to set
         * @param insured           the new insured state of the object
         * @return true on success, false on error
         */
        public static boolean setInsured(obj_id target, boolean insured)
        {
            if (insured)
                return setCondition(target, CONDITION_INSURED);
            else
                return clearCondition(target, CONDITION_INSURED);
        }

        /**
         * Returns if an item is insured.
         * @param target        object we want to get
         * @return true if insured, false if not
         */
        private static native boolean _isInsured(long target);
        public static boolean isInsured(obj_id target)
        {
            return _isInsured(getLongWithNull(target));
        }

        /**
         * Sets an object to be autoInsured
         * @param target            object we want to set
         * @return true on success, false on error
         */
        public static boolean setAutoInsured(obj_id target)
        {
            return setUninsurable(target, true) && setInsured(target, true);
        }

        /**
         * Returns if an item is autoInsured.
         * @param target        object we want to get
         * @return true if autoInsured, false if not
         */
        private static native boolean _isAutoInsured(long target);
        public static boolean isAutoInsured(obj_id target)
        {
            return _isAutoInsured(getLongWithNull(target));
        }

        /**
         * Sets the uninsurable flag on an object.
         * @param target            object we want to set
         * @param uninsurable       the new uninsurable state of the object
         * @return true on success, false on error
         */
        public static boolean setUninsurable(obj_id target, boolean uninsurable)
        {
            if (uninsurable)
                return setCondition(target, CONDITION_UNINSURABLE);
            else
                return clearCondition(target, CONDITION_UNINSURABLE);
        }

        /**
         * Returns the uninsurable flag of an object.
         * @param target        object we want to get
         * @return the uninsurable flag
         */
        private static native boolean _isUninsurable(long target);
        public static boolean isUninsurable(obj_id target)
        {
            return _isUninsurable(getLongWithNull(target));
        }

        /**
         * Returns the complexity of an object.
         * @param target        object to get
         * @return the complexity, or -1 on error
         */
        private static native float _getComplexity(long target);
        public static float getComplexity(obj_id target)
        {
            return _getComplexity(getLongWithNull(target));
        }
        /**
         * Sets the complexity of an object.
         * @param target        object to change
         * @param complexity    object complexity
         * @return true on success, false on error
         */
        private static native boolean _setComplexity(long target, float complexity);
        public static boolean setComplexity(obj_id target, float complexity)
        {
            return _setComplexity(getLongWithNull(target), complexity);
        }
        /**
         * Get the group object a creature is in, if any.
         * @param creature  the creature to get the group object for
         * @return the group object or null
         */
        private static native long _getGroupObject(long creature);
        public static obj_id getGroupObject(obj_id creature)
        {
            return getObjIdWithNull(_getGroupObject(getLongWithNull(creature)));
        }
        /**
         * Get the name of a group.
         * @param group  the group object to get the name of
         * @return  the group's name
         */
        private static native String _getGroupName(long group);
        public static String getGroupName(obj_id group)
        {
            return _getGroupName(getLongWithNull(group));
        }
        /**
         * Get the obj_id of all members of a group.
         * @param group  the group object to get the members of
         * @return  the group members' obj_ids
         */
        private static native long[] _getGroupMemberIds(long group);
        public static obj_id[] getGroupMemberIds(obj_id group)
        {
            long[] _ret_long = _getGroupMemberIds(getLongWithNull(group));
            obj_id[] _ret_obj_id = null;
            if (_ret_long != null)
            {
                _ret_obj_id = new obj_id[_ret_long.length];
                for (int _i = 0; _i < _ret_long.length; ++_i)
                    _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
            }
            return _ret_obj_id;
        }
        /**
         * Get the name of all members of a group.
         * @param group  the group object to get the members of
         * @return  the group members' names
         */
        private static native String[] _getGroupMemberNames(long group);
        public static String[] getGroupMemberNames(obj_id group)
        {
            return _getGroupMemberNames(getLongWithNull(group));
        }
        /**
         * Get the id of a group's leader.
         * @param group  the group object to get the leader for
         * @return the group leader's obj_id
         */
        private static native long _getGroupLeaderId(long group);
        public static obj_id getGroupLeaderId(obj_id group)
        {
            return getObjIdWithNull(_getGroupLeaderId(getLongWithNull(group)));
        }
        /**
         * Get the number of members in a group.
         * @param group  the group object to get the number of members for
         * @return the number of members in the group
         */
        private static native int _getGroupSize(long group);
        public static int getGroupSize(obj_id group)
        {
            return _getGroupSize(getLongWithNull(group));
        }
        /**
         * Get the number of player controlled members in a group.
         * @param group  the group object to get the number of player controlled members for
         * @return the number of player controlled members in the group
         */
        private static native int _getPCGroupSize(long group);
        public static int getPCGroupSize(obj_id group)
        {
            return _getPCGroupSize(getLongWithNull(group));
        }
        /**
         * Get the id of a group's loot leader.
         * @param group  the group object to get the loot leader for
         * @return the group leader's obj_id
         */
        private static native long _getGroupMasterLooterId(long group);
        public static obj_id getGroupMasterLooterId(obj_id group)
        {
            return getObjIdWithNull(_getGroupMasterLooterId(getLongWithNull(group)));
        }
        /**
         * Get the id of a group's loot leader.
         * @param group  the group object to get the loot rule for
         * @return the group leader's obj_id
         */
        private static native int _getGroupLootRule(long group);
        public static int getGroupLootRule(obj_id group)
        {
            return _getGroupLootRule(getLongWithNull(group));
        }
        /**
         * Get the id of a group's loot leader.
         * @param group  the group object to set the loot rule for
         * @return the group leader's obj_id
         */
        private static native boolean _setGroupLootRule(long object, int rule);
        public static boolean setGroupLootRule(obj_id object, int rule)
        {
            return _setGroupLootRule(getLongWithNull(object), rule);
        }
        /**
         * open the lottery window for a player.
         * @param   player to send to and the container that this for
         * @return  success
         */
        private static native void _openLotteryWindow(long playerToSendTo, long container);
        public static void openLotteryWindow(obj_id playerToSendTo, obj_id container)
        {
            _openLotteryWindow(getLongWithNull(playerToSendTo), getLongWithNull(container));
        }
        /**
         * Get the type of a creature's current performance (music/dance).
         * @param   target the creature to check
         * @return  the performance type or 0 if none
         */
        private static native int _getPerformanceType(long target);
        public static int getPerformanceType(obj_id target)
        {
            return _getPerformanceType(getLongWithNull(target));
        }
        /**
         * Set the type of a creature's current performance (music/dance).
         * @param   target the creature to modify
         * @param   performanceType the index of the performance type
         */
        private static native void _setPerformanceType(long target, int performanceType);
        public static void setPerformanceType(obj_id target, int performanceType)
        {
            _setPerformanceType(getLongWithNull(target), performanceType);
        }
        /**
         * Get the start time of a creature's current performance (music/dance).
         * @param   target the creature to check
         * @return  the performance start time or 0 if none
         */
        private static native int _getPerformanceStartTime(long target);
        public static int getPerformanceStartTime(obj_id target)
        {
            return _getPerformanceStartTime(getLongWithNull(target));
        }
        /**
         * Set the start time of a creature's current performance (music/dance).
         * @param   target the creature to modify
         * @param   performanceType the start time of the performance
         */
        private static native void _setPerformanceStartTime(long target, int performanceStartTime);
        public static void setPerformanceStartTime(obj_id target, int performanceStartTime)
        {
            _setPerformanceStartTime(getLongWithNull(target), performanceStartTime);
        }
        /**
         * Get a creature's current performance listen target.
         * @param  actor  the creature to get the target from
         * @return  the listen target
         */
        private static native long _getPerformanceListenTarget(long actor);
        public static obj_id getPerformanceListenTarget(obj_id actor)
        {
            return getObjIdWithNull(_getPerformanceListenTarget(getLongWithNull(actor)));
        }
        /**
         * Set a creature's current performance listen target.
         * @param actor   the creature to set the target for
         * @param target  the target to set
         */
        private static native void _setPerformanceListenTarget(long actor, long target);
        public static void setPerformanceListenTarget(obj_id actor, obj_id target)
        {
            _setPerformanceListenTarget(getLongWithNull(actor), getLongWithNull(target));
        }
        /**
         * Get a creature's current performance watch target.
         * @param  actor  the creature to get the target from
         * @return  the watch target
         */
        private static native long _getPerformanceWatchTarget(long actor);
        public static obj_id getPerformanceWatchTarget(obj_id actor)
        {
            return getObjIdWithNull(_getPerformanceWatchTarget(getLongWithNull(actor)));
        }
        /**
         * Set a creature's current performance watch target.
         * @param actor   the creature to set the target for
         * @param target  the target to set
         */
        private static native void _setPerformanceWatchTarget(long actor, long target);
        public static void setPerformanceWatchTarget(obj_id actor, obj_id target)
        {
            _setPerformanceWatchTarget(getLongWithNull(actor), getLongWithNull(target));
        }
        /**
         * Get the visual type of a creature's current instrument
         * @param   target the creature to check
         * @return  the instrument type number or 0 if none
         */
        private static native int _getInstrumentVisualId(long target);
        public static int getInstrumentVisualId(obj_id target)
        {
            return _getInstrumentVisualId(getLongWithNull(target));
        }
        /**
         * Get the audio type of a creature's current instrument
         * @param   target the creature to check
         * @return  the instrument type number or 0 if none
         */
        private static native int _getInstrumentAudioId(long target);
        public static int getInstrumentAudioId(obj_id target)
        {
            return _getInstrumentAudioId(getLongWithNull(target));
        }
        /**
         * send a music flourish
         * @param performer the person performing the flourish
         * @param flourishIndex the index of the flourish to perform
         */
        private static native void _sendMusicFlourish(long performer, int flourishIndex);
        public static void sendMusicFlourish(obj_id performer, int flourishIndex)
        {
            _sendMusicFlourish(getLongWithNull(performer), flourishIndex);
        }

        /**
         * Returns if an object is an object being controlled by a god-mode client.
         * @param target        the object to test
         * @return true if the object is god-mode controlled, false if not
         */
        private static native boolean _isGod(long target);
        public static boolean isGod(obj_id target)
        {
            return _isGod(getLongWithNull(target));
        }
        /**
         * Returns the god-level of a player.
         * @param target        the object to test
         * @return the god level
         */
        private static native int _getGodLevel(long target);
        public static int getGodLevel(obj_id target)
        {
            return _getGodLevel(getLongWithNull(target));
        }

        /**
         * Get the master of a creature (for pet support).
         * @param target  the creature to get the master of
         * @return the obj_id of the creature's master
         */
        private static native long _getMaster(long target);
        public static obj_id getMaster(obj_id target)
        {
            return getObjIdWithNull(_getMaster(getLongWithNull(target)));
        }
        /**
         * Set the master of a creature (for pet support).
         * @param target the creature to set the master of
         * @param master the new master
         */
        private static native void _setMaster(long target, long master);
        public static void setMaster(obj_id target, obj_id master)
        {
            _setMaster(getLongWithNull(target), getLongWithNull(master));
        }

        /**
        * @return difficulty in the range [0,32768]
        */
        private static native int  _getGroupObjectLevel(long groupId);
        public static int  getGroupObjectLevel    (obj_id groupId)
        {
            return _getGroupObjectLevel(getLongWithNull(groupId));
        }

        /**
        * @return level in the range [0,32768] for creature objects
        */
        private static native int _getLevel(long target);
        public static int getLevel(obj_id target)
        {
            return _getLevel(getLongWithNull(target));
        }

        /**
        * Set the level of a creature for the duration of the current session
        */
        private static native boolean _setLevel(long target, int level);
        public static boolean setLevel(obj_id target, int level)
        {
            return _setLevel(getLongWithNull(target), level);
        }
        /**
        * @recalculates the level based on skils for the creature object
        */
        private static native boolean _recalculateLevel(long target);
        public static boolean recalculateLevel(obj_id target)
        {
            return _recalculateLevel(getLongWithNull(target));
        }

		/**
        * @return hologram type
        */
		private static native int _getHologramType(long target);
		public static int getHologramType(obj_id target)
		{
			return _getHologramType(getLongWithNull(target));
		}

		/**
		* Set the hologram type
		*/
		private static native boolean _setHologramType(long target, int type);
		public static boolean setHologramType(obj_id target, int type)
		{
			return _setHologramType(getLongWithNull(target), type);
		}

		/**
		* @return true if the creature is visible on the map and radar
		*/
		private static native boolean _getVisibleOnMapAndRadar(long target);
		public static boolean getVisibleOnMapAndRadar(obj_id target)
		{
			return _getVisibleOnMapAndRadar(getLongWithNull(target));
		}

		/**
		* sets if this creature is visible on map and radar
		*/
		private static native boolean _setVisibleOnMapAndRadar(long target, boolean value);
		public static boolean setVisibleOnMapAndRadar(obj_id target, boolean value)
		{
			return _setVisibleOnMapAndRadar(getLongWithNull(target), value);
		}


		/**
		 * Start a buff builder session
		 * @param bufferid the buffer
		 * @param recipientId the recipient
		 */
		 private static native void _buffBuilderStart(long bufferId, long recipientId);
		 public static void buffBuilderStart(obj_id bufferId, obj_id recipientId)
		 {
			 _buffBuilderStart(getLongWithNull(bufferId), getLongWithNull(recipientId));
		 }

		 /**
		  * Do a customization on the target with the customization changes
		  */
		 private static native boolean _buffBuilderValidated(long bufferId, long recipientId, int startingTime, int bufferRequiredCredits, int recipientPaidCredits, boolean accepted, String[] buffComponentKeys, int[] buffComponentValues);
		 public static boolean buffBuilderValidated(obj_id bufferId, obj_id recipientId, int startingTime, int bufferRequiredCredits, int recipientPaidCredits, boolean accepted, String[] buffComponentKeys, int[] buffComponentValues)
		 {
		 	return _buffBuilderValidated(getLongWithNull(bufferId), getLongWithNull(recipientId), startingTime, bufferRequiredCredits, recipientPaidCredits, accepted, buffComponentKeys, buffComponentValues);
         }

         /**
		  * development version of launching the incubator - temp
		  * @param playerid the player
		  * @param terminalId the terminal
		  */
		 private static native void _incubatorStart_development(long playerId, long terminalId);
		 public static void incubatorStart_development(obj_id playerId, obj_id terminalId)
		 {
		 	_incubatorStart_development(getLongWithNull(playerId), getLongWithNull(terminalId));
		 }

		 /**
		  *  launch the incubator
		  * @param sessionNumber the session number
		  * @param playerid the player
		  * @param terminalId the terminal
		  * @param powerGauge (0-999)
		  * @param initialPointsSurvival (0 on first session, points so far in successive sessions)
		  * @param initialPointsBeastialResilience (0 on first session, points so far in successive sessions)
		  * @param initialPointsCunning (0 on first session, points so far in successive sessions)
		  * @param initialPointsIntelligence (0 on first session, points so far in successive sessions)
		  * @param initialPointsAggression (0 on first session, points so far in successive sessions)
		  * @param initialPointsHuntersInstinct(0 on first session, points so far in successive sessions)
		  * @param temperatureGauge (0 - 10)
		  * @param nutrientGauge (0 - 10)
		  * @param initialCreatureColorIndex (index into palette)
		  * @param creatureTemplateName
		  */
		 private static native void _incubatorStart(
			 int sessionNumber,
			 long playerId,
			 long terminalId,
			 int powerGauge,
			 int initialPointsSurvival,
			 int initialPointsBeastialResilience,
			 int initialPointsCunning,
			 int initialPointsIntelligence,
			 int initialPointsAggression,
			 int initialPointsHuntersInstinct,
			 int temperatureGauge,
			 int nutrientGauge,
			 int initialCreatureColorIndex,
			 String creatureTemplateName
		);

		 public static void incubatorStart(
			 int sessionNumber,
			 obj_id playerId,
			 obj_id terminalId,
			 int powerGauge,
			 int initialPointsSurvival,
			 int initialPointsBeastialResilience,
			 int initialPointsCunning,
			 int initialPointsIntelligence,
			 int initialPointsAggression,
			 int initialPointsHuntersInstinct,
			 int temperatureGauge,
			 int nutrientGauge,
			 int initialCreatureColorIndex,
			 String creatureTemplateName
		)
		 {
		 	_incubatorStart(
				sessionNumber,
				getLongWithNull(playerId),
				getLongWithNull(terminalId),
				powerGauge,
				initialPointsSurvival,
				initialPointsBeastialResilience,
				initialPointsCunning,
				initialPointsIntelligence,
				initialPointsAggression,
				initialPointsHuntersInstinct,
				temperatureGauge,
				nutrientGauge,
				initialCreatureColorIndex,
				creatureTemplateName
			);
		 }

        /**
         * Sets the resource that is put into the incubator
         */
         private static native void _setIncubatorPowerResourceName(long incubatorId, String resourceName);
         public static void setIncubatorPowerResourceName(obj_id incubatorId, String resourceName)
         {
             _setIncubatorPowerResourceName(getLongWithNull(incubatorId), resourceName);
         }

        /**
         * Start an imagedesigner session
         * @paarm designerId the designer
         * @param recipientId the recipient
         * @param terminalId the terminal being used for the session(optional)
         * @param currentHoloEmote the holo-emote currently on the player
         */
        private static native void _imagedesignStart(long designerId, long recipientId, long terminalId, String currentHoloEmote);
        public static void imagedesignStart(obj_id designerId, obj_id recipientId, obj_id terminalId, String currentHoloEmote)
        {
            _imagedesignStart(getLongWithNull(designerId), getLongWithNull(recipientId), getLongWithNull(terminalId), currentHoloEmote);
        }

        /**
         * Do a customization on the target with the customization changes
         */
        private static native boolean _imagedesignValidated(long designerId, long recipientId, long terminalId, int startingTime, int designType, boolean newHairSet, String newHairAsset, String hairCustomizationData, int designerRequiredCredits, int recipientPaidCredits, boolean accepted, String[] morphChangesKeys, float[] morphChangesValues, String[] indexChangesKeys, int[] indexChangesValues, String holoEmote);
        public static boolean imagedesignValidated(obj_id designerId, obj_id recipientId, obj_id terminalId, int startingTime, int designType, boolean newHairSet, String newHairAsset, String hairCustomizationData, int designerRequiredCredits, int recipientPaidCredits, boolean accepted, String[] morphChangesKeys, float[] morphChangesValues, String[] indexChangesKeys, int[] indexChangesValues, String holoEmote)
        {
            return _imagedesignValidated(getLongWithNull(designerId), getLongWithNull(recipientId), getLongWithNull(terminalId), startingTime, designType, newHairSet, newHairAsset, hairCustomizationData, designerRequiredCredits, recipientPaidCredits, accepted, morphChangesKeys, morphChangesValues, indexChangesKeys, indexChangesValues, holoEmote);
        }

        /**
         * Open the client's holocron screen and display the given page.
         * Passing an empty string will cause the holocron to open but not change pages.
         * Sending this message to a client with an open Holocron will cause the holocron to stay open and change to the new page.
         */
        private static native boolean _openHolocronToPage(long client, String page);
        public static boolean openHolocronToPage(obj_id client, String page)
        {
            return _openHolocronToPage(getLongWithNull(client), page);
        }

        /**
         * Close the client's holocron screen.
         * (We don't normally allow such direct control over the UI from script, but this is useful for a directly newbie experience)
         */
        private static native boolean _closeHolocron(long client);
        public static boolean closeHolocron(obj_id client)
        {
            return _closeHolocron(getLongWithNull(client));
        }

        /**
         * Returns the appearance file name of an object.
         * @param target        the object
         * @return the appearance name, or null on error
         */
        private static native String _getAppearance(long target);
        public static String getAppearance(obj_id target)
        {
            return _getAppearance(getLongWithNull(target));
        }

        /**
         * Returns an object's counter.
         * @param target        the object
         * @return the counter value
         */
        private static native int _getCount(long target);
        public static int getCount(obj_id target)
        {
            return _getCount(getLongWithNull(target));
        }

        /**
         * Sets an object's counter.
         * @param target        the object
         * @param value         the counter value
         * @return true if the counter was set, false if there was an error
         */
        private static native boolean _setCount(long target, int value);
        public static boolean setCount(obj_id target, int value)
        {
            return _setCount(getLongWithNull(target), value);
        }

        /**
         * Increments (or decrements, if passed a negative value) an object's counter.
         * @param target        the object
         * @param delta         number to add to the current count
         * @return true on success, false if there was an error
         */
        private static native boolean _incrementCount(long target, int delta);
        public static boolean incrementCount(obj_id target, int delta)
        {
            return _incrementCount(getLongWithNull(target), delta);
        }

        /**
         * Decrements an object's counter by 1 and destroys it if none are left.
         * @param target        the object
         * @return true on success, false if there was an error
         */
        public static boolean decrementCount(obj_id target)
        {
            if (!isValidId(target))
                return false;

            boolean result = incrementCount(target, -1);

            if (result && getCount(target) <= 0)
                destroyObject(target);

            return result;
        }

		// these MUST be reflected in:
		// //depot/swg/current/dsrc/sku.0/sys.server/compiled/game/object/tangible_object_template.tdf
		// //depot/swg/current/dsrc/sku.0/sys.server/compiled/game/script/base_class.java
		// //depot/swg/current/src/engine/client/library/clientGame/src/shared/object/TangibleObject.h
		// //depot/swg/current/src/engine/server/library/serverGame/src/shared/object/TangibleObject.h

        public static final int CONDITION_ON                       = 0x00000001;
        public static final int CONDITION_VENDOR                   = 0x00000002;
        public static final int CONDITION_INSURED                  = 0x00000004;
        public static final int CONDITION_CONVERSABLE              = 0x00000008;
        public static final int CONDITION_HIBERNATING              = 0x00000010;
        public static final int CONDITION_MAGIC_ITEM               = 0x00000020;
        public static final int CONDITION_AGGRESSIVE               = 0x00000040;
        public static final int CONDITION_WANT_SAW_ATTACK_TRIGGER  = 0x00000080;
        public static final int CONDITION_INVULNERABLE             = 0x00000100;
        public static final int CONDITION_DISABLED                 = 0x00000200;
        public static final int CONDITION_UNINSURABLE              = 0x00000400;
        public static final int CONDITION_INTERESTING              = 0x00000800;
        public static final int CONDITION_MOUNT                    = 0x00001000;  // Set programmatically by mount system.  Do not set this.
        public static final int CONDITION_CRAFTED                  = 0x00002000;  // Set programmatically by crafting system.  Do not set this.
        public static final int CONDITION_WINGS_OPENED             = 0x00004000;  // Set programmatically by wing system.  Do not set this.
        public static final int CONDITION_SPACE_INTERESTING        = 0x00008000;
        public static final int CONDITION_DOCKING                  = 0x00010000;  // Set programmatically by docking system.  Do not set this.
        public static final int CONDITION_DESTROYING               = 0x00020000;  // Set programmatically by ship system.  Do not set this.
        public static final int CONDITION_COMMABLE                 = 0x00040000;
        public static final int CONDITION_DOCKABLE                 = 0x00080000;
        public static final int CONDITION_EJECT                    = 0x00100000;
        public static final int CONDITION_INSPECTABLE              = 0x00200000;
        public static final int CONDITION_TRANSFERABLE             = 0x00400000;
        public static final int CONDITION_INFLIGHT_TUTORIAL        = 0x00800000;
        public static final int CONDITION_SPACE_COMBAT_MUSIC       = 0x01000000;  // Set programmatically by the AI system.  Do not set this.
        public static final int CONDITION_ENCOUNTER_LOCKED         = 0x02000000;
        public static final int CONDITION_SPAWNED_CREATURE         = 0x04000000;
        public static final int CONDITION_HOLIDAY_INTERESTING      = 0x08000000;
        public static final int CONDITION_LOCKED                   = 0x10000000;

        /**
         * Returns an object's condition flags.
         * @param target        the object
         * @return the object's condition flags
         */
        private static native int _getCondition(long target);
        public static int getCondition(obj_id target)
        {
            return _getCondition(getLongWithNull(target));
        }

        /**
         * Tests if an object has a condition flag set.
         * @param target        the object
         * @param condition     the condition flag to test
         * @return true if the condition flag is set, false if not
         */
        private static native boolean _hasCondition(long target, int condition);
        public static boolean hasCondition(obj_id target, int condition)
        {
            return _hasCondition(getLongWithNull(target), condition);
        }

        /**
         * Sets a condition flag on an object.
         * @param target        the object
         * @param condition     the condition flag
         * @return true on success, false if there was an error
         */
        private static native boolean _setCondition(long target, int condition);
        public static boolean setCondition(obj_id target, int condition)
        {
            return _setCondition(getLongWithNull(target), condition);
        }

        /**
         * Clears a condition flag on an object.
         * @param target        the object
         * @param condition     the condition flag
         * @return true on success, false if there was an error
         */
        private static native boolean _clearCondition(long target, int condition);
        public static boolean clearCondition(obj_id target, int condition)
        {
            return _clearCondition(getLongWithNull(target), condition);
        }

        /**
         * Sets the cheater level of a player. NOTE: Cheater level is currently being used as a HACK.  Do not set this.
         * @param player        the player
         * @param level    cheater level
         *
         * @return true on success, false on error
         */
        private static native boolean _setCheaterLevel(long player, int level);
        public static boolean setCheaterLevel(obj_id player, int level)
        {
            return _setCheaterLevel(getLongWithNull(player), level);
        }

        /**
         * Sets the cheater level on a player
         * @param player        the player
         * @return the level of cheater (0 for non-players)
         */
        private static native int _getCheaterLevel(long player);
        public static int getCheaterLevel(obj_id player)
        {
            return _getCheaterLevel(getLongWithNull(player));
        }

        /**
         * Sets the house that a player owns.
         * @param player        the player
         * @param houseId       the house
         * @return true on success, false on error
         */
        private static native boolean _setHouseId(long player, long houseId);
        public static boolean setHouseId(obj_id player, obj_id houseId)
        {
            return _setHouseId(getLongWithNull(player), getLongWithNull(houseId));
        }

        /**
         * Sets the house that a player owns.
         * @param player        the player
         * @return the house id, or null on error
         */
        private static native long _getHouseId(long player);
        public static obj_id getHouseId(obj_id player)
        {
            return getObjIdWithNull(_getHouseId(getLongWithNull(player)));
        }

        /**
         * Returns the draft schematic template name used to create a manufacture schematic.
         * @param manfSchematic     the manf schematic id
         * @return the draft schematic name, or null on error
         */
        private static native String _getDraftSchematic(long manfSchematic);
        public static String getDraftSchematic(obj_id manfSchematic)
        {
            return _getDraftSchematic(getLongWithNull(manfSchematic));
        }

        /**
         * Returns the draft schematic template name crc used to create a manufacture schematic.
         * @param manfSchematic     the manf schematic id
         * @return the draft schematic name crc, or 0 on error
         */
        private static native int _getDraftSchematicCrc(long manfSchematic);
        public static int getDraftSchematicCrc(obj_id manfSchematic)
        {
            return _getDraftSchematicCrc(getLongWithNull(manfSchematic));
        }

        /**
         * Returns the draft schematic template name crc used to create an object.
         * @param object        the object we want the source schematic of
         * @return the draft schematic name crc, or 0 on error or if the object wasn't crafted
         */
        private static native int _getSourceDraftSchematic(long object);
        public static int getSourceDraftSchematic(obj_id object)
        {
            return _getSourceDraftSchematic(getLongWithNull(object));
        }

        /**
         * Returns the "birth" date of a player character.
         * @param player        the id of the player we want
         * @return returns the birth date, in days since Jan 1st, 2001 (Jan 1st, 2001 = 0);
         *      returns -1 on error
         */
        private static native int _getPlayerBirthDate(long player);
        public static int getPlayerBirthDate(obj_id player)
        {
            return _getPlayerBirthDate(getLongWithNull(player));
        }

        /**
         * Returns the "birth" date that a player being created now would get.
         * @return returns the birth date, in days since Jan 1st, 2001 (Jan 1st, 2001 = 0)
         */
        public static native int getCurrentBirthDate();

        /**
         * Returns the amount of time a player has been online.
         * @param player        the id of the player we want
         * @return
         */
        private static native int _getPlayerPlayedTime(long player);
        public static int getPlayerPlayedTime(obj_id player)
        {
            return _getPlayerPlayedTime(getLongWithNull(player));
        }

        /**
         * Get the city id set on a building
         * @param building  the building we want info from
         * @return the id of the city set for a building
         */
        private static native int _getBuildingCityId(long building);
        public static int getBuildingCityId(obj_id building)
        {
            return _getBuildingCityId(getLongWithNull(building));
        }

        /**
         * Set the city id for a building
         * @param building  the building we want to modify
         * @param cityId    the city id to for the building
         */
        private static native void _setBuildingCityId(long building, int cityId);
        public static void setBuildingCityId(obj_id building, int cityId)
        {
            _setBuildingCityId(getLongWithNull(building), cityId);
        }

        /**
         * Returns the default name that would be given an object created by a given draft schematic.
         * @param draftSchematic        the schematic name
         * @return the object name, or null if the schematic doesn't exist
         */
        public static native string_id getProductNameFromSchematic(String draftSchematic);

        /**
         * Returns the default name that would be given an object created by a given draft schematic.
         * @param draftSchematicCrc     the schematic name crc
         * @return the object name, or null if the schematic doesn't exist
         */
        public static native string_id getProductNameFromSchematic(int draftSchematicCrc);

        /**
         * Register an obj_id with a name for later lookup via getNamedObject.
         * The name registry does not persist, and only contains objects registered on the gameserver
         * the registerNamedObject function was called on.  Passing a null namedObject unregisters a name.
         *
         * @param name  the name to associate with the object
         * @param namedObject  the obj_id to associate with the name
         */
        private static native void _registerNamedObject(String name, long namedObject);
        public static void registerNamedObject(String name, obj_id namedObject)
        {
            _registerNamedObject(name, getLongWithNull(namedObject));
        }

        /**
         * Get the obj_id associated previously with a name by registerNamedObject.
         *
         * @param name  the name associated with the object
         * @return  the named object
         */
        private static native long _getNamedObject(String name);
        public static obj_id getNamedObject(String name)
        {
            return getObjIdWithNull(_getNamedObject(name));
        }

        /**
        *  Attempts to find an object anywhere in the galaxy
        *  If it can find the object it will respond with a message "foundObject"
        *  The params returned in foundObject are:
         *      obj_id target
         *      string sharedTemplate
         *      location location (x,y,z,scene world coords)
         *      int pid (auth process id)
         *      obj_id[] containers
        *
        *  @param target The object id you wish to find
        *  @param objectToNotify The object id to receive the foundObject message on success
        */
        private static native void _findObjectAnywhere(long target, long objectToNotify);
        public static void findObjectAnywhere(obj_id target, obj_id objectToNotify)
        {
            _findObjectAnywhere(getLongWithNull(target), getLongWithNull(objectToNotify));
        }

        /**
        *  Attempts to find all objects in the galaxy with a given template name
        *  If it can find the object it will respond with a message "foundObject"
        *  The params returned in foundObject are:
         *      obj_id target
         *      string sharedTemplate
         *      location location (x,y,z,scene world coords)
         *      int pid (auth process id)
         *      obj_id[] containers
        *
        *  @param templateName The template name
        *  @param objectToNotify The object id to receive the foundObject message on success
        */
        private static native void _findObjectAnywhereByTemplate(String templateName, long objectToNotify);
        public static void findObjectAnywhereByTemplate(String templateName, obj_id objectToNotify)
        {
            _findObjectAnywhereByTemplate(templateName, getLongWithNull(objectToNotify));
        }

        /**
         *  Attempts to find an player anywhere in the galaxy
         *  If it can find the object it will respond with a message "foundPlayer"
         *  The params returned in foundObject are:
         *      obj_id target
         *      string scene
         *      location location (x,y,z,scene world coords)
         *      int pid (auth process id)
         *
         *  @param partialName The partial name of the player we are looking for
         *  @param objectToNotify The object id to receive the foundObject message on success
         */
        private static native void _findPlayerAnywhereByPartialName(String partialName, long objectToNotify);
        public static void findPlayerAnywhereByPartialName(String partialName, obj_id objectToNotify)
        {
            _findPlayerAnywhereByPartialName(partialName, getLongWithNull(objectToNotify));
        }

        /**
         *  Attempts to find all Wardens anywhere in the galaxy
         *
         *  @param objectToNotify The object id to receive the foundObject message on success
         */
        private static native void _findWardenAnywhere(long objectToNotify);
        public static void findWardenAnywhere(obj_id objectToNotify)
        {
            _findWardenAnywhere(getLongWithNull(objectToNotify));
        }

        /**
         *  Attempts to find all creatures of a particular type anywhere in the galaxy
         *
         *  @param objectToNotify The object id to receive the foundObject message on success
         *  @param creatureName name of the creature (from creatures.tab or returned from getCreatureName())
         */
        private static native void _findCreatureAnywhere(String creatureName, long objectToNotify);
        public static void findCreatureAnywhere(String creatureName, obj_id objectToNotify)
        {
            _findCreatureAnywhere(creatureName, getLongWithNull(objectToNotify));
        }

        /**
         * Request an OnPreloadComplete trigger when preloading is complete (or immediately if already complete).
         *
         * @param target  the object to receive the OnPreloadComplete trigger
         */
        private static native void _requestPreloadCompleteTrigger(long target);
        public static void requestPreloadCompleteTrigger(obj_id target)
        {
            _requestPreloadCompleteTrigger(getLongWithNull(target));
        }

        /*
         * Tests if an object is flagged as notrade or not.
         * @param target        the item to test
         * @return true if the item can be traded, false if not
         */
        private static native boolean _canTrade(long target);
        public static boolean canTrade(obj_id target)
        {
            return _canTrade(getLongWithNull(target));
        }

        /*
         * Tests if an object is flagged as "no trade shared" or not.
         * @param target        the item to test
         * @return true or false
         */
        private static native boolean _isNoTradeShared(long target);
        public static boolean isNoTradeShared(obj_id target)
        {
            return _isNoTradeShared(getLongWithNull(target));
        }

        /**
         * Sets a bio-link on an object. If the object is equippable, only the player that
         * the object is linked to will be able to equip it. If the object is used as a
         * component during crafting, the crafted object will also be linked to the player.
         * @param target        the item to be bio-linked
         * @param link          the id of the player to link the item to; if 0/null, the item will be send to pending (not equippable by any player)
         * @return true on success, false on fail
         */
        private static native boolean _setBioLink(long target, long link);
        public static boolean setBioLink(obj_id target, obj_id link)
        {
            return _setBioLink(getLongWithNull(target), getLongWithNull(link));
        }

        /**
         * Removes a bio-link from an object.
         * @param target        the item to remove the link from
         * @return true on success, false on fail
         */
        private static native boolean _clearBioLink(long target);
        public static boolean clearBioLink(obj_id target)
        {
            return _clearBioLink(getLongWithNull(target));
        }

        /**
         * Returns the bio-link attached to an object.
         * @param target        the item to get the link from
         *
         * @return the bio-link id, null if the item isn't linked
         */
        private static native long _getBioLink(long target);
        public static obj_id getBioLink(obj_id target)
        {
            return getObjIdWithNull(_getBioLink(getLongWithNull(target)));
        }

    /*@} objectInfoMethods */

    // object pathing/steering methods
    /**
     * @defgroup steering Steering Methods
     * @{
     */
    /**
     * Resets all of the explicit steering commands given to the creature.
     * There may be implicit steering commands (follow in particular may add them) that are not reset.
     *
     * @param creature The ID of the creature
     * @return a success code
     */
//  public static native boolean resetSteering(obj_id creature);
    /**
     * Sets the slope aversion angle for a creature.
     * angle is a slope in degrees.  The creature has no displeasure at moving on slope less than value degrees.
     * He will have some displeasure moving on slopes between value and 2*value degrees, and will attempt to
     * avoid slopes > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param angle the maximum comfortable slope for the creature
     */
    private static native boolean _setSlopeModAngle(long creature, float value);
    public static boolean setSlopeModAngle(obj_id creature, float value)
    {
        return _setSlopeModAngle(getLongWithNull(creature), value);
    }
    /**
     * Sets the slope aversion angle for a creature.
     * angle is a slope in degrees.  The creature has no displeasure at moving on slope less than value degrees.
     * He will have some displeasure moving on slopes between value and 2*value degrees, and will attempt to
     * avoid slopes > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param angle the maximum comfortable slope for the creature
     */
    private static native float _getSlopeModAngle(long creature);
    public static float getSlopeModAngle(obj_id creature)
    {
        return _getSlopeModAngle(getLongWithNull(creature));
    }
    /**
     * Sets the slope aversion angle for a creature.
     * angle is a slope in degrees.  The creature has no displeasure at moving on slope less than value degrees.
     * He will have some displeasure moving on slopes between value and 2*value degrees, and will attempt to
     * avoid slopes > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param angle the maximum comfortable slope for the creature
     */
    private static native float _getTemplateSlopeModAngle(long creature);
    public static float getTemplateSlopeModAngle(obj_id creature)
    {
        return _getTemplateSlopeModAngle(getLongWithNull(creature));
    }
    /**
     * Sets the slope aversion Percent for a creature.
     * Percent is a slope in degrees.  The creature has no displeasure at moving on slope less than value degrees.
     * He will have some displeasure moving on slopes between value and 2*value degrees, and will attempt to
     * avoid slopes > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param Percent the maximum comfortable slope for the creature
     */
    private static native boolean _setSlopeModPercent(long creature, float value);
    public static boolean setSlopeModPercent(obj_id creature, float value)
    {
        return _setSlopeModPercent(getLongWithNull(creature), value);
    }
    /**
     * Sets the slope aversion Percent for a creature.
     * Percent is a slope in degrees.  The creature has no displeasure at moving on slope less than value degrees.
     * He will have some displeasure moving on slopes between value and 2*value degrees, and will attempt to
     * avoid slopes > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param Percent the maximum comfortable slope for the creature
     */
    private static native float _getSlopeModPercent(long creature);
    public static float getSlopeModPercent(obj_id creature)
    {
        return _getSlopeModPercent(getLongWithNull(creature));
    }
    /**
     * Sets the slope aversion Percent for a creature.
     * Percent is a slope in degrees.  The creature has no displeasure at moving on slope less than value degrees.
     * He will have some displeasure moving on slopes between value and 2*value degrees, and will attempt to
     * avoid slopes > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param Percent the maximum comfortable slope for the creature
     */
    private static native float _getTemplateSlopeModPercent(long creature);
    public static float getTemplateSlopeModPercent(obj_id creature)
    {
        return _getTemplateSlopeModPercent(getLongWithNull(creature));
    }
    /**
     * Sets the slope aversion Percent for a creature.
     * Percent is a slope in degrees.  The creature has no displeasure at moving on slope less than value degrees.
     * He will have some displeasure moving on slopes between value and 2*value degrees, and will attempt to
     * avoid slopes > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param Percent the maximum comfortable slope for the creature
     */
    private static native boolean _setWaterModPercent(long creature, float value);
    public static boolean setWaterModPercent(obj_id creature, float value)
    {
        return _setWaterModPercent(getLongWithNull(creature), value);
    }
    /**
     * Sets the Water aversion Percent for a creature.
     * Percent is a Water in degrees.  The creature has no displeasure at moving on Water less than value degrees.
     * He will have some displeasure moving on Waters between value and 2*value degrees, and will attempt to
     * avoid Waters > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param Percent the maximum comfortable Water for the creature
     */
    private static native float _getWaterModPercent(long creature);
    public static float getWaterModPercent(obj_id creature)
    {
        return _getWaterModPercent(getLongWithNull(creature));
    }
    /**
     * Sets the Water aversion Percent for a creature.
     * Percent is a Water in degrees.  The creature has no displeasure at moving on Water less than value degrees.
     * He will have some displeasure moving on Waters between value and 2*value degrees, and will attempt to
     * avoid Waters > 2*value degrees at all costs.
     *
     * @param creature The ID of the creature
     * @param Percent the maximum comfortable Water for the creature
     */
    private static native float _getTemplateWaterModPercent(long creature);
    public static float getTemplateWaterModPercent(obj_id creature)
    {
        return _getTemplateWaterModPercent(getLongWithNull(creature));
    }
    /**
     * Sets the movement speed mod for a creature.
     *
     * @param creature The ID of the creature
     * @param value the mod
     */
    private static native boolean _setMovementPercent(long creature, float value);
    public static boolean setMovementPercent(obj_id creature, float value)
    {
        return _setMovementPercent(getLongWithNull(creature), value);
    }
    /**
     * Get the movement speed mod for a creature
     *
     * @param creature The ID of the creature
     */
    private static native float _getMovementPercent(long creature);
    public static float getMovementPercent(obj_id creature)
    {
        return _getMovementPercent(getLongWithNull(creature));
    }
    /**
     * Sets the acceleration mod for a creature.
     *
     * @param creature The ID of the creature
     * @param value the mod
     */
    private static native boolean _setAccelPercent(long creature, float value);
    public static boolean setAccelPercent(obj_id creature, float value)
    {
        return _setAccelPercent(getLongWithNull(creature), value);
    }
    /**
     * Get the acceleration mod for a creature
     *
     * @param creature The ID of the creature
     */
    private static native float _getAccelPercent(long creature);
    public static float getAccelPercent(obj_id creature)
    {
        return _getAccelPercent(getLongWithNull(creature));
    }
    /**
     * Sets the terrain type preference for steering and pathfinding.
     * Positive values indicate a preference for that type of terrain, and negative values indicate an aversion.
     * The suggested range is -10/10 intense dislike/preference, -3/3 mild dislike/preference.
     *
     * @param creature The ID of the creature
     * @param terrain_type The desired terrain type
     * @param preference The preference for the terrain type
     */
//  public static native boolean preferTerrainType(obj_id creature, int terrain_type, float preference);
    /**
     * Causes the creature to seek or avoid another object.
     * If direction equals STEER_TOWARD, then the creature will prefer to move toward the target.
     * If he is less than minDistance away, he will be happy, and if he is more than maxDistance then he
     * will be unaware of the target.  If he is inbetween, he will move toward the target.
     * If the direction equals STEER_AWAY, then the creature will prefer to move away from the target.
     * He will try really hard to stay more than minDistance away, will move away until he is at maxDistance,
     * and will ignore if he is greater than maxDistance away.
     *
     * @param creature The ID of the creature
     * @param target The ID of the object we are steering toward or away from.
     * @param minDistance The minimum distance to the target
     * @param maxDistance The maximum distance to the target
     * @param direction STEER_TOWARD or STEER_AWAY to move toward or away from the target.
     * @return a success code
     */
//  public static native boolean seekObject(obj_id creature, obj_id target, float minDistance, float maxDistance, int direction);
    /**
     * Makes the creature seek all similar creatures (same species).  Parameters and behavior is similar to seekObject.
     *
     * @param creature The ID of the creature
     * @param minDistance The minimum distance to the target
     * @param maxDistance The maximum distance to the target
     * @param direction STEER_TOWARD or STEER_AWAY to move toward or away from the target.
     * @return a success code
     */
//  public static native boolean seekSimilarCreatures(obj_id creature, float minDistance, float maxDistance, int direction);
    /**
     * Makes the creature seek all different creatures (different species).  Parameters and behavior is similar to seekObject.
     *
     * @param creature The ID of the creature
     * @param minDistance The minimum distance to the target
     * @param maxDistance The maximum distance to the target
     * @param direction STEER_TOWARD or STEER_AWAY to move toward or away from the target.
     * @return a success code
     */
//  public static native boolean seekDifferentCreatures(obj_id creature, float minDistance, float maxDistance, int direction);
    /**
     * Makes the creature seek all non-creatures (buildings, trees, etc).  Parameters and behavior is similar to seekObject.
     *
     * @param creature The ID of the creature
     * @param minDistance The minimum distance to the target
     * @param maxDistance The maximum distance to the target
     * @param direction STEER_TOWARD or STEER_AWAY to move toward or away from the target.
     * @return a success code
     */
//  public static native boolean seekNonCreatures(obj_id creature, float minDistance, float maxDistance, int direction);

    private static native float _getAcceleration(long mob, int movementType);
    public static float getAcceleration(obj_id mob, int movementType)
    {
        return _getAcceleration(getLongWithNull(mob), movementType);
    }
    private static native float _getTurnRate(long mob, int movementType);
    public static float getTurnRate(obj_id mob, int movementType)
    {
        return _getTurnRate(getLongWithNull(mob), movementType);
    }
    private static native float _getStepHeight(long mob);
    public static float getStepHeight(obj_id mob)
    {
        return _getStepHeight(getLongWithNull(mob));
    }
    private static native float _getApproachTriggerRange(long mob);
    public static float getApproachTriggerRange(obj_id mob)
    {
        return _getApproachTriggerRange(getLongWithNull(mob));
    }
    public static float getLoiterRangeMin(obj_id mob) { return 10; }
    public static float getLoiterRangeMax(obj_id mob) { return 30; }
    public static float getLoiterDelayMin(obj_id mob) { return 3; }
    public static float getLoiterDelayMax(obj_id mob) { return 8; }
    public static float getWanderRangeMin(obj_id mob) { return 5; }
    public static float getWanderRangeMax(obj_id mob) { return 10; }
    public static float getWanderAngleMin(obj_id mob) { return 0; }
    public static float getWanderAngleMax(obj_id mob) { return 90; }
    public static float getWanderDelayMin(obj_id mob) { return 4; }
    public static float getWanderDelayMax(obj_id mob) { return 7; }
    public static float getFleeLegRangeMin(obj_id mob) { return 5; }
    public static float getFleeLegRangeMax(obj_id mob) { return 10; }
//  public static native float getSlopeAversion(obj_id mob);
//  public static native float getSlopeAversionMin(obj_id mob);
//  public static native float getSlopeAversionMax(obj_id mob);
    /// @}

    /**
    * @defgroup weaponMethods weapon methods
    */
    /*@{*/

    /**
     * Returns the weapon a creature is currently using for combat.
     * @param target        id of the creature
     * @return the object id of the weapon, or NULL on error
     */
    private static native long _getCurrentWeapon(long target);
    public static obj_id getCurrentWeapon(obj_id target)
    {
        return getObjIdWithNull(_getCurrentWeapon(getLongWithNull(target)));
    }
    /**
     * Sets the weapon a creature will use for combat.
     * @param target        id of the object
     * @param weapon        id of the weapon
     * @return true on success, false on fail
     */
    private static native boolean _setCurrentWeapon(long target, long weapon);
    public static boolean setCurrentWeapon(obj_id target, obj_id weapon)
    {
        return _setCurrentWeapon(getLongWithNull(target), getLongWithNull(weapon));
    }
    /**
     * Gets the weapon being held by a creature, which may or may not be it's current
     * weapon. If the creature is not holding a weapon, returns the creature's default
     * weapon.
     * @param target        id of the object
     * @return the object id of the weapon, or NULL on error
     */
    private static native long _getHeldWeapon(long target);
    public static obj_id getHeldWeapon(obj_id target)
    {
        return getObjIdWithNull(_getHeldWeapon(getLongWithNull(target)));
    }
    /**
     * Returns the current weapon a creature has equipped.
     * @param target        id of creature
     * @return the object id of the weapon, or NULL on error
     */
    private static native long _getDefaultWeapon(long creature);
    public static obj_id getDefaultWeapon(obj_id creature)
    {
        return getObjIdWithNull(_getDefaultWeapon(getLongWithNull(creature)));
    }
    /**
     * Replaces the default weapon of a creature, and moves the old one, if any, to the specified container.
     * @param creature          id of the creature
     * @param weapon            id of the new default weapon
     * @param weaponContainer           id of the container inactive default weapons are stored in
     * @return true on success, false on error
     */
    private static native boolean _swapDefaultWeapons(long creature, long newDefaultWeapon, long weaponContainer);
    public static boolean swapDefaultWeapons(obj_id creature, obj_id newDefaultWeapon, obj_id weaponContainer)
    {
        return _swapDefaultWeapons(getLongWithNull(creature), getLongWithNull(newDefaultWeapon), getLongWithNull(weaponContainer));
    }
    /**
     * Returns if an object is a weapon or not.
     * @param target        the object
     * @return true if the object is a weapon, false if not
     */
    private static native boolean _isWeapon(long target);
    public static boolean isWeapon(obj_id target)
    {
        return _isWeapon(getLongWithNull(target));
    }
    /**
     * Returns if an object is a default weapon or not.
     * @param target        the object
     * @return true if the object is a default weapon, false if not
     */
    private static native boolean _isDefaultWeapon(long target);
    public static boolean isDefaultWeapon(obj_id target)
    {
        return _isDefaultWeapon(getLongWithNull(target));
    }
    /**
     * Returns the minimum range of a weapon.
     * @param weapon        the weapon
     * @return the range, or -1 on error
     */
    private static native float _getMinRange(long weapon);
    public static float getMinRange(obj_id weapon)
    {
        return _getMinRange(getLongWithNull(weapon));
    }
    /**
     * Returns the maximum range of a weapon.
     * @param weapon        the weapon
     * @return the range, or -1 on error
     */
    private static native float _getMaxRange(long weapon);
    public static float getMaxRange(obj_id weapon)
    {
        return _getMaxRange(getLongWithNull(weapon));
    }
    /**
     * Returns the average damage a weapon does.
     * @param weapon        the weapon
     * @return the damage, or 0 on error
     */
    private static native float _getAverageDamage(long weapon);
    public static float getAverageDamage(obj_id weapon)
    {
        return _getAverageDamage(getLongWithNull(weapon));
    }
    /**
     * Returns the type of a weapon.
     * @param weapon        the weapon
     * @return the type, or -1 on error
     */
    private static native int _getWeaponType(long weapon);
    public static int getWeaponType(obj_id weapon)
    {
        return _getWeaponType(getLongWithNull(weapon));
    }
    /**
     * Returns the attack type of a weapon.
     * @param weapon        the weapon
     * @return the type, or -1 on error
     */
    private static native int _getWeaponAttackType(long weapon);
    public static int getWeaponAttackType(obj_id weapon)
    {
        return _getWeaponAttackType(getLongWithNull(weapon));
    }
    /**
     * Gets the base damage type of a weapon.
     *
     * @param weapon        the id of the weapon
     *
     * @return the damage type, or -1 on error
     */
    private static native int _getWeaponDamageType(long weapon);
    public static int getWeaponDamageType(obj_id weapon)
    {
        return _getWeaponDamageType(getLongWithNull(weapon));
    }
    /**
     * Sets the base damage type of a weapon.
     *
     * @param weapon        the id of the weapon
     * @param type          the base damage type
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponDamageType(long weapon, int type);
    public static boolean setWeaponDamageType(obj_id weapon, int type)
    {
        return _setWeaponDamageType(getLongWithNull(weapon), type);
    }
    /**
     * Gets the minimum damage a weapon does.
     *
     * @param weapon        the id of the weapon
     *
     * @return the damage, or -1 on error
     */
    private static native int _getWeaponMinDamage(long weapon);
    public static int getWeaponMinDamage(obj_id weapon)
    {
        return _getWeaponMinDamage(getLongWithNull(weapon));
    }
    /**
     * Sets the minimum damage a weapon does.
     *
     * @param weapon        the id of the weapon
     * @param damage        the minimum damage
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponMinDamage(long weapon, int damage);
    public static boolean setWeaponMinDamage(obj_id weapon, int damage)
    {
        return _setWeaponMinDamage(getLongWithNull(weapon), damage);
    }
    /**
     * Gets the maximum damage a weapon does.
     *
     * @param weapon        the id of the weapon
     *
     * @return the damage, or -1 on error
     */
    private static native int _getWeaponMaxDamage(long weapon);
    public static int getWeaponMaxDamage(obj_id weapon)
    {
        return _getWeaponMaxDamage(getLongWithNull(weapon));
    }
    /**
     * Sets the maximum damage a weapon does.
     *
     * @param weapon        the id of the weapon
     * @param damage        the maximum damage
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponMaxDamage(long weapon, int damage);
    public static boolean setWeaponMaxDamage(obj_id weapon, int damage)
    {
        return _setWeaponMaxDamage(getLongWithNull(weapon), damage);
    }
    /**
     * Gets the attack speed of a weapon.
     *
     * @param weapon        the id of the weapon
     *
     * @return the attack speed, or -1 on error
     */
    private static native float _getWeaponAttackSpeed(long weapon);
    public static float getWeaponAttackSpeed(obj_id weapon)
    {
        return _getWeaponAttackSpeed(getLongWithNull(weapon));
    }
    /**
     * Sets the attack speed of a weapon.
     *
     * @param weapon        the id of the weapon
     * @param speed         the attack speed
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponAttackSpeed(long weapon, float speed);
    public static boolean setWeaponAttackSpeed(obj_id weapon, float speed)
    {
        return _setWeaponAttackSpeed(getLongWithNull(weapon), speed);
    }
    /**
     * Thingy.
     */
    private static native float _getWeaponAudibleRange(long weapon);
    public static float getWeaponAudibleRange(obj_id weapon)
    {
        return _getWeaponAudibleRange(getLongWithNull(weapon));
    }
    /**
     * Gets the range info of a weapon.
     *
     * @param weapon        the id of the weapon
     *
     * @return the range info, or null on error
     */
    private static native range_info _getWeaponRangeInfo(long weapon);
    public static range_info getWeaponRangeInfo(obj_id weapon)
    {
        return _getWeaponRangeInfo(getLongWithNull(weapon));
    }
    /**
     * Sets the range info of a weapon. Note that the max range of a weapon cannot be changed.
     *
     * @param weapon        the id of the weapon
     * @param info          the new info
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponRangeInfo(long weapon, range_info info);
    public static boolean setWeaponRangeInfo(obj_id weapon, range_info info)
    {
        return _setWeaponRangeInfo(getLongWithNull(weapon), info);
    }
    /**
     * Sets the range info of a weapon.
     *
     * @param weapon            the id of the weapon
     * @param minRange          the mid-range value of the weapon
     * @param maxRange          the mid-range value of the weapon
     *
     * @return true on success, false if there was an error
     */
    private static range_info _dummyRangeInfo = new range_info();
    public static boolean setWeaponRangeInfo(obj_id weapon, float minRange, float maxRange)
    {
        _dummyRangeInfo.minRange = minRange;
        _dummyRangeInfo.maxRange = maxRange;
        return setWeaponRangeInfo(weapon, _dummyRangeInfo);
    }
    /**
     * Gets the % change that a weapon will cause a wound.
     *
     * @param weapon        the id of the weapon
     *
     * @return the wound chance, or -1 on error
     */
    private static native float _getWeaponWoundChance(long weapon);
    public static float getWeaponWoundChance(obj_id weapon)
    {
        return _getWeaponWoundChance(getLongWithNull(weapon));
    }
    /**
     * Sets the % change that a weapon will cause a wound.
     *
     * @param weapon        the id of the weapon
     * @param chance        the wound % chance
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponWoundChance(long weapon, float chance);
    public static boolean setWeaponWoundChance(obj_id weapon, float chance)
    {
        return _setWeaponWoundChance(getLongWithNull(weapon), chance);
    }
    /**
     * Gets the damage radius for area-effect weapons.
     *
     * @param weapon        the id of the weapon
     *
     * @return the damage radius, or -1 on error
     */
    private static native float _getWeaponDamageRadius(long weapon);
    public static float getWeaponDamageRadius(obj_id weapon)
    {
        return _getWeaponDamageRadius(getLongWithNull(weapon));
    }
    /**
     * Sets the damage radius for area-effect weapons.
     *
     * @param weapon        the id of the weapon
     * @param radius        the damage radius
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponDamageRadius(long weapon, float radius);
    public static boolean setWeaponDamageRadius(obj_id weapon, float radius)
    {
        return _setWeaponDamageRadius(getLongWithNull(weapon), radius);
    }
    /**
     * Gets the special attack cost a weapon does.
     *
     * @param weapon        the id of the weapon
     *
     * @return the attack cost, or 0 on error
     */
    private static native int _getWeaponAttackCost(long weapon);
    public static int getWeaponAttackCost(obj_id weapon)
    {
        return _getWeaponAttackCost(getLongWithNull(weapon));
    }
    /**
     * Sets the special attack cost a weapon does.
     *
     * @param weapon        the id of the weapon
     * @param cost          the special attack cost
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponAttackCost(long weapon, int cost);
    public static boolean setWeaponAttackCost(obj_id weapon, int cost)
    {
        return _setWeaponAttackCost(getLongWithNull(weapon), cost);
    }
    /**
     * Gets the accuracy of a weapon.
     *
     * @param weapon        the id of the weapon
     *
     * @return the accuracy, or 0 on error
     */
    private static native int _getWeaponAccuracy(long weapon);
    public static int getWeaponAccuracy(obj_id weapon)
    {
        return _getWeaponAccuracy(getLongWithNull(weapon));
    }
    /**
     * Sets the accuracy of a weapon.
     *
     * @param weapon        the id of the weapon
     * @param accuracy          the accuracy
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponAccuracy(long weapon, int accuracy);
    public static boolean setWeaponAccuracy(obj_id weapon, int accuracy)
    {
        return _setWeaponAccuracy(getLongWithNull(weapon), accuracy);
    }
    /**
     * Gets the elemental damage type of a weapon.
     *
     * @param weapon        the id of the weapon
     *
     * @return the elemental damage type, or 0 on error
     */
    private static native int _getWeaponElementalType(long weapon);
    public static int getWeaponElementalType(obj_id weapon)
    {
        return _getWeaponElementalType(getLongWithNull(weapon));
    }
    /**
     * Sets the elemental damage type of a weapon.
     *
     * @param weapon        the id of the weapon
     * @param type          the elemental damage type
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponElementalType(long weapon, int type);
    public static boolean setWeaponElementalType(obj_id weapon, int type)
    {
        return _setWeaponElementalType(getLongWithNull(weapon), type);
    }
    /**
     * Gets the elemental damage amount of a weapon.
     *
     * @param weapon        the id of the weapon
     *
     * @return the elemental damage amount, or 0 on error
     */
    private static native int _getWeaponElementalValue(long weapon);
    public static int getWeaponElementalValue(obj_id weapon)
    {
        return _getWeaponElementalValue(getLongWithNull(weapon));
    }
    /**
     * Sets the elemental damage amount of a weapon.
     *
     * @param weapon        the id of the weapon
     * @param value         the elemental damage amount
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _setWeaponElementalValue(long weapon, int value);
    public static boolean setWeaponElementalValue(obj_id weapon, int value)
    {
        return _setWeaponElementalValue(getLongWithNull(weapon), value);
    }
    /**
     * Sets the elemental damage of a weapon.
     *
     * @param weapon        the id of the weapon
     * @param type          the elemental damage type
     * @param value         the elemental damage amount
     *
     * @return true on success, false if there was an error
     */
    public static boolean setWeaponElementalDamage(obj_id weapon, int type, int value)
    {
        return (setWeaponElementalType(weapon,type) && setWeaponElementalValue(weapon, value));
    }
/*@}*/

/**
 * @defgroup combat Constants and methods related to combat
 * @{
 */

    /**
     * @defgroup combatStructures Structures used in combat functions
     * @{
     */
        public static class attacker_results
        {
            public obj_id id;                           // attacker id
            public obj_id weapon = null;                // attacker's weapon id
            public string_id weaponName = null;         // weapon name that will be used in combat spam, if we don't want to use the weapon object
            public int    endPosture;                   // end posture of attacker
            public int    clientEffectId = 0;           // deferred effect to play on an attacker.  Lookup done in client data table.
            public int    actionName = 0;               // crc of the name of the special action used for this attack
            public boolean useLocation = false;			// if true, this is a location-based attack, and targetLocation is valid
            public vector targetLocation;				// the world-space location being targetted.
            public obj_id targetCell;                   // the cell of the location being targetted.

            public static final int TRAIL_LFOOT  = 1;
            public static final int TRAIL_RFOOT  = 2;
            public static final int TRAIL_LHAND  = 4;
            public static final int TRAIL_RHAND  = 8;
            public static final int TRAIL_WEAPON = 16;

            /**
             * Turn on or off a specified trail region during
             * combat playback.
             *
             * By default, all trail regions are turned off.
             *
             * @param trailRegion  the trail region to be manipulated.
             *                     Use attacker_results.TRAIL_XXX constants
             *                     for these values.
             * @param turnOn       if true, the trail for the specified region
             *                     will be turned on for the attacker; otherwise,
             *                     the trail for the region will be turned off.
             */
            public void setTrail(int trailRegion, boolean turnOn)
                {
                    if (turnOn)
                        m_trailBits = m_trailBits | trailRegion;
                    else
                        m_trailBits = m_trailBits & ~trailRegion;
                }

            /**
             * Retrieve whether a trail region is turned on or off for the attacker.
             *
             * @param trailRegion  the trail region to be returned.
             *                     Use attacker_results.TRAIL_XXX constants
             *                     for these values.
             *
             * @param return  true if the trail region is turned on; false otherwise.
             */
            public boolean getTrail(int trailRegion)
                {
                    return (m_trailBits & trailRegion) != 0;
                }

            private int   m_trailBits = 0;  // each bit represents whether a trail for that region should be turned on.
}

        public static class defender_results
        {
            public obj_id id;                 // defender id
            public int    endPosture;         // end posture of defender
            public int    result;             // result of the attack
            public int    clientEffectId = 0; // deferred effect to play on an defender.  Lookup done in client data table.
            public int    hitLocation;        // location the defender was hit
            public int    damageAmount = 0;   // amount of damage applied to this defender

            public static defender_results[] createArray(int size)
            {
                if (size < 0)
                    return null;

                defender_results[] array = new defender_results[size];
                for (int i = 0; i < size; ++i)
                    array[i] = new defender_results();
                return array;
            }
        }
    /*@}*/
    /* combatStructures */

    /**
     * @defgroup combatConstants Combat constants
     * @{
     */

        /**
         * @defgroup combatMiss Miss types
         * @{
         */
            /** Normal miss */
            public static final int MISS_NORMAL = 0;
            /** Critical Miss */
            public static final int MISS_FUMBLE = 1;
        /*@}*/
        /* combatMiss*/

        /**
         * @defgroup weaponTypeConstants Weapon type constants from WeaponObjectTemplate.h
         * @{
         */
            /** weapon attack type for rifles */
            public static final int WEAPON_TYPE_RIFLE       = 0;
            /** weapon attack type for light rifles */
            public static final int WEAPON_TYPE_LIGHT_RIFLE = 1;
            /** weapon attack type for melee pistols */
            public static final int WEAPON_TYPE_PISTOL      = 2;
            /** weapon attack type for heavy ranged weapons */
            public static final int WEAPON_TYPE_HEAVY       = 3;
            /** weapon attack type for one-handed melee weapons */
            public static final int WEAPON_TYPE_1HAND_MELEE = 4;
            /** weapon attack type for two-handed melee weapons */
            public static final int WEAPON_TYPE_2HAND_MELEE = 5;
            /** weapon attack type for unarmed attacks */
            public static final int WEAPON_TYPE_UNARMED     = 6;
            /** weapon attack type for polearms */
            public static final int WEAPON_TYPE_POLEARM     = 7;
            /** weapon attack type for thrown weapons */
            public static final int WEAPON_TYPE_THROWN      = 8;
            /** weapon attack types for lightsabers */
            public static final int WEAPON_TYPE_WT_1HAND_LIGHTSABER   = 9;
            public static final int WEAPON_TYPE_WT_2HAND_LIGHTSABER   = 10;
            public static final int WEAPON_TYPE_WT_POLEARM_LIGHTSABER = 11;
            /** these weapons have a special attack type that targets the ground **/
            public static final int WEAPON_TYPE_GROUND_TARGETTING = 12;
            /** these weapons have a special attack type that just shoots in a direction **/
            public static final int WEAPON_TYPE_DIRECTIONAL = 13;
        /*@}*/
         /*weaponTypeConstants*/

        /**
         * @defgroup weaponAttackConstants Weapon attack type constants from WeaponObjectTemplate.h
         * @{
         */
            /** weapon attack type for melee weapons */
            public static final int ATTACK_TYPE_MELEE  = 0;
            /** weapon attack type for ranged weapons */
            public static final int ATTACK_TYPE_RANGED = 1;
            /** weapon attack type for thrown weapons */
            public static final int ATTACK_TYPE_THROWN = 2;
        /*@}*/
         /*weaponAttackConstants*/

        /**
         * @defgroup weaponDamageConstants Weapon damage constants from WeaponObjectTemplate.h
         * @see #damage(obj_id, int, int, int)
         * @{
         */
            public static final int DAMAGE_NONE                       = 0x00000000;
            public static final int DAMAGE_KINETIC                    = 0x00000001;
            public static final int DAMAGE_ENERGY                     = 0x00000002;
            public static final int DAMAGE_BLAST                      = 0x00000004;
            public static final int DAMAGE_STUN                       = 0x00000008;
            public static final int DAMAGE_RESTRAINT                  = 0x00000010;
            public static final int DAMAGE_ELEMENTAL_HEAT             = 0x00000020;
            public static final int DAMAGE_ELEMENTAL_COLD             = 0x00000040;
            public static final int DAMAGE_ELEMENTAL_ACID             = 0x00000080;
            public static final int DAMAGE_ELEMENTAL_ELECTRICAL       = 0x00000100;
            public static final int DAMAGE_ENVIRONMENTAL_HEAT         = 0x00000200;
            public static final int DAMAGE_ENVIRONMENTAL_COLD         = 0x00000400;
            public static final int DAMAGE_ENVIRONMENTAL_ACID         = 0x00000800;
            public static final int DAMAGE_ENVIRONMENTAL_ELECTRICAL   = 0x00001000;
        /*@}*/
          /*weaponDamageConstants*/

        /**
         * @defgroup actionConstants Combat action constants
         * @{
         */
            /** combat action id target, for use in ModifyActionTime */
            public static final int ACTION_TARGET            = 1;
            /** combat action id attack, for use in ModifyActionTime */
            public static final int ACTION_ATTACK            = 2;
            /** combat action id use skill, for use in ModifyActionTime */
            public static final int ACTION_USE_SKILL         = 3;
            /** combat action id aim, for use in ModifyActionTime */
            public static final int ACTION_AIM               = 4;
            /** combat action id change posture, for use in ModifyActionTime */
            public static final int ACTION_CHANGE_POSTURE    = 5;
            /** combat action id change attitude, for use in ModifyActionTime */
            public static final int ACTION_CHANGE_ATTITUDE   = 6;
            /** combat action id reload weapon, for use in ModifyActionTime */
            public static final int ACTION_RELOAD_WEAPON     = 7;
            /** combat action id surrender, for use in ModifyActionTime */
            public static final int ACTION_SURRENDER         = 8;
        /*@}*/
          /*actionConstants*/

        /**
         * @defgroup hitLocations Combat skeleton hit locations, for the triggers
         * OnXCombatAction() and ModifyHitLocation()
         * @{
         */
            public static final int HIT_LOCATION_BODY  = 0;
            public static final int HIT_LOCATION_HEAD  = 1;
            public static final int HIT_LOCATION_R_ARM = 2;
            public static final int HIT_LOCATION_L_ARM = 3;
            public static final int HIT_LOCATION_R_LEG = 4;
            public static final int HIT_LOCATION_L_LEG = 5;
        /*@}*/
          /*hitLocations*/

        /**
         * @defgroup combatResults Possible results of an attack, to be sent to doCombatResults. Also used as the
         * spam channel id for the combat spam functions.
         * @{
         */
            public static final int COMBAT_RESULT_MISS               = 0;
            public static final int COMBAT_RESULT_HIT                = 1;
            public static final int COMBAT_RESULT_BLOCK              = 2;
            public static final int COMBAT_RESULT_EVADE              = 3;
            public static final int COMBAT_RESULT_REDIRECT           = 4;
            public static final int COMBAT_RESULT_COUNTER            = 5;
            public static final int COMBAT_RESULT_FUMBLE             = 6;
            public static final int COMBAT_RESULT_LIGHTSABER_BLOCK   = 7;
            public static final int COMBAT_RESULT_LIGHTSABER_COUNTER = 8;
            public static final int COMBAT_RESULT_LIGHTSABER_COUNTER_TARGET = 9;  // !!!!! this is the last valid combat result that can be used in doCombatResults() - if you change this, make sure method is updated
            public static final int COMBAT_RESULT_GENERIC            = 10;
            public static final int COMBAT_RESULT_OUT_OF_RANGE       = 11;
            public static final int COMBAT_RESULT_POSTURE_CHANGE     = 12;
            public static final int COMBAT_RESULT_TETHERED           = 13; // AI tether is forcing AI home
            public static final int COMBAT_RESULT_MEDICAL            = 14;
            public static final int COMBAT_RESULT_BUFF               = 15;
            public static final int COMBAT_RESULT_DEBUFF             = 16;


        /*@}*/
          /*combatResults*/

    /*@}*/
      /*combatConstants*/

    /**
     * @defgroup combatMethods Combat methods
     *@{
     */

        /**
         * Returns if the combat engine is enabled.
         * @return true if combat is enabled, false if not
         */
        public static native boolean isCombatEnabled();

        /**
         * Returns the current target of an object.
         * @param object        the object
         * @return the object's target
         */
        public static obj_id getTarget(obj_id object)
        {
            return getLookAtTarget(object);
        }

        /**
         * Sets the current target of an object. Note this bypasses the command table.
         * @param object        the object
         * @param target        who the object wants to target
         * @return true on success, false on fail
         */
        public static boolean setTarget(obj_id object, obj_id target)
        {
            return setLookAtTarget(object, target);
        }

        /**
         * Returns the ids of any attackers targeting a given defender.
         * @param defender      the defender being targeted
         * @return an array of obj_id of the attackers targeting the defender
         */
        public static obj_id[] getWhoIsTargetingMe(obj_id defender)
        {
            return getHateList(defender);
        }

        /**
         * Causes an object to sustain combat damage. The damage may be absorbed by any armor the object has.
         * @param target        the object to damage
         * @param type          the type of damage being applied
         * @param location      the hit location of the damage
         * @param amount        the amount of damage being applied
         * @return true on success, false on fail
         */
        private static native boolean _damage(long target, int type, int location, int amount);
        public static boolean damage(obj_id target, int type, int location, int amount)
        {
            return _damage(getLongWithNull(target), type, location, amount);
        }
        /**
         * Applies weapon-based damage to an object.
         * @param targetId      id of the object to damage
         * @param weaponId      id of the weapon doing the damage
         * @param amount        amount of damage to do
         * @param location      where to do the damage
         * @return the true on success, false on error
         */
        private static native boolean _damage(long target, long weapon, int amount, int location);
        public static boolean damage(obj_id target, obj_id weapon, int amount, int location)
        {
            return _damage(getLongWithNull(target), getLongWithNull(weapon), amount, location);
        }
        /**
         * Causes an area of combat damage. Any object in the range will take damage. The damage may be absorbed by any armor the object has.
         * @param center        the object that is at the center of the damage area
         * @param radius        the damage area radius
         * @param type          the type of damage being applied
         * @param amount        the amount of damage being applied
         * @return true on success, false on fail
         */
        private static native boolean _damage(long center, float radius, int type, int amount);
        public static boolean damage(obj_id center, float radius, int type, int amount)
        {
            return _damage(getLongWithNull(center), radius, type, amount);
        }
        /**
         * Causes an area of combat damage. Any object in the range will take damage. The damage may be absorbed by any armor the object has.
         * @param center        the location of the center of the damage area
         * @param radius        the damage area radius
         * @param type          the type of damage being applied
         * @param amount        the amount of damage being applied
         * @return true on success, false on fail
         */
        public static native boolean damage(location center, float radius, int type, int amount);

        /**
        * Puts an attacker into combat towards the defender. If the defender is a player,
        * the defender is additionally put into combat towards the attacker.
        *
        * @param attacker - the object to be put into combat
        * @param defender - the object the attacker is put into combat against
        */
        private static native void _startCombat(long attacker, long defender);
        public static void startCombat(obj_id attacker, obj_id defender)
        {
            _startCombat(getLongWithNull(attacker), getLongWithNull(defender));
        }

        /**
        * DO NOT CALL THIS FUNCTION UNLESS YOU KNOW WHAT YOU ARE DOING!
        * Puts an attacker into combat towards the defender. If the defender is a player,
        * the defender is additionally put into combat towards the attacker.
        *
        * @param attacker - the object to be put into combat
        * @param defender - the object the attacker is put into combat against
        */
        private static native void _startCombatWithAssist(long attacker, long defender);
        public static void startCombatWithAssist(obj_id attacker, obj_id defender)
        {
            _startCombatWithAssist(getLongWithNull(attacker), getLongWithNull(defender));
        }

        /**
        * Removes an object from combat.
        * @param object - the object to be removed from combat
        */
        private static native void _stopCombat(long object);
        public static void stopCombat(obj_id object)
        {
            _stopCombat(getLongWithNull(object));
        }

        /**
         * Handles initializing combatants and finishing up after a combat action has taken
         * place.
         *
         * @param command       the attack command from the command queue
         * @param actor         the attacker
         * @param target        the defender
         * @param params        command params
         *
         * @return JNI_TRUE on success, JNI_FALSE on error
         */
//      public static native int _combatCommandHandler(int command, obj_id actor, obj_id target, String params);

        public static boolean combatCommandHandler(int command, obj_id actor, obj_id target, String params)
        {
            return queueCommand(actor, command, target, params, COMMAND_PRIORITY_DEFAULT);
        }

        /**
         * Gets combat related info for given attackers and defenders.
         *
         * @param attackers         ids of the attackers we want data for
         * @param defenders         ids of the defenders we want data for
         * @param attackerData      data for each attacker
         * @param defenderData      data for each defender
         * @param weaponData        data for each attackers' weapon
         *
         * @return true on success, false on error
         */
        private static native boolean __getCombatData(long[] attackers, long[] defenders, combat_engine.attacker_data[] attackerData, combat_engine.defender_data[] defenderData, combat_engine.weapon_data[] weaponData);
        private static boolean _getCombatData(obj_id[] attackers, obj_id[] defenders, combat_engine.attacker_data[] attackerData, combat_engine.defender_data[] defenderData, combat_engine.weapon_data[] weaponData)
        {
            long[] _attackers = null;
            if (attackers != null)
            {
                _attackers = new long[attackers.length];
                for (int _i = 0; _i < attackers.length; ++_i)
                    _attackers[_i] = getLongWithNull(attackers[_i]);
            }
            long[] _defenders = null;
            if (defenders != null)
            {
                _defenders = new long[defenders.length];
                for (int _i = 0; _i < defenders.length; ++_i)
                    _defenders[_i] = getLongWithNull(defenders[_i]);
            }
            return __getCombatData(_attackers, _defenders, attackerData, defenderData, weaponData);
        }
        /**
         * Gets combat related info for given attackers and defenders.
         *
         * @param attacker          id of the attacker we want data for
         * @param defenders         ids of the defenders we want data for
         * @param attackerData      data for each attacker
         * @param defenderData      data for each defender
         * @param weaponData        data for each attackers' weapon
         *
         * @return true on success, false on error
         */
        public static boolean getCombatData(obj_id attacker, obj_id[] defenders,
            combat_engine.attacker_data attackerData, combat_engine.defender_data[] defenderData, combat_engine.weapon_data weaponData)
        {
            obj_id[] attackers = null;
            combat_engine.attacker_data[] attackersData = null;
            combat_engine.weapon_data[] weaponsData = null;
            if (attacker != null)
            {
                attackers = new obj_id[1];
                attackers[0] = attacker;
                if (attackerData == null)
                {
                    System.err.println("ERROR in Java base_class.getCombatData, attackerData null");
                    return false;
                }
                if (weaponData == null)
                {
                    System.err.println("ERROR in Java base_class.getCombatData, weaponData null");
                    return false;
                }
                attackers = new obj_id[1];
                attackers[0] = attacker;
                attackersData = new combat_engine.attacker_data[1];
                attackersData[0] = attackerData;
                weaponsData = new combat_engine.weapon_data[1];
                weaponsData[0] = weaponData;
                for (int i = 0; i < attackers.length; ++i)
                {
                    if (attackersData[i] == null)
                        attackersData[i] = new combat_engine.attacker_data();
                    attackersData[i].id = attackers[i];
                    if (weaponsData[i] == null)
                        weaponsData[i] = new combat_engine.weapon_data();
                }
            }
            if (defenders != null)
            {
                if (defenderData == null || defenderData.length < defenders.length)
                {
                    System.err.println("ERROR in Java base_class.getCombatData, defenderData null or too small");
                    return false;
                }
                for (int i = 0; i < defenders.length; ++i)
                {
                    if (defenderData[i] == null)
                        defenderData[i] = new combat_engine.defender_data();
                    defenderData[i].id = defenders[i];
                }
            }
            return _getCombatData(attackers, defenders, attackersData, defenderData, weaponsData);
        }   // getCombatData()

        /**
         * Gets combat related info for a given weapon.
         *
         * @param weapon            ids of the weapon
         * @param weaponData        data to be filled in for the weapon
         *
         * @return true on success, false on error
         */
        private static native boolean __getWeaponData(long weapon, combat_engine.weapon_data weaponData);
        private static boolean _getWeaponData(obj_id weapon, combat_engine.weapon_data weaponData)
        {
            return __getWeaponData(getLongWithNull(weapon), weaponData);
        }
        /**
         * Gets combat related info for a given weapon.
         *
         * @param attacker          id of the attacker we want data for
         * @param defenders         ids of the defenders we want data for
         * @param attackerData      data for each attacker
         * @param defenderData      data for each defender
         * @param weaponData        data for each attackers' weapon
         *
         * @return the weapon combat data, or null on error
         */
        public static combat_engine.weapon_data getWeaponData(obj_id weapon)
        {
            if ( weapon == null )
                return null;

            combat_engine.weapon_data data = new combat_engine.weapon_data();
            if (!_getWeaponData(weapon, data))
                data = null;
            return data;
        }   // getWeaponData()

        /**
         * Applies damage to an object being attacked.
         *
         * @param attacker      the attacker
         * @param defender      the defender
         * @param weapon        the attacker's weapon
         * @param damage        amount of damage done
         * @param hitLocation   where the defender was hit
         *
         * @return true on success, false on error
         */
        private static native boolean __doDamage(long attacker, long defender, long weapon, int damage, int hitLocation);
        private static boolean _doDamage(obj_id attacker, obj_id defender, obj_id weapon, int damage, int hitLocation)
        {
            return __doDamage(getLongWithNull(attacker), getLongWithNull(defender), getLongWithNull(weapon), damage, hitLocation);
        }

        /**
         * Applies damage to an object being attacked.
         *
         * @param attacker      the attacker
         * @param defender      the defender
         * @param weapon        the attacker's weapon
         * @param damage        amount of damage done
         * @param hitLocation   where the defender was hit
         *
         * @return true on success, false on error
         */
        public static boolean doDamage(obj_id attacker, obj_id defender, obj_id weapon, combat_engine.hit_result hitResult)
        {
            return _doDamage(attacker, defender, weapon, (hitResult.damage + hitResult.elementalDamage), hitResult.hitLocation);
        }   // doDamage()

		/**
		 * Applies damage to an object being attacked.
		 *
		 * @param attacker		the attacker
		 * @param defender		the defender
		 * @param damage		amount of damage done
		 * @param hitLocation	where the defender was hit
		 *
		 * @return true on success, false on error
		 */
		private static native boolean __doDamageNoWeapon(long attacker, long defender, int damage, int hitLocation);
		public static boolean doDamage(obj_id attacker, obj_id defender, combat_engine.hit_result hitResult)
		{
			return __doDamageNoWeapon(getLongWithNull(attacker), getLongWithNull(defender), (hitResult.damage + hitResult.elementalDamage), hitResult.hitLocation);
		}	// doDamage()

		/**
		 * Creates a package to be sent to the client for displaying combat results.
		 *
		 * @param animationId				name of animation script to play
		 * @param attackerStartPosture		the attacker's start posture
		 * @param attackerEndPosture		the attacker's end posture
		 * @param defenderStartPosture		the defenders' start postures
		 * @param defenderEndPosture		the defenders' end postures
		 *
		 * @return true on success, false on error
		 */
		public static native boolean doCombatResults(String animationId, attacker_results attackerResult, defender_results[] defenderResult);

        /**
         * Triggers OnDefenderCombatAction for a list of defenders.
         * @param defenders     list of defenders to be triggered
         * @param results       list of combat results for each defender
         * @param attacker      the attacker
         * @param weapon        the attacker's weapon (if null, the attacker's current weapon will be used)
         * @return true on success, false on error
         */
        private static native boolean _callDefenderCombatAction(long[] defenders, int[] results, long attacker, long weapon);
        public static boolean callDefenderCombatAction(obj_id[] defenders, int[] results, obj_id attacker, obj_id weapon)
        {
            long[] _defenders = null;
            if (defenders != null)
            {
                _defenders = new long[defenders.length];
                for (int _i = 0; _i < defenders.length; ++_i)
                    _defenders[_i] = getLongWithNull(defenders[_i]);
            }
            return _callDefenderCombatAction(_defenders, results, getLongWithNull(attacker), getLongWithNull(weapon));
        }

        /**
         * Triggers OnDefenderCombatAction for a defender.
         * @param defender      defender to be triggered
         * @param result        combat result for the defender
         * @param attacker      the attacker
         * @param weapon        the attacker's weapon (if null, the attacker's current weapon will be used)
         * @return true on success, false on error
         */
        public static boolean callDefenderCombatAction(obj_id defender, int result, obj_id attacker, obj_id weapon)
        {
            obj_id[] defenders = new obj_id[1];
            defenders[0] = defender;
            int[] results = new int[1];
            results[0] = result;
            return callDefenderCombatAction(defenders, results, attacker, weapon);
        }

        /**
         * Determines if a given attacker hits his opponent.
         *
         * @param attacker      the attacker's data
         * @param defender      the defender's data
         * @param weapon        the attacker's weapon's data
         *
         * @return result of attack
         */
        public static combat_engine.hit_result calculateHit(combat_engine.attacker_data attacker,
            combat_engine.defender_data defender, combat_engine.weapon_data weapon)
        {
            if (attacker == null)
            {
                System.err.println("WARNING: Java base_class.calculateHit received null attacker. Current stack = ");
                Thread.dumpStack();
                return null;
            }
            if (defender == null)
            {
                System.err.println("WARNING: Java base_class.calculateHit received null defender. Current stack = ");
                Thread.dumpStack();
                return null;
            }
            if (weapon == null)
            {
                System.err.println("WARNING: Java base_class.calculateHit received null weapon. Current stack = ");
                Thread.dumpStack();
                return null;
            }

            return combat_engine.calculateHit(attacker, defender, weapon);
        }   // calculateHit()

        /**
         * Determines the attack roll.
         *
         * @param attacker      the attacker's data
         * @param defender      the defender's data
         * @param weapon        the attacker's weapon's data
         *
         * @return the attack roll, along with the unmodified base attack roll
         */
        public static combat_engine.attack_roll_result getAttackRoll(combat_engine.attacker_data attacker,
            combat_engine.defender_data defender, combat_engine.weapon_data weapon)
        {
            return combat_engine.getAttackRoll(attacker, defender, weapon);
        }   // getAttackRoll()

        /**
         * Determines the defense roll.
         *
         * @param attacker      the attacker's data
         * @param defender      the defender's data
         * @param weapon        the attacker's weapon's data
         *
         * @return the defense roll
         */
        public static int getDefenseRoll(combat_engine.attacker_data attacker, combat_engine.defender_data defender,
            combat_engine.weapon_data weapon)
        {
            return combat_engine.getDefenseRoll(attacker, defender, weapon);
        }   // getDefenseRoll()

        /**
         * Determines where a defender got hit.
         *
         * @param defender      the object that was being attacked
         *
         * @return the hit location
         */
        public static int getHitLocation(combat_engine.defender_data defender)
        {
            return combat_engine.getHitLocation(defender);
        }   // getHitLocation()

        /**
         * Determines the base amount of damage a weapon does.
         *
         * @param weapon        the weapon
         *
         * @return the amount of damage
         */
        public static int getDamage(combat_engine.weapon_data weapon)
        {
            return combat_engine.getDamage(weapon);
        }   // getDamage()
        /**
         * Set whether an object is interested in OnSawAttack triggers.
         *
         * @param obj     the object in question
         * @param enable  whether OnSawAttack triggers should be enabled for the object
         */
        private static native void _setWantSawAttackTriggers(long obj, boolean enable);
        public static void setWantSawAttackTriggers(obj_id obj, boolean enable)
        {
            _setWantSawAttackTriggers(getLongWithNull(obj), enable);
        }

        /**
         * Creates a "slow down" effect between an attacker and defender. The effect acts as if
         * there was a hill between the combatants, with the attacker at the top and the defender
         * at the bottom. The area of the effect is a cone between the attacker and defender.
         * The "hill" will be maintained between the combatants even if they move.
         *
         * @param attacker      who is at the top of the hill
         * @param defender      who is at the bottom of the hill
         * @param coneLength    the length of the effect cone
         * @param coneAngle     the angle of the effect cone, in degrees; 0 < angle <= 180
         * @param slopeAngle    the effective angle of the slope in degrees; 1 <= slope < 90
         * @param effectTime    how long the effect will last, in secs
         *
         * @return true on success, false on fail
         */
        private static native boolean _addSlowDownEffect(long attacker, long defender, float coneLength, float coneAngle, float slopeAngle, float effectTime);
        public static boolean addSlowDownEffect(obj_id attacker, obj_id defender, float coneLength, float coneAngle, float slopeAngle, float effectTime)
        {
            return _addSlowDownEffect(getLongWithNull(attacker), getLongWithNull(defender), coneLength, coneAngle, slopeAngle, effectTime);
        }

        /**
         * Causes a slow down effect being used by an attacker to be canceled early.
         * @param attacker      the attacker who is using the effect
         * @return true on success, false on error (bad attacker)
         */
        private static native boolean _removeSlowDownEffect(long attacker);
        public static boolean removeSlowDownEffect(obj_id attacker)
        {
            return _removeSlowDownEffect(getLongWithNull(attacker));
        }

    /*@}*/
    /*combatMethods */
/*@}*/
  /*combat */

    /**
    * @defgroup conversationMethods NPC conversation methods
    */
    /*@{*/

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param greetingOob           the outofband buffer to be appended to the greeting.  Only prose_packages may be packed into the buffer.  May be null.
     * @param responses     the initial responses available to the player.  Each response may either be a string_id or an outofband String buffer containing prose_packages
     */
    private static native boolean __npcStartConversation(long player, long npc, String convoName, string_id greeting, String greetingOob, Object[] responses);
    public static boolean _npcStartConversation(obj_id player, obj_id npc, String convoName, string_id greeting, String greetingOob, Object[] responses)
    {
        return __npcStartConversation(getLongWithNull(player), getLongWithNull(npc), convoName, greeting, greetingOob, responses);
    }

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param greetingOob   the outofband buffer to be appended to the greeting.  Only prose_packages may be packed into the buffer.  May be null.
     * @param responses     the initial responses available to the player.  Each response may either be a string_id or an outofband String buffer containing prose_packages
     * @param appearanceOverrideServerTemplate  an optional parameter holding the name of a template to use an the appearance in any UI window when representing the "talker"
     */
    private static native boolean __npcStartConversationWithOverrideAppearance(long player, long npc, String convoName, string_id greeting, String greetingOob, Object[] responses, String appearanceOverrideServerTemplate);
    public static boolean _npcStartConversationWithOverrideAppearance(obj_id player, obj_id npc, String convoName, string_id greeting, String greetingOob, Object[] responses, String appearanceOverrideServerTemplate)
    {
        return __npcStartConversationWithOverrideAppearance(getLongWithNull(player), getLongWithNull(npc), convoName, greeting, greetingOob, responses, appearanceOverrideServerTemplate);
    }

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param responses     the initial responses available to the player.
     */

    public static boolean npcStartConversation(obj_id player, obj_id npc, String convoName, string_id greeting, string_id[] responses)
    {
        Object [] objects = new Object [responses.length];
        java.lang.System.arraycopy (responses, 0, objects, 0, responses.length);
        return _npcStartConversation (player, npc, convoName, greeting, null, objects);

    }

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param responses     the initial responses available to the player.
     */
    public static boolean npcStartConversation(obj_id player, obj_id npc, String convoName, string_id greeting, Vector responses)
    {
        return _npcStartConversation (player, npc, convoName, greeting, null, responses.toArray());
    }

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param greetingProse         the greeting the NPC will give the the player.  May be null.
     * @param responses     the initial responses available to the player.
     */

    public static boolean npcStartConversation(obj_id player, obj_id npc, String convoName, string_id greetingId, prose_package greetingProse, Object[] responses)
    {
        String oob = null;

        if (greetingProse != null)
        {
            oob = packOutOfBandProsePackage (oob, -1, greetingProse);
        }

        return _npcStartConversation (player, npc, convoName, greetingId, oob, responses);
    }

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param responses     the initial responses available to the player.
     * @param appearanceOverrideServerTemplate  an optional parameter holding the name of a template to use an the appearance in any UI window when representing the "talker"
     */

    public static boolean npcStartConversation(obj_id player, obj_id npc, String convoName, string_id greeting, string_id[] responses, String appearanceOverrideServerTemplate)
    {
        Object [] objects = new Object [responses.length];
        java.lang.System.arraycopy (responses, 0, objects, 0, responses.length);
        return _npcStartConversationWithOverrideAppearance (player, npc, convoName, greeting, null, objects, appearanceOverrideServerTemplate);

    }

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param responses     the initial responses available to the player.
     * @param appearanceOverrideServerTemplate  an optional parameter holding the name of a template to use an the appearance in any UI window when representing the "talker"
     */
    public static boolean npcStartConversation(obj_id player, obj_id npc, String convoName, string_id greeting, Vector responses, String appearanceOverrideServerTemplate)
    {
        return _npcStartConversationWithOverrideAppearance (player, npc, convoName, greeting, null, responses.toArray(), appearanceOverrideServerTemplate);
    }

    /**
     * Starts a conversation between a player and an NPC.
     *
     * @param player        the player
     * @param npc           the NPC
     * @param convoName     the name of the conversation, must be less than 255 chars; will be passed to the trigger OnNpcConversationResponse
     * @param greeting      the greeting the NPC will give to the player.  It will attempt to localize on the server, and if that fails, the client will try.  May be null.
     * @param greetingProse         the greeting the NPC will give the the player.  May be null.
     * @param responses     the initial responses available to the player.
     * @param appearanceOverrideServerTemplate  an optional parameter holding the name of a template to use an the appearance in any UI window when representing the "talker"
     */

    public static boolean npcStartConversation(obj_id player, obj_id npc, String convoName, string_id greetingId, prose_package greetingProse, Object[] responses, String appearanceOverrideServerTemplate)
    {
        String oob = null;

        if (greetingProse != null)
        {
            oob = packOutOfBandProsePackage (oob, -1, greetingProse);
        }

        return _npcStartConversationWithOverrideAppearance (player, npc, convoName, greetingId, oob, responses, appearanceOverrideServerTemplate);
    }

    private static native boolean _npcEndConversationWithMessage(long player, string_id text, String oob);
    public static boolean npcEndConversationWithMessage(obj_id player, string_id text)
    {
        return _npcEndConversationWithMessage(getLongWithNull(player), text, null);
    }

    public static boolean npcEndConversationWithMessage(obj_id player, prose_package pp)
    {
        String oob = packOutOfBandProsePackage (null, pp);
        return _npcEndConversationWithMessage(getLongWithNull(player), null, oob);
    }

    /**
     * Ends a player's current conversation.
     *
     * @param player        the player
     */
    private static native boolean _npcEndConversation(long player);
    public static boolean npcEndConversation(obj_id player)
    {
        return _npcEndConversation(getLongWithNull(player));
    }

    /**
     * Has the NPC a player is in conversation with say something to the player.
     *
     * @param player        the player
     * @param text          the message the npc will say to the player.  May be null if oob is not.
     * @param oob                   the out of band buffer may contain prose packages only.  May be null if text is not.
     */

    private static native boolean __npcSpeak(long player, string_id text, String oob);
    public static boolean _npcSpeak(obj_id player, string_id text, String oob)
    {
        return __npcSpeak(getLongWithNull(player), text, oob);
    }

    /**
     * Has the NPC a player is in conversation with say something to the player.
     *
     * @param player        the player
     * @param text          the message the npc will say to the player.  May not be null.
     */

    public static boolean npcSpeak(obj_id player, string_id text)
    {
        return _npcSpeak (player, text, null);
    }

    /**
     * Has the NPC a player is in conversation with say something to the player.
     *
     * @param player        the player
     * @param pp            the message the npc will say to the player.  May not be null.
     */

    public static boolean npcSpeak(obj_id player, prose_package pp)
    {
        String oob = packOutOfBandProsePackage (null, -1, pp);
        return _npcSpeak (player, null, oob);
    }

    /**
     * Sets the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param responses     the responses available to the player.  Each element must be a string_id or a String oob containing only prose_packages
     */
    private static native boolean __npcSetConversationResponses(long player, Object[] responses);
    public static boolean _npcSetConversationResponses(obj_id player, Object[] responses)
    {
        return __npcSetConversationResponses(getLongWithNull(player), responses);
    }

    /**
     * Sets the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param responses     the responses available to the player
     */
    public static boolean npcSetConversationResponses(obj_id player, string_id[] responses)
    {
        Object [] objects = new Object [responses.length];
        java.lang.System.arraycopy (responses, 0, objects, 0, responses.length);
        return _npcSetConversationResponses (player, objects);
    }

    /**
     * Sets the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param responses     the responses available to the player
     */
    public static boolean npcSetConversationResponses(obj_id player, Vector responses)
    {
        if (responses == null)
            return false;
        return _npcSetConversationResponses (player, responses.toArray());
    }


    /**
     * Sets the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param responses     the responses available to the player
     */
    public static boolean npcSetConversationResponses(obj_id player, prose_package[] responses)
    {
        Object [] objects = new Object [responses.length];
        for (int i = 0; i < responses.length; ++i)
        {
            objects [i] = packOutOfBandProsePackage (null, -1, responses [i]);
        }
        return _npcSetConversationResponses (player, objects);
    }

    /**
     * Adds a response to the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param response      the response to add.  May be null if oob is not.
     * @param oob                   the oob to add.  May contain only prose_packages.  May be null if response is not.
     */
    private static native boolean __npcAddConversationResponse(long player, string_id response, String oob);
    public static boolean _npcAddConversationResponse(obj_id player, string_id response, String oob)
    {
        return __npcAddConversationResponse(getLongWithNull(player), response, oob);
    }

    /**
     * Adds a response to the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param response      the response to add.  May not be null.
     */
    public static boolean npcAddConversationResponse(obj_id player, string_id response)
    {
        return _npcAddConversationResponse (player, response, null);
    }

    /**
     * Adds a response to the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param pp                the response to add.  May not be null.
     */

    public static boolean npcAddConversationResponse(obj_id player, prose_package pp)
    {
        String oob = packOutOfBandProsePackage (null, -1, pp);
        return _npcAddConversationResponse (player, null, oob);
    }

    /**
     * Removes a response from the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param response      the response to remove.  The string_id will match prose_packages in the responses as well
     */
    private static native boolean _npcRemoveConversationResponse(long player, string_id response);
    public static boolean npcRemoveConversationResponse(obj_id player, string_id response)
    {
        return _npcRemoveConversationResponse(getLongWithNull(player), response);
    }

    /**
     * Checks to see if an NPC or player is in a conversation.
     *
     * @param creature      the NPC or player we want to know about
     *
     * @return true if creature is in a conversastion, false if not
     */
    private static native boolean _isInNpcConversation(long creature);
    public static boolean isInNpcConversation(obj_id creature)
    {
        return _isInNpcConversation(getLongWithNull(creature));
    }

    /**
     * Removes a response from the available responses for a player to select in a conversation with an NPC.
     *
     * @param player        the player
     * @param response      the response to remove
     */
    private static native long[] _getNpcConversants(long creature);
    public static obj_id[] getNpcConversants(obj_id creature)
    {
        long[] _ret_long = _getNpcConversants(getLongWithNull(creature));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

/*@}*/

    /**
    * @defgroup animationMethods animation, sound, and special effect methods
    */
/*@{*/
    private static native void   _doAnimationAction(long target, String animationActionName);
    public static void   doAnimationAction (obj_id target, String animationActionName)
    {
        _doAnimationAction(getLongWithNull(target), animationActionName);
    }
    private static native void   _setAnimationMood(long target, String moodName);
    public static void   setAnimationMood (obj_id target, String moodName)
    {
        _setAnimationMood(getLongWithNull(target), moodName);
    }
    private static native String _getAnimationMood(long target);
    public static String getAnimationMood (obj_id target)
    {
        return _getAnimationMood(getLongWithNull(target));
    }

    /**
     * Instruct the clients to display the sitterId object sitting on the targetId object.
     *
     * This function should be used when the sitting creature is supposed to be sitting
     * on a chair-like object.  This function should not be used for mounting a vehicle
     * or creature.
     *
     * @param sitterId       the object id for the player/creature that should sit on an object.
     * @param chairId        the object id for the chair-like object on which the player/creature will sit.
     * @param positionIndex  the 0-based index for the position of the chair-like object at which
     *                       the player/creature is sitting.  Typically this value is zero, but
     *                       for multi-seat objects (like a couch) it may need to be larger.
     */
    private static native boolean  _sitOnObject(long sitterId, long chairId, int positionIndex);
    public static boolean  sitOnObject(obj_id sitterId, obj_id chairId, int positionIndex)
    {
        return _sitOnObject(getLongWithNull(sitterId), getLongWithNull(chairId), positionIndex);
    }

/*@}*/

    /**
    * @defgroup installationMethods installation methods
    */
/*@{*/

    /**
     * Cause the harvester object to package up its resource data and send it to the
     * specified player.
     *
     * @param player          the player object to which to send the data
     * @param harvester       the harvester object in question
     * @param resourceIds     an array of networkids for the resource objects
     *
     */
//  public static native void sendHarvesterResourceData (obj_id player, obj_id harvester, obj_id[] resourceIds);

    /**
     * Cause the harvester object to package up its status and send it to the player
     *
     * @param player          the player object to which to send the data
     * @param harvester       the harvester object in question
     *
     */
//  public static native void sendHarvesterStatus (obj_id player, obj_id harvester);

    /**
     * Causes the client to activate the harvester GUI.
     * @param player          the player object to which to send the data
     * @param harvester       the harvester object in question
     */
     private static native void _activateHarvesterExtractionPage(long player, long harvester);
     public static void activateHarvesterExtractionPage (obj_id player, obj_id harvester)
     {
        _activateHarvesterExtractionPage(getLongWithNull(player), getLongWithNull(harvester));
     }

    /**
     * Get the number of resources yielded per unit time for the harvester, as it is
     * currently installed.
     *
     * @param installation the harvester object in question
     */
    private static native int          _getInstalledExtractionRate(long installation);
    public static int          getInstalledExtractionRate(obj_id installation)
    {
        return _getInstalledExtractionRate(getLongWithNull(installation));
    }
    /**
     * Is the harvester currently running?
     *
     * @return true if the harvester is currently running
     */
    private static native boolean      _isHarvesterActive(long installation);
    public static boolean      isHarvesterActive(obj_id installation)
    {
        return _isHarvesterActive(getLongWithNull(installation));
    }
    /**
     * Does the harvester contain any resources?
     *
     * @return true if the harvester has no resources in its hopper
     */
    private static native boolean      _isHarvesterEmpty(long installation);
    public static boolean      isHarvesterEmpty(obj_id installation)
    {
        return _isHarvesterEmpty(getLongWithNull(installation));
    }
    /**
     * Get the maximum number of resources yielded per unit time for the harvester,
     * if it were undamaged, fully powered, installed on a perfect spot, etc.
     * @param installation the harvester object in question
     */
    private static native int          _getMaxExtractionRate(long installation);
    public static int          getMaxExtractionRate(obj_id installation)
    {
        return _getMaxExtractionRate(getLongWithNull(installation));
    }
    /**
     * Set the maximum number of resources yielded per unit time for the harvester,
     * if it were undamaged, fully powered, installed on a perfect spot, etc.
     * Use this when adding an upgrade to the harvester, for example.
     *
     * @param installation the harvester object in question
     * @param value the new extraction rate
     * @return true on success   * @param player          the player object to which to send the data
     * @param harvester       the harvester object in question

     */
    private static native boolean      _setMaxExtractionRate(long installation, int value);
    public static boolean      setMaxExtractionRate(obj_id installation, int value)
    {
        return _setMaxExtractionRate(getLongWithNull(installation), value);
    }
    /**
     * Get the number of resources yielded per unit time for the harvester,
     * if it were installed on a perfect spot.  (Takes into account power, damage, etc., but
     * not the efficiency map.)
     * @param installation the harvester object in question
     */
    private static native int          _getCurrentExtractionRate(long installation);
    public static int          getCurrentExtractionRate(obj_id installation)
    {
        return _getCurrentExtractionRate(getLongWithNull(installation));
    }
    /**
     * Set the number of resources yielded per unit time for the harvester,
     * if it were installed on a perfect spot.  Use this when taking damage or computing
     * power effects, for example.
     * @param installation the harvester object in question
     * @param value the new extraction rate
     * @return true on success
     */
    private static native boolean      _setCurrentExtractionRate(long installation, int value);
    public static boolean      setCurrentExtractionRate(obj_id installation, int value)
    {
        return _setCurrentExtractionRate(getLongWithNull(installation), value);
    }
    /**
     * Get the maximum number of resources that can be in the harvester's hopper.
     * @param installation the harvester object in question
     */
    private static native int          _getMaxHopperAmount(long installation);
    public static int          getMaxHopperAmount(obj_id installation)
    {
        return _getMaxHopperAmount(getLongWithNull(installation));
    }
    /**
     * Set the maximum number of resources that can be in the harvester's hopper.
     * @param installation the harvester object in question
     */
    private static native boolean      _setMaxHopperAmount(long installation, int value);
    public static boolean      setMaxHopperAmount(obj_id installation, int value)
    {
        return _setMaxHopperAmount(getLongWithNull(installation), value);
    }
    /**
     * Turn the harvester on.  Start collecting resources.
     * @param installation the harvester object in question
     * @return true on success
     */
    private static native boolean      _activate(long installation);
    public static boolean      activate(obj_id installation)
    {
        return _activate(getLongWithNull(installation));
    }
    /**
     * Turn the harvester off.  Stop collecting resources.
     * @param installation the harvester object in question
     * @return true on success
     */
    private static native boolean      _deactivate(long installation);
    public static boolean      deactivate(obj_id installation)
    {
        return _deactivate(getLongWithNull(installation));
    }

    /**
     * Displays a set of structure permission data for a player to administer.
     * @param currentMembers    the list of members currently in the list
     * @param nearbyPeople      a list of people to pre-seed for adding to the list
     * @param listName          name of the list to add on a structure, since it might have > 1 (i.e. ban list, friends list, admin list, etc.)
     */
    private static native void _displayStructurePermissionData(long player, String[] currentMembers, String[] nearbyPeople, String listName);
    public static void displayStructurePermissionData(obj_id player, String[] currentMembers, String[] nearbyPeople, String listName)
    {
        _displayStructurePermissionData(getLongWithNull(player), currentMembers, nearbyPeople, listName);
    }

    /**
     * Returns an installation's power value.
     * @param target        id of the installation
     * @return the power value
     */
    private static native float _getPowerValue(long target);
    public static float getPowerValue(obj_id target)
    {
        return _getPowerValue(getLongWithNull(target));
    }

    /**
     * Sets an installation's power value.
     * @param target        id of the installation
     * @return true on success, false if there was an error
     */
    private static native boolean _setPowerValue(long target, float value);
    public static boolean setPowerValue(obj_id target, float value)
    {
        return _setPowerValue(getLongWithNull(target), value);
    }

    /**
     * Changes an installation's power value.
     * @param target        id of the installation
     * @param value         the amount to change the power by
     * @return true on success, false if there was an error
     */
    private static native boolean _incrementPowerValue(long target, float value);
    public static boolean incrementPowerValue(obj_id target, float value)
    {
        return _incrementPowerValue(getLongWithNull(target), value);
    }

    /**
     * Returns an installation's power consumption rate, in units/hour.
     * @param target        id of the installation
     * @return the power rate
     */
    private static native float _getPowerRate(long target);
    public static float getPowerRate(obj_id target)
    {
        return _getPowerRate(getLongWithNull(target));
    }

    /**
     * Sets an installation's power consumption rate, in units/hour.
     * @param target        id of the installation
     * @return true on success, false if there was an error
     */
    private static native boolean _setPowerRate(long target, float value);
    public static boolean setPowerRate(obj_id target, float value)
    {
        return _setPowerRate(getLongWithNull(target), value);
    }

    /**
     * Request that the list of possible resources for a survey be sent
     * to the specified player.
     * @param player The player who will recieve the resource list.
     * @param tool The tool that is generating the survey request
     * @param parentResourceClassName Only show resources derived from this class.
     */
    private static native boolean      _requestResourceListForSurvey(long player, long tool, String parentResourceClass);
    public static boolean      requestResourceListForSurvey(obj_id player, obj_id tool, String parentResourceClass)
    {
        return _requestResourceListForSurvey(getLongWithNull(player), getLongWithNull(tool), parentResourceClass);
    }
    /**
     * Take a survey.
     * @param player The player who will recieve the survey.  (Also determines the location of the survey.)
     * @param parentResourceClassName Only allow the survey if the resource type derives from this class.
     * @param resourceTypeName The type of resource to survey.
     * @param surveyRange The maximum distance away from the player the survey reaches.
     * @param numPoints The number of points on a side for the survey. (the total number of points surveyed will be
     * this number squared.)
     */
    private static native boolean      _requestSurvey(long player, String parentResourceClass, String resourceTypeName, int surveyRange, int numPoints);
    public static boolean      requestSurvey(obj_id player, String parentResourceClass, String resourceTypeName, int surveyRange, int numPoints)
    {
        return _requestSurvey(getLongWithNull(player), parentResourceClass, resourceTypeName, surveyRange, numPoints);
    }
    /**
     * Choose a resource type that has a non-depleted pool on the current planet.
     * @param parentResourceClass restrict the results to something derived from this class
     * @return Object id of the ResourceTypeObject
     */
    private static native long       _pickRandomNonDepeletedResource(String parentResourceClass);
    public static obj_id       pickRandomNonDepeletedResource(String parentResourceClass)
    {
        return getObjIdWithNull(_pickRandomNonDepeletedResource(parentResourceClass));
    }
    /**
     * Harvest resources, one time only
     * @param resourceType The object id of the resource type to harvest
     * @param amount How much to harvest if the effeciency at the location were 100%
     * @param spot Where to harvest the resource.  Must be in the world, i.e. not in a cell.
     * @return The actual amount harvested
     */
    private static native int          _oneTimeHarvest(long resourceType, int amount, location spot);
    public static int          oneTimeHarvest(obj_id resourceType, int amount, location spot)
    {
        return _oneTimeHarvest(getLongWithNull(resourceType), amount, spot);
    }
/*@}*/

    /**
    * @defgroup resourceMethods resource methods
    */
/*@{*/

    /**
     * Add resources to a container.
     * @param resourceContainer The object id of the resource container.
     * @param resourceType The object id of thre resource type.
     * @param amount The amount to add
     * @param sourcePlayer The player who harvested this resource (for experience)
     */
    private static native boolean      _addResourceToContainer(long resourceContainer, long resourceType, int amount, long sourcePlayer);
    public static boolean      addResourceToContainer(obj_id resourceContainer, obj_id resourceType, int amount, obj_id sourcePlayer)
    {
        return _addResourceToContainer(getLongWithNull(resourceContainer), getLongWithNull(resourceType), amount, getLongWithNull(sourcePlayer));
    }
    /**
     * Remove resources from a container.
     * @param resourceContainer The object id of the resource container.
     * @param resourceType The object id of thre resource type.
     * @param amount The amount to remove
     */
    private static native boolean      _removeResourceFromContainer(long resourceContainer, long resourceType, int amount);
    public static boolean      removeResourceFromContainer(obj_id resourceContainer, obj_id resourceType, int amount)
    {
        return _removeResourceFromContainer(getLongWithNull(resourceContainer), getLongWithNull(resourceType), amount);
    }
    /**
     * Transfer resources from one container to another
     * @param sourceResourceContainer The object id of the source container
     * @param destinationResourceContainer The object id of the destination container
     * @param amount The amount of resource to transfer
     */
    private static native boolean      _transferToResourceContainer(long sourceResourceContainer, long destinationResourceContainer, int amount);
    public static boolean      transferToResourceContainer(obj_id sourceResourceContainer, obj_id destinationResourceContainer, int amount)
    {
        return _transferToResourceContainer(getLongWithNull(sourceResourceContainer), getLongWithNull(destinationResourceContainer), amount);
    }
    /**
     * Get the ResourceType contained in a container
     *
     * @param resourceContainer   the resource container
     * @return A reference to the ResourceTypeObject
     */
    private static native long _getResourceContainerResourceType(long resourceContainer);
    public static obj_id getResourceContainerResourceType(obj_id resourceContainer)
    {
        return getObjIdWithNull(_getResourceContainerResourceType(getLongWithNull(resourceContainer)));
    }
    /**
     * Get the quantity of resources in a container.
     *
     * @param resourceContainer   the resource container
     * @return the amount
     */
    private static native int _getResourceContainerQuantity(long resourceContainer);
    public static int getResourceContainerQuantity(obj_id resourceContainer)
    {
        return _getResourceContainerQuantity(getLongWithNull(resourceContainer));
    }
    /**
     * For CTS of resource container, get a string that contains the various resource information
     * which will be used on the destination cluster to reconstruct the resource container
     *
     * @param resourceContainer   the resource container
     * @return the resource information string
     */
    private static native String _getResourceCtsData(long resourceContainer);
    public static String getResourceCtsData(obj_id resourceContainer)
    {
        return _getResourceCtsData(getLongWithNull(resourceContainer));
    }
    /**
     * For CTS of resource container, apply the string that contains the
     * various resource information to the specified resource container
     *
     * @param resourceContainer   the resource container
     * @param quantity            the amount of resource to set the container to
     * @param resourceData        the string containing the resource data
     */
    private static native void _setResourceCtsData(long resourceContainer, int quantity, String resourceData);
    public static void setResourceCtsData(obj_id resourceContainer, int quantity, String resourceData)
    {
        _setResourceCtsData(getLongWithNull(resourceContainer), quantity, resourceData);
    }
    /**
     * Get the value of the resource efficiency map at a specific location
     * @param resourceType The object id of the resource type
     * @param where The location to test
     */
    private static native float        _getResourceEfficiency(long resourceType, location where);
    public static float        getResourceEfficiency(obj_id resourceType, location where)
    {
        return _getResourceEfficiency(getLongWithNull(resourceType), where);
    }
    /**
     * Return true if the resource type is derived from the specified class
     * @param resourceType The object id of the resource type
     * @param parentResourceClass The name of the parent class
     */
    private static native boolean      _isResourceDerivedFrom(long resourceType, String parentResourceClass);
    public static boolean      isResourceDerivedFrom(obj_id resourceType, String parentResourceClass)
    {
        return _isResourceDerivedFrom(getLongWithNull(resourceType), parentResourceClass);
    }
    /**
     * Return true if the resource class is derived from the specified class
     * @param resourceType The name of the resource class
     * @param parentResourceClass The name of the parent class
     */
    public static native boolean      isResourceClassDerivedFrom(String resourceClass, String parentResourceClass);
    /**
     * Get the object id for a resource type
     * @param typeName The name of the resource type
     * @return The object id of the resource type
     */
    private static native long       _getResourceTypeByName(String typeName);
    public static obj_id       getResourceTypeByName(String typeName)
    {
        return getObjIdWithNull(_getResourceTypeByName(typeName));
    }
    /**
     * Get the crate for a resource type
     * @param typeName The name of the resource type
     * @return The name of the crate that holds the specified type of resource
     */
    private static native String       _getResourceContainerForType(long resourceType);
    public static String       getResourceContainerForType(obj_id resourceType)
    {
        return _getResourceContainerForType(getLongWithNull(resourceType));
    }
    /**
     * Returns the name of a given resource type.
     * @param resourceType The resource type id
     * @return the resource type name, or null on error
     */
    private static native String _getResourceName(long resourceType);
    public static String getResourceName(obj_id resourceType)
    {
        return _getResourceName(getLongWithNull(resourceType));
    }
    /**
     * Returns the names for given resource types.
     * @param resourceTypes The resource type ids
     * @return the resource type names, or null on error
     */
    private static native String[] _getResourceNames(long[] resourceTypes);
    public static String[] getResourceNames(obj_id[] resourceTypes)
    {
        long[] _resourceTypes = null;
        if (resourceTypes != null)
        {
            _resourceTypes = new long[resourceTypes.length];
            for (int _i = 0; _i < resourceTypes.length; ++_i)
                _resourceTypes[_i] = getLongWithNull(resourceTypes[_i]);
        }
        return _getResourceNames(_resourceTypes);
    }
    /**
     * Returns the friendly name of a given resource class.
     * @param resourceClass The resource class name
     * @return the friendly resource class name, or null on error
     */
    public static native String getResourceClassName(String resourceClass);
    /**
     * Returns the friendly names of given resource classes.
     * @param resourceClasses The resource class names
     * @return the friendly resource class names, or null on error
     */
    public static native String[] getResourceClassNames(String[] resourceClasses);
    /**
     * Returns the resources types associated with a given resource class.
     * @param resourceClass The resource class name
     * @return the resource type ids for the given resource class, or null on error
     */
    private static native long[] _getResourceTypes(String resourceClass);
    public static obj_id[] getResourceTypes(String resourceClass)
    {
        long[] _ret_long = _getResourceTypes(resourceClass);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Returns the resource class for a given resource type.
     * @param resourceType The resource type id
     * @return the resource class name, or null on error
     */
    private static native String _getResourceClass(long resourceType);
    public static String getResourceClass(obj_id resourceType)
    {
        return _getResourceClass(getLongWithNull(resourceType));
    }
    /**
     * Returns the parent resource class of a given resource class.
     * @param resourceClass The resource class name to get the parent of
     * @return the parent's name, or null of an error or if the given class is the top-level resource class
     */
    public static native String getResourceParentClass(String resourceClass);
    /**
     * Returns the children of a given resource class. Note that we return the entire child tree,
     * not just the top-level chilren of the class.
     * @param resourceClass The resource class name to get the children of
     * @return an array of the resource class' children's names, or null on error
     */
    public static native String[] getResourceChildClasses(String resourceClass);
    /**
     * Returns the immediate children of a given resource class.
     * @param resourceClass The resource class name to get the children of
     * @return an array of the resource class' children's names, or null on error
     */
    public static native String[] getImmediateResourceChildClasses(String resourceClass);
    /**
     * Returns the bottom-most children of a given resource class.
     * @param resourceClass The resource class name to get the children of
     * @return an array of the resource class' children's names, or null on error
     */
    public static native String[] getLeafResourceChildClasses(String resourceClass);
    /**
     * Checks if a given resource class has a resource type available.
     * @param resourceClass The resource class name to test
     * @return true if there is a resource type of the given class, false if not
     */
    public static native boolean hasResourceType(String resourceClass);
    /**
     * Creates a new resource crate in a volume container. Note that the new crate may be auto-combined with
     * any other resource crates of the same type in the container.
     * @param resourceType The resource type we want the crate to contain
     * @param amount The amount of resources the crate will have
     * @param destination The volume container the crate will be created in
     * @return the id of the new resource crate (or the crate the new one was combined with), or null on error
     */
    private static native long _createResourceCrate(long resourceType, int amount, long destination);
    public static obj_id createResourceCrate(obj_id resourceType, int amount, obj_id destination)
    {
        return getObjIdWithNull(_createResourceCrate(getLongWithNull(resourceType), amount, getLongWithNull(destination)));
    }
    /**
     * Finds all the resources, derived from a given resource class, at a given location with a density/efficiency within a given range.
     * @param loc The location to look for resources in. Make sure this is a world location, and to include the scene id!
     * @param minDensity The minimum density the resource type must have
     * @param maxDensity The maximum density the resource type must have
     * @param resourceClass The base resource class for resources we will look for
     * @return an array of resource type/densities that meet the criteria, or null on error
     */
    public static native resource_density[] requestResourceList(location loc, float minDensity, float maxDensity, String resourceClass);
    /**
     * Get all the attributes for a resource type
     * @param resource The id of the resource type
     * @return an array of resource attributes, or null on error
     */
    private static native resource_attribute[] _getResourceAttributes(long resourceType);
    public static resource_attribute[] getResourceAttributes(obj_id resourceType)
    {
        return _getResourceAttributes(getLongWithNull(resourceType));
    }
    /**
     * Get all the attributes for a resource type, scaled for a particular resource class range
     * @param resourceType The id of the resource type
     * @param resourceClass The resource class that will define the scaling range
     * @return an array of resource attributes, or null on error
     */
    private static native resource_attribute[] _getScaledResourceAttributes(long resourceType, String resourceClass);
    public static resource_attribute[] getScaledResourceAttributes(obj_id resourceType, String resourceClass)
    {
        return _getScaledResourceAttributes(getLongWithNull(resourceType), resourceClass);
    }
    /**
     * Get an attribute for a resource
     * @param resource The id of the resource
     * @param attribute The name of the attribute
     * @return The value of the attribute, or -1 if the parameters were invalid.
     */
    private static native int _getResourceAttribute(long resource, String attribute);
    public static int getResourceAttribute(obj_id resource, String attribute)
    {
        return _getResourceAttribute(getLongWithNull(resource), attribute);
    }
    /**
     * Given a resource type, find the corresponding recycled resource type
     * @param resource The id of the resource
     * @return The id of the recycled resource
     */
    private static native long _getRecycledVersionOfResourceType(long resourceType);
    public static obj_id getRecycledVersionOfResourceType(obj_id resourceType)
    {
        return getObjIdWithNull(_getRecycledVersionOfResourceType(getLongWithNull(resourceType)));
    }
    /**
     * Checks if a given resource type id is a valid resource id.
     * @param resourceType The resource type id to test
     * @return true if there is a valid resource type for the given id, false if not
     */
    private static native boolean _isValidResourceId(long resourceType);
    public static boolean isValidResourceId(obj_id resourceType)
    {
        return _isValidResourceId(getLongWithNull(resourceType));
    }

    /**
     * Tests if an object is a resource container or not.
     * @param object the object to test
     * @param return true if the object is a resource container, false if not
     */
    public static boolean isResourceContainer(obj_id object)
    {
        if ( !isIdValid(object) )
            return false;
        int got = getGameObjectType(object);
        return (got & GOT_resource_container) != 0;
    }
/*@}*/

    /** @defgroup crafting data and functions used in the crafting and manufacturing processes
    *@{ */

        /** @defgroup craftingTypes
         *@{ */
            // crafting station/tool types - also defined in server object_template.tdf
            public static final int CT_weapon           = 0x00000001;
            public static final int CT_armor            = 0x00000002;
            public static final int CT_food             = 0x00000004;
            public static final int CT_clothing         = 0x00000008;
            public static final int CT_vehicle          = 0x00000010;
            public static final int CT_droid            = 0x00000020;
            public static final int CT_chemical         = 0x00000040;
            public static final int CT_plantBreeding    = 0x00000080;
            public static final int CT_animalBreeding   = 0x00000100;
            public static final int CT_furniture        = 0x00000200;
            public static final int CT_installation     = 0x00000400;
            public static final int CT_lightsaber       = 0x00000800;
            public static final int CT_genericItem      = 0x00001000;
            public static final int CT_genetics                 = 0x00002000;
            public static final int CT_mandalorianTailor        = 0x00004000;
            public static final int CT_mandalorianArmorsmith    = 0x00008000;
            public static final int CT_mandalorianDroidEngineer = 0x00010000;
            public static final int CT_space                    = 0x00020000;
            public static final int CT_reverseEngineering       = 0x00040000;
            public static final int CT_misc                     = 0x00080000;
            public static final int CT_spaceComponent           = 0x00100000;
            // note that CT_mission is a modifier to the above crafting
            // types to flag a schematic that is used in a mission
            public static final int CT_mission                  = 0x80000000;
        /*@}*/

        /** @defgroup craftingStages
         *@{ */
            public static final int CS_none                 = 0;
            public static final int CS_selectDraftSchematic = 1;
            public static final int CS_assembly             = 2;
            public static final int CS_experiment           = 3;
            public static final int CS_customize            = 4;
            public static final int CS_finish               = 5;
        /*@}*/

        /**
         * Starts a crafting session. This should be called in response to a player
         * selecting a "start crafting" radial menu selection when clicking on a
         * crafting tool.
         *
         * @param player    the player who will be crafting
         * @param tool      the crafting tool a player will be using
         *
         * @return true if the session was started, false if not
         **/
        private static native boolean _startCraftingSession(long player, long tool);
        public static boolean startCraftingSession(obj_id player, obj_id tool)
        {
            return _startCraftingSession(getLongWithNull(player), getLongWithNull(tool));
        }

        /**
         * Signals the end of a crafting session. Called when a prototype is done being crafted.
         *
         * @param crafter       the crafter
         * @param tool          the crafting tool being used
         * @param prototype     the prototype being created (may be null)
         *
         * @return true on success, false on error
         **/
        private static native boolean _endCraftingSession(long crafter, long tool, long prototype);
        public static boolean endCraftingSession(obj_id crafter, obj_id tool, obj_id prototype)
        {
            return _endCraftingSession(getLongWithNull(crafter), getLongWithNull(tool), getLongWithNull(prototype));
        }

        /**
         * Sets the crafting level and station of a player's crafting session.
         *
         * @param player            the player who's crafting
         * @param craftingLevel     the crafting level of the session
         * @param station           the crafting station of the session
         *
         * @return true if the data was set, false on error
         */
        private static native boolean _setCraftingLevelAndStation(long player, int craftingLevel, long station);
        public static boolean setCraftingLevelAndStation(obj_id player, int craftingLevel, obj_id station)
        {
            return _setCraftingLevelAndStation(getLongWithNull(player), craftingLevel, getLongWithNull(station));
        }

        /**
         * Sets the crafting level of a player's crafting session.
         *
         * @param player            the player who's crafting
         * @param craftingLevel     the crafting level of the session
         *
         * @return true if the level was set, false on error
         */
        public static boolean setCraftingLevel(obj_id player, int craftingLevel)
        {
            return setCraftingLevelAndStation(player, craftingLevel, null);
        }
        /**
         * Gets the crafting level of a player's crafting session.
         *
         * @param player            the player who's crafting
         *
         * @return the crafting level, or -1 on error
         */
        private static native int _getCraftingLevel(long player);
        public static int getCraftingLevel(obj_id player)
        {
            return _getCraftingLevel(getLongWithNull(player));
        }

        /**
         * Sets the crafting station of a player's crafting session.
         *
         * @param player        the player who's crafting
         * @param station       the crafting station of the session
         *
         * @return true if the station was set, false on error
         */
        public static boolean setCraftingStation(obj_id player, obj_id station)
        {
            return setCraftingLevelAndStation(player, -1, station);
        }
        /**
         * Gets the crafting station of a player's crafting session.
         *
         * @param player            the player who's crafting
         *
         * @return the crafting station, or null on error
         */
        private static native long _getCraftingStation(long player);
        public static obj_id getCraftingStation(obj_id player)
        {
            return getObjIdWithNull(_getCraftingStation(getLongWithNull(player)));
        }

        /**
         * Sends a list of draft schematics to a player that he may select to craft an item.
         *
         * @param player        the player trying to use the station
         * @param schematics    list of schematic template names the player may use to craft an item
         *
         * @return true on success, false if there was an error
         **/
        private static native boolean _sendUseableDraftSchematics(long player, int[] schematics);
        public static boolean sendUseableDraftSchematics(obj_id player, int[] schematics)
        {
            return _sendUseableDraftSchematics(getLongWithNull(player), schematics);
        }

        /**
         * Sets an attribute for a manufacturing schematic.
         *
         * @param manufacturingSchematic        the schematic
         * @param attribute                     the attribute info to set
         * @param experiment                    flag that these are experimental attributes
         *
         * @return true on success, false if there was an error
         */
        private static native boolean __setSchematicAttribute(long manufacturingSchematic, draft_schematic.attribute attribute, boolean experiment);
        private static boolean _setSchematicAttribute(obj_id manufacturingSchematic, draft_schematic.attribute attribute, boolean experiment)
        {
            return __setSchematicAttribute(getLongWithNull(manufacturingSchematic), attribute, experiment);
        }

        /**
         * Sets attributes for a manufacturing schematic.
         *
         * @param manufacturingSchematic        the schematic
         * @param attributes                    list of attribute info to set
         * @param experiment                    flag that these are experimental attributes
         *
         * @return true on success, false if there was an error
         */
        private static native boolean __setSchematicAttributes(long manufacturingSchematic, draft_schematic.attribute[] attributes, boolean experiment);
        private static boolean _setSchematicAttributes(obj_id manufacturingSchematic, draft_schematic.attribute[] attributes, boolean experiment)
        {
            return __setSchematicAttributes(getLongWithNull(manufacturingSchematic), attributes, experiment);
        }

        /**
         * Gets an attribute of a manufacturing schematic.
         *
         * @param manufacturingSchematic        the schematic
         * @param name                          name of the attribute to get
         * @param experiment                    flag that these are experimental attributes
         *
         * @return the attribute, or null on error
         */
        private static native draft_schematic.attribute __getSchematicAttribute(long manufacturingSchematic, string_id name, boolean experiment);
        private static draft_schematic.attribute _getSchematicAttribute(obj_id manufacturingSchematic, string_id name, boolean experiment)
        {
            return __getSchematicAttribute(getLongWithNull(manufacturingSchematic), name, experiment);
        }

        /**
         * Gets a select list of the attributes of a manufacturing schematic. Note that calling getAllSchematicAttributes
         * may be more efficient than calling this function if the number of attributes wanted is close (say, 75%) of the
         * total number of attributes available.
         *
         * @param manufacturingSchematic        the schematic
         * @param names                         names of the attribute to get
         * @param experiment                    flag that these are experimental attributes
         *
         * @return the attribute, or null on error
         */
        private static native draft_schematic.attribute[] __getSchematicAttributes(long manufacturingSchematic, string_id[] name, boolean experiment);
        private static draft_schematic.attribute[] _getSchematicAttributes(obj_id manufacturingSchematic, string_id[] name, boolean experiment)
        {
            return __getSchematicAttributes(getLongWithNull(manufacturingSchematic), name, experiment);
        }

        /**
         * Gets all the attributes of a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @param experiment                    flag that these are experimental attributes
         * @return the attributes, or null on error
         */
        private static native draft_schematic.attribute[] __getAllSchematicAttributes(long manufacturingSchematic, boolean experiment);
        private static draft_schematic.attribute[] _getAllSchematicAttributes(obj_id manufacturingSchematic, boolean experiment)
        {
            return __getAllSchematicAttributes(getLongWithNull(manufacturingSchematic), experiment);
        }

        /**
         * Sets an attribute for a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @param attribute                     the attribute info to set
         * @return true on success, false if there was an error
         */
        public static boolean setSchematicAttribute(obj_id manufacturingSchematic, draft_schematic.attribute attribute)
        {
            return _setSchematicAttribute(manufacturingSchematic, attribute, false);
        }

        /**
         * Sets attributes for a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @param attributes                    list of attribute info to set
         * @return true on success, false if there was an error
         */
        public static boolean setSchematicAttributes(obj_id manufacturingSchematic, draft_schematic.attribute[] attributes)
        {
            return _setSchematicAttributes(manufacturingSchematic, attributes, false);
        }

        /**
         * Gets an attribute of a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @param name                          name of the attribute to get
         * @return the attribute, or null on error
         */
        public static draft_schematic.attribute getSchematicAttribute(obj_id manufacturingSchematic, string_id name)
        {
            return _getSchematicAttribute(manufacturingSchematic, name, false);
        }

        /**
         * Gets a select list of the attributes of a manufacturing schematic. Note that calling getAllSchematicAttributes
         * may be more efficient than calling this function if the number of attributes wanted is close (say, 75%) of the
         * total number of attributes available.
         * @param manufacturingSchematic        the schematic
         * @param names                         names of the attribute to get
         * @return the attribute, or null on error
         */
        public static draft_schematic.attribute[] getSchematicAttributes(obj_id manufacturingSchematic, string_id[] name)
        {
            return _getSchematicAttributes(manufacturingSchematic, name, false);
        }

        /**
         * Gets all the attributes of a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @return the attributes, or null on error
         */
        public static draft_schematic.attribute[] getAllSchematicAttributes(obj_id manufacturingSchematic)
        {
            return _getAllSchematicAttributes(manufacturingSchematic, false);
        }

        /**
         * Sets an attribute for a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @param attribute                     the attribute info to set
         * @return true on success, false if there was an error
         */
        public static boolean setSchematicExperimentalAttribute(obj_id manufacturingSchematic, draft_schematic.attribute attribute)
        {
            return _setSchematicAttribute(manufacturingSchematic, attribute, true);
        }

        /**
         * Sets attributes for a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @param attributes                    list of attribute info to set
         * @return true on success, false if there was an error
         */
        public static boolean setSchematicExperimentalAttributes(obj_id manufacturingSchematic, draft_schematic.attribute[] attributes)
        {
            return _setSchematicAttributes(manufacturingSchematic, attributes, true);
        }

        /**
         * Gets an attribute of a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @param name                          name of the attribute to get
         * @return the attribute, or null on error
         */
        public static draft_schematic.attribute getSchematicExperimentalAttribute(obj_id manufacturingSchematic, string_id name)
        {
            return _getSchematicAttribute(manufacturingSchematic, name, true);
        }

        /**
         * Gets a select list of the attributes of a manufacturing schematic. Note that calling getAllSchematicAttributes
         * may be more efficient than calling this function if the number of attributes wanted is close (say, 75%) of the
         * total number of attributes available.
         * @param manufacturingSchematic        the schematic
         * @param names                         names of the attribute to get
         * @return the attribute, or null on error
         */
        public static draft_schematic.attribute[] getSchematicExperimentalAttributes(obj_id manufacturingSchematic, string_id[] name)
        {
            return _getSchematicAttributes(manufacturingSchematic, name, true);
        }

        /**
         * Gets all the attributes of a manufacturing schematic.
         * @param manufacturingSchematic        the schematic
         * @return the attributes, or null on error
         */
        public static draft_schematic.attribute[] getAllSchematicExperimentalAttributes(obj_id manufacturingSchematic)
        {
            return _getAllSchematicAttributes(manufacturingSchematic, true);
        }

        /**
         * Returns a draft_schematic structure filled in with info used by a manufacturing schematic.
         * @param manufacturingSchematic        the schematic to get the data from
         * @return the draft_schematic object, or null on error
         */
        private static native draft_schematic _getSchematicData(long manufacturingSchematic);
        public static draft_schematic getSchematicData(obj_id manufacturingSchematic)
        {
            return _getSchematicData(getLongWithNull(manufacturingSchematic));
        }

        /**
         * Returns a draft_schematic structure filled in with info used by a draft schematic.
         * @param draftSchematic        the schematic template name to get the data from
         * @return the draft_schematic object, or null on error
         */
        public static native draft_schematic getSchematicData(String draftSchematic);

        /**
         * Returns a draft_schematic structure filled in with info used by a draft schematic.
         * @param draftSchematic        the schematic template crc to get the data from
         * @return the draft_schematic object, or null on error
         */
        public static native draft_schematic getSchematicData(int draftSchematic);

        /**
         * Gets the template of the item a draft schematic creates.
         * @param draftSchematic the draft schematic's template
         * @return the template for the item the schematic creates, or null on error
         */
        public static native String getTemplateCreatedFromSchematic(String draftSchematic);
        /**
         * Gets the template of the item a draft schematic creates.
         * @param draftSchematicCrc the draft schematic's template crc
         * @return the template for the item the schematic creates, or null on error
         */
        public static native String getTemplateCreatedFromSchematic(int draftSchematicCrc);
        /**
         * Gets the template of the item a draft schematic creates.
         * @param draftSchematic the draft schematic's template
         * @return the template crc for the item the schematic creates, or 0 on error
         */
        public static native int getTemplateCrcCreatedFromSchematic(String draftSchematic);
        /**
         * Gets the template of the item a draft schematic creates.
         * @param draftSchematicCrc the draft schematic's template crc
         * @return the template crc for the item the schematic creates, or 0 on error
         */
        public static native int getTemplateCrcCreatedFromSchematic(int draftSchematicCrc);

        /**
         * Returns a draft_schematic structure filled in with info about requested experimental attributes. The info will consist
         * of the experimentation attribute data, the object attributes associated with them, and a mapping between the two.
         * @param manufacturingSchematic        the schematic to get the data from
         * @param attributeNames                the experimental attributes we're interested about
         * @return the draft_schematic object, or null on error
         */
        private static native draft_schematic _getSchematicForExperimentalAttributes(long manufacturingSchematic, string_id[] attributeNames);
        public static draft_schematic getSchematicForExperimentalAttributes(obj_id manufacturingSchematic, string_id[] attributeNames)
        {
            return _getSchematicForExperimentalAttributes(getLongWithNull(manufacturingSchematic), attributeNames);
        }

        /**
         * Sets the appearances the player may choose from when customizing the object.
         * @param manufacturingSchematic        the schematic that will create the customized object
         * @param appearances                   list of appearance filenames that the player may choose
         * @param returns true on success, false on error
         */
        private static native boolean _setSchematicAppearances(long manufacturingSchematic, String[] appearances);
        public static boolean setSchematicAppearances(obj_id manufacturingSchematic, String[] appearances)
        {
            return _setSchematicAppearances(getLongWithNull(manufacturingSchematic), appearances);
        }

        /**
         * Sets the customization parameters that a player is allowed to change, or differ in their default value from
         * the template. You do not have to set fixed customization parameters that use their default value.
         *
         * @param manufacturingSchematic        the schematic that will create the customized object
         * @param customizations                customization info
         * @return true on success, false if there was error
         */
        private static native boolean _setSchematicCustomizations(long manufacturingSchematic, draft_schematic.custom[] customizations);
        public static boolean setSchematicCustomizations(obj_id manufacturingSchematic, draft_schematic.custom[] customizations)
        {
            return _setSchematicCustomizations(getLongWithNull(manufacturingSchematic), customizations);
        }

        /**
         * Returns the number of items a manufacturing schematic can create.
         *
         * @param manufacturingSchematic        the schematic
         *
         * @return the number of items, or -1 on error
         */
        private static native int _getSchematicItemCount(long manufacturingSchematic);
        public static int getSchematicItemCount(obj_id manufacturingSchematic)
        {
            return _getSchematicItemCount(getLongWithNull(manufacturingSchematic));
        }

        /**
         * Sets the number of items a manufacturing schematic can create.
         *
         * @param manufacturingSchematic    the schematic
         * @param count                     the number of items
         *
         * @return true on success, false if there was an error
         */
        private static native boolean _setSchematicItemCount(long manufacturingSchematic, int count);
        public static boolean setSchematicItemCount(obj_id manufacturingSchematic, int count)
        {
            return _setSchematicItemCount(getLongWithNull(manufacturingSchematic), count);
        }

        /**
         * Returns the numer of items per container a manufacturing schematic will
         * create.
         *
         * @param manufacturingSchematic        the schematic
         *
         * @return the number of items, or -1 on error
         */
        private static native int _getSchematicItemsPerContainer(long manufacturingSchematic);
        public static int getSchematicItemsPerContainer(obj_id manufacturingSchematic)
        {
            return _getSchematicItemsPerContainer(getLongWithNull(manufacturingSchematic));
        }

        /**
         * Sets the numer of items per container a manufacturing schematic will
         * create.
         *
         * @param manufacturingSchematic    the schematic
         * @param count                     the number of items
         *
         * @return true on success, false if there was an error
         */
        private static native boolean _setSchematicItemsPerContainer(long manufacturingSchematic, int count);
        public static boolean setSchematicItemsPerContainer(obj_id manufacturingSchematic, int count)
        {
            return _setSchematicItemsPerContainer(getLongWithNull(manufacturingSchematic), count);
        }

        /**
         * Returns the time per complexity point it takes to manufacture an item with
         * a manufacturing schematic.
         *
         * @param manufacturingSchematic        the schematic
         *
         * @return the time, or -1 on error
         */
        private static native float _getSchematicManufactureTime(long manufacturingSchematic);
        public static float getSchematicManufactureTime(obj_id manufacturingSchematic)
        {
            return _getSchematicManufactureTime(getLongWithNull(manufacturingSchematic));
        }

        /**
         * Sets the time per complexity point it takes to manufacture an item with
         * a manufacturing schematic.
         *
         * @param manufacturingSchematic    the schematic
         * @param time                      the manufacturing time per complexity
         *
         * @return true on success, false if there was an error
         */
        private static native boolean _setSchematicManufactureTime(long manufacturingSchematic, float time);
        public static boolean setSchematicManufactureTime(obj_id manufacturingSchematic, float time)
        {
            return _setSchematicManufactureTime(getLongWithNull(manufacturingSchematic), time);
        }

        /**
         * Sets an approximate experiment mod for an assembled schematic so the player will have some idea of
         * the risk experimenting with an item.
         *
         * @param manufacturingSchematic    the schematic
         * @param experimentMod             approximent mod that will be applied during experimentation
         *
         * @return true on success, false if there was an error
         */
        private static native boolean _setSchematicExperimentMod(long manufacturingSchematic, float experimentMod);
        public static boolean setSchematicExperimentMod(obj_id manufacturingSchematic, float experimentMod)
        {
            return _setSchematicExperimentMod(getLongWithNull(manufacturingSchematic), experimentMod);
        }

        /**
         * Sets the amount of xp the creator of an object will get when an object is "used".
         * @param object        the object that will grant the xp
         * @param xp            the amount of xp to grant
         * @return true on success, false if there was an error
         */
        private static native boolean _setCreatorXp(long object, int xp);
        public static boolean setCreatorXp(obj_id object, int xp)
        {
            return _setCreatorXp(getLongWithNull(object), xp);
        }

        /**
         * Gets a list of ingredients needed to craft using the current manufacturing schematic in a manufacturing station.
         * @param station       the manufacturing station id
         * @param ingredients   array to be filled in with a string array of ingredients
         */
        private static native void _getIngredientsForManufactureStation(long station, String[][] ingredients);
        public static void getIngredientsForManufactureStation(obj_id station, String[][] ingredients)
        {
            _getIngredientsForManufactureStation(getLongWithNull(station), ingredients);
        }

        /**
         * Gets the id of a manufacture station's input hopper.
         * @param station       the station id
         * @return the hopper id, or null on error
         */
        private static native long _getManufactureStationInputHopper(long station);
        public static obj_id getManufactureStationInputHopper(obj_id station)
        {
            return getObjIdWithNull(_getManufactureStationInputHopper(getLongWithNull(station)));
        }

        /**
         * Gets the id of a manufacture station's output hopper.
         * @param station       the station id
         * @return the hopper id, or null on error
         */
        private static native long _getManufactureStationOutputHopper(long station);
        public static obj_id getManufactureStationOutputHopper(obj_id station)
        {
            return getObjIdWithNull(_getManufactureStationOutputHopper(getLongWithNull(station)));
        }

        /**
         * Gets the id and name of the schematic in a manufacture station.
         * @param station       the station id
         * @return a string of the form <id> "*" <name>, or null if the station has no schematic
         */
        private static native String _getManufactureStationSchematic(long station);
        public static String getManufactureStationSchematic(obj_id station)
        {
            return _getManufactureStationSchematic(getLongWithNull(station));
        }

        /**
         * Gets a list of manufacture schematics that could be used at a given manufacturing station.
         * @param player        the player whose schematics to get
         * @param station       the manufacturing station
         * @param schematics    array to be filled in with a string array of schematics in the same for as returned by getManufactureStationSchematic
         */
        private static native void _getValidManufactureSchematicsForStation(long player, long station, String[][] schematics);
        public static void getValidManufactureSchematicsForStation(obj_id player, obj_id station, String[][] schematics)
        {
            _getValidManufactureSchematicsForStation(getLongWithNull(player), getLongWithNull(station), schematics);
        }

        /**
         * Checks if a player has any manufacture schematics that could be used at a given manufacturing station.
         * @param player        the player whose schematics to check
         * @param station       the manufacturing station
         * @return true if the player has any schematics, false if not
         */
        private static native boolean _hasValidManufactureSchematicsForStation(long player, long station);
        public static boolean hasValidManufactureSchematicsForStation(obj_id player, obj_id station)
        {
            return _hasValidManufactureSchematicsForStation(getLongWithNull(player), getLongWithNull(station));
        }

        /**
         * Transfers the manufacture schematic in a manufacturing station to a player.
         * @param station       the manufacturing station id
         * @param player        the the player to transfer to
         * @return true if the schematic was transferred, false if not
         */
        private static native boolean _transferManufactureSchematicToPlayer(long station, long player);
        public static boolean transferManufactureSchematicToPlayer(obj_id station, obj_id player)
        {
            return _transferManufactureSchematicToPlayer(getLongWithNull(station), getLongWithNull(player));
        }

        /**
         * Transfers a manufacture schematic to a manufacturing station.
         * @param schematic     the schematic id
         * @param station       the manufacturing station id
         * @return true if the schematic was transferred, false if not
         */
        private static native boolean _transferManufactureSchematicToStation(long schematic, long station);
        public static boolean transferManufactureSchematicToStation(obj_id schematic, obj_id station)
        {
            return _transferManufactureSchematicToStation(getLongWithNull(schematic), getLongWithNull(station));
        }

        /**
         * Creates a new item based on a draft schematic. The item will have stats
         * based on a % value passed in (0 = worst possible stats, 100 = best possible
         * stats).
         *
         * @param draftSchematic    draft schematic to make the object from
         * @param qualityPercent    % stat adjustment
         * @param container         the container to create the item in
         *
         * @return the item, or null on error
         */
        private static native long _makeCraftedItem(String draftSchematic, float qualityPercent, long container);
        public static obj_id makeCraftedItem(String draftSchematic, float qualityPercent, obj_id container)
        {
            return getObjIdWithNull(_makeCraftedItem(draftSchematic, qualityPercent, getLongWithNull(container)));
        }

        /**
         * Gets a list of objects that can be repaired by a given repair tool.
         * @param player        the player whose objects to get
         * @param tool          the repair tool
         * @param objects       array to be filled in with a string array of objects in the same for as returned by getManufactureStationSchematic
         */
        private static native void _getRepairableObjectsForTool(long player, long tool, String[][] objects);
        public static void getRepairableObjectsForTool(obj_id player, obj_id tool, String[][] objects)
        {
            _getRepairableObjectsForTool(getLongWithNull(player), getLongWithNull(tool), objects);
        }

        /**
         * Returns the attribute bonuses an object grants when equipped.
         * @param target        the object
         * @return an array with the bonus for each attribute, or null on error
         */
        private static native int[] _getAttributeBonuses(long target);
        public static int[] getAttributeBonuses(obj_id target)
        {
            return _getAttributeBonuses(getLongWithNull(target));
        }

        /**
         * Returns the attribute bonus of an object for a given attribute.
         * @param target        the object
         * @param attribute     the attribute to get
         * @return the attribute bonus
         */
        private static native int _getAttributeBonus(long target, int attribute);
        public static int getAttributeBonus(obj_id target, int attribute)
        {
            return _getAttributeBonus(getLongWithNull(target), attribute);
        }

        /**
         * Sets the attribute bonus an object applies when equipped.
         * @param target        the object
         * @param attribute     the attribute to set
         * @param bonus         the attribute bonus value
         * @return true on success, false on error
         */
        private static native boolean _setAttributeBonus(long target, int attribute, int bonus);
        public static boolean setAttributeBonus(obj_id target, int attribute, int bonus)
        {
            return _setAttributeBonus(getLongWithNull(target), attribute, bonus);
        }

        /**
         * Sets the attribute bonuses an object applies when equipped.
         * @param target        the object
         * @param bonuses       the attribute bonus values (must be length 9)
         * @return true on success, false on error
         */
        private static native boolean _setAttributeBonuses(long target, int[] bonuses);
        public static boolean setAttributeBonuses(obj_id target, int[] bonuses)
        {
            return _setAttributeBonuses(getLongWithNull(target), bonuses);
        }

        /**
         * Returns the skill mod bonuses an object grants when equipped.
         * @param target        the object
         * @return a dictionary of skill mod names -> mod values, or null on error
         */
        private static native dictionary _getSkillModBonuses(long target);
        public static dictionary getSkillModBonuses(obj_id target)
        {
            return _getSkillModBonuses(getLongWithNull(target));
        }

        /**
         * Returns the skill mod bonus of an object for a given skill mod.
         * @param target        the object
         * @param skillMod      the skill mod to get
         * @return the skill mod value
         */
        private static native int _getSkillModBonus(long target, String skillMod);
        public static int getSkillModBonus(obj_id target, String skillMod)
        {
            return _getSkillModBonus(getLongWithNull(target), skillMod);
        }

        /**
         * Sets the base skill mod bonus an object applies when equipped.
         * @param target        the object
         * @param skillMod      the skill mod to set
         * @param bonus         the skill mod bonus value
         * @return true on success, false on error
         */
        private static native boolean _setSkillModBonus(long target, String skillMod, int bonus);
        public static boolean setSkillModBonus(obj_id target, String skillMod, int bonus)
        {
            return _setSkillModBonus(getLongWithNull(target), skillMod, bonus);
        }

        /**
         * Sets the base skill mod bonuses an object applies when equipped.
         * @param target        the object
         * @param skillMod      the skill mods to set
         * @param bonus         the skill mod bonus values
         * @return true on success, false on error
         */
        private static native boolean _setSkillModBonuses(long target, String[] skillMod, int[] bonus);
        public static boolean setSkillModBonuses(obj_id target, String[] skillMod, int[] bonus)
        {
            return _setSkillModBonuses(getLongWithNull(target), skillMod, bonus);
        }

        /**
         * Sets the base skill mod bonus an object applies when equipped.
         * @param target        the object
         * @param category      the category of the skill mod bonus
         *                      multiple/independent bonuses can be granted
         *                      for a particular skill mod by putting them
         *                      into different categories
         * @param skillMod      the skill mod to set
         * @param bonus         the skill mod bonus value
         * @return true on success, false on error
         */
        private static native boolean _setCategorizedSkillModBonus(long target, String category, String skillMod, int bonus);
        public static boolean setCategorizedSkillModBonus(obj_id target, String category, String skillMod, int bonus)
        {
            return _setCategorizedSkillModBonus(getLongWithNull(target), category, skillMod, bonus);
        }

        /**
         * Removes all skill mod bonuses in a particular category on an object.
         * @param target        the object
         * @param category      the category of the skill mod bonus
         *                      multiple/independent bonuses can be granted
         *                      for a particular skill mod by putting them
         *                      into different categories
         */
        private static native void _removeCategorizedSkillModBonuses(long target, String category);
        public static void removeCategorizedSkillModBonuses(obj_id target, String category)
        {
            _removeCategorizedSkillModBonuses(getLongWithNull(target), category);
        }

        /**
         * Returns the number of available skill mod sockets of an object.
         * @param target        the object
         * @return the number of sockets
         */
        private static native int _getSkillModSockets(long target);
        public static int getSkillModSockets(obj_id target)
        {
            return _getSkillModSockets(getLongWithNull(target));
        }

        /**
         * Sets the number of available skill mod sockets for an object.
         * @param target        the object
         * @param sockets       the number of sockets
         * @return true on success, false on error
         */
        private static native boolean _setSkillModSockets(long target, int sockets);
        public static boolean setSkillModSockets(obj_id target, int sockets)
        {
            return _setSkillModSockets(getLongWithNull(target), sockets);
        }

		/**
 		 * Causes the stats of a crate of manufactured objects to get recomputed from the
 		 * crate's objvars.
 		 * IMPORTANT: This only affects the stats of new objects that get pulled out of the
 		 * crate! It is up to the caller to modify the "examine" item stored in the crate.
 		 * @param crate		the crate to recompute the stats of
 		 */
		private static native void _recomputeCrateAttributes(long crate);
		public static void recomputeCrateAttributes(obj_id crate)
		{
			_recomputeCrateAttributes(getLongWithNull(crate));
		}

        /** @defgroup craftingArmorMethods methods used in the crafting and manufacturing processes of armor
        *@{ */

            // ArmorLevel - defined in sys.server/object_template.tdf
            static public final int AL_none     = -1;
            static public final int AL_basic    = 0;
            static public final int AL_standard = 1;
            static public final int AL_advanced = 2;
            static public final int AL_max      = 3;  // make sure that this is always at the end of the list if you add new levels

            // ArmorCategory - defined in sys.server/object_template.tdf
            static public final int AC_none           = -1;
            static public final int AC_reconnaissance = 0;
            static public final int AC_battle         = 1;
            static public final int AC_assault        = 2;
            static public final int AC_psg            = 3;  // personal shield generator
            static public final int AC_max            = 4;  // make sure that this is always at the end of the list if you add new levels
        /*@}  craftingArmorMethods*/
    /*@}  craftingMethods*/

    public static native String _getSkillTemplate(long player);
    public static String getSkillTemplate(obj_id player)
    {
        return _getSkillTemplate((player == null) ? 0 : player.getValue());
    }

    public static native void _setSkillTemplate(long player, String skillTemplateName);
    public static void setSkillTemplate(obj_id player, String skillTemplateName)
    {
        _setSkillTemplate((player == null) ? 0 : player.getValue(), skillTemplateName);
    }

    public static native String _getWorkingSkill(long player);
    public static String getWorkingSkill(obj_id player)
    {
        return _getWorkingSkill((player == null) ? 0 : player.getValue());
    }

    public static native void _setWorkingSkill(long player, String skillTemplateName);
    public static void setWorkingSkill(obj_id player, String skillTemplateName)
    {
        _setWorkingSkill((player == null) ? 0 : player.getValue(), skillTemplateName);
    }

    public static native void _recomputeCommandSeries(long player);
    public static void recomputeCommandSeries(obj_id player)
    {
        _recomputeCommandSeries((player == null) ? 0 : player.getValue());
    }

    public static native void _resetExpertises(long player);
    public static void resetExpertises(obj_id player)
    {
        _resetExpertises((player == null) ? 0 : player.getValue());
    }

    //*********************************************************************
    // collection methods
    //*********************************************************************

    // modify the value of a certain collection slot on a player by the
    // specified delta amount; if the slot is a bit-type slot, a positive
    // delta value will cause the bit to get set, a negative delta
    // value will cause the bit to get cleared, and a 0 delta value will
    // leave the bit unchanged; if the slot is a counter-type slot, the
    // value of the slot will be modified by the delta value, and the
    // modified value will be capped between 0 - max slot value
    private static native boolean _modifyCollectionSlotValue(long player, String slotName, long delta);
    public static boolean modifyCollectionSlotValue(obj_id player, String slotName, long delta)
    {
        return _modifyCollectionSlotValue(getLongWithNull(player), slotName, delta);
    }

    // get the value of a certain collection slot on a player;
    // for a bit-type slot, will return 0 or 1; for counter-type
    // slot, returns the counter value (0 - max slot value);
    // returns -1 to indicate an error
    private static native long _getCollectionSlotValue(long player, String slotName);
    public static long getCollectionSlotValue(obj_id player, String slotName)
    {
        return _getCollectionSlotValue(getLongWithNull(player), slotName);
    }

    // check to see if player has completed all the prereq collection slot(s)
    // for the specified collection slot; a completed prereq collection slot
    // is a collection slot where hasCompletedCollectionSlot() is true;
    // if the specified collection slot doesn't have any prereq collection slot(s)
    // defined, the return value will be true
    private static native boolean _hasCompletedCollectionSlotPrereq(long player, String slotName);
    public static boolean hasCompletedCollectionSlotPrereq(obj_id player, String slotName)
    {
        return _hasCompletedCollectionSlotPrereq(getLongWithNull(player), slotName);
    }

    // check to see if player has completed a certain collection slot
    // "completed" means if the slot is a bit-type slot, the bit is set;
    // else if the slot is a counter-type slot, *AND* the slot has a max value
    // defined, *AND* the current value of the slot is equals to the max value
    private static native boolean _hasCompletedCollectionSlot(long player, String slotName);
    public static boolean hasCompletedCollectionSlot(obj_id player, String slotName)
    {
        return _hasCompletedCollectionSlot(getLongWithNull(player), slotName);
    }

    // check to see if player has completed a certain collection
    // "completed" means hasCompletedCollectionSlot() is true
    // for every slot in the collection
    private static native boolean _hasCompletedCollection(long player, String collectionName);
    public static boolean hasCompletedCollection(obj_id player, String collectionName)
    {
        return _hasCompletedCollection(getLongWithNull(player), collectionName);
    }

    // check to see if player has completed a certain collection page
    // "completed" means hasCompletedCollection() is true
    // for every collection in the page
    private static native boolean _hasCompletedCollectionPage(long player, String pageName);
    public static boolean hasCompletedCollectionPage(obj_id player, String pageName)
    {
        return _hasCompletedCollectionPage(getLongWithNull(player), pageName);
    }

    // check to see if player has completed a certain collection book
    // "completed" means hasCompletedCollectionPage() is true
    // for every collection page in the book
    private static native boolean _hasCompletedCollectionBook(long player, String bookName);
    public static boolean hasCompletedCollectionBook(obj_id player, String bookName)
    {
        return _hasCompletedCollectionBook(getLongWithNull(player), bookName);
    }

    // get a list of completed collection slots that player has for a collection
    // null is a valid return value
    private static native String[] _getCompletedCollectionSlotsInCollection(long player, String collectionName);
    public static String[] getCompletedCollectionSlotsInCollection(obj_id player, String collectionName)
    {
        return _getCompletedCollectionSlotsInCollection(getLongWithNull(player), collectionName);
    }

    // get a list of completed collection slots that player has for a collection page
    // null is a valid return value
    private static native String[] _getCompletedCollectionSlotsInPage(long player, String pageName);
    public static String[] getCompletedCollectionSlotsInPage(obj_id player, String pageName)
    {
        return _getCompletedCollectionSlotsInPage(getLongWithNull(player), pageName);
    }

    // get a list of completed collections that player has for a collection page
    // null is a valid return value
    private static native String[] _getCompletedCollectionsInPage(long player, String pageName);
    public static String[] getCompletedCollectionsInPage(obj_id player, String pageName)
    {
        return _getCompletedCollectionsInPage(getLongWithNull(player), pageName);
    }

    // get a list of completed collection slots that player has for a collection book
    // null is a valid return value
    private static native String[] _getCompletedCollectionSlotsInBook(long player, String bookName);
    public static String[] getCompletedCollectionSlotsInBook(obj_id player, String bookName)
    {
        return _getCompletedCollectionSlotsInBook(getLongWithNull(player), bookName);
    }

    // get a list of completed collections that player has for a collection book
    // null is a valid return value
    private static native String[] _getCompletedCollectionsInBook(long player, String bookName);
    public static String[] getCompletedCollectionsInBook(obj_id player, String bookName)
    {
        return _getCompletedCollectionsInBook(getLongWithNull(player), bookName);
    }

    // get a list of completed collection pages that player has for a collection book
    // null is a valid return value
    private static native String[] _getCompletedCollectionPagesInBook(long player, String bookName);
    public static String[] getCompletedCollectionPagesInBook(obj_id player, String bookName)
    {
        return _getCompletedCollectionPagesInBook(getLongWithNull(player), bookName);
    }

    // get a list of completed collection books that player has
    // null is a valid return value
    private static native String[] _getCompletedCollectionBooks(long player);
    public static String[] getCompletedCollectionBooks(obj_id player)
    {
        return _getCompletedCollectionBooks(getLongWithNull(player));
    }

    // returns a string array containing the page name, collection name, and music for the collection slot
    // null is a valid return value
    public static final int COLLECTION_INFO_INDEX_BOOK = 0;
    public static final int COLLECTION_INFO_INDEX_PAGE = 1;
    public static final int COLLECTION_INFO_INDEX_COLLECTION = 2;
    public static final int COLLECTION_INFO_INDEX_MUSIC = 3;
    public static final int COLLECTION_INFO_ARRAY_SIZE = 4;
    public static native String[] getCollectionSlotInfo(String slotName);

    // returns true if the specified collection slot is marked as a title
    public static native boolean isCollectionSlotATitle(String slotName);

    // returns true if the specified collection is marked as a title
    public static native boolean isCollectionATitle(String collectionName);

    // returns true if the specified collection page is marked as a title
    public static native boolean isCollectionPageATitle(String pageName);

    // returns a string array containing the categories for the collection slot
    // null is a valid return value
    public static native String[] getCollectionSlotCategoryInfo(String slotName);

    // returns a string array containing the prereq collection slot(s)
    // for the specified collection slot
    // null is a valid return value
    public static native String[] getCollectionSlotPrereqInfo(String slotName);

    // returns a string collection slot name for the given collection slot id
    // null is a valid return value
    public static native String getCollectionSlotName(int collectionSlotId);

    // get the list of all the possible collection slots in a collection
    // null is a valid return value
    public static native String[] getAllCollectionSlotsInCollection(String collectionName);

    // get the list of all the possible collection slots in a collection page
    // null is a valid return value
    public static native String[] getAllCollectionSlotsInPage(String pageName);

    // get the list of all the possible collections in a collection page
    // null is a valid return value
    public static native String[] getAllCollectionsInPage(String pageName);

    // get the list of all the possible collection slots in a collection book
    // null is a valid return value
    public static native String[] getAllCollectionSlotsInBook(String bookName);

    // get the list of all the possible collections in a collection book
    // null is a valid return value
    public static native String[] getAllCollectionsInBook(String bookName);

    // get the list of all the possible collection pages in a collection book
    // null is a valid return value
    public static native String[] getAllCollectionPagesInBook(String bookName);

    // get the list of all the possible collection books
    // null is a valid return value
    public static native String[] getAllCollectionBooks();

    // get the list of all the possible collection slots in a collection category
    // null is a valid return value
    public static native String[] getAllCollectionSlotsInCategory(String categoryName);

    // get the list of all the possible collection slots in a collection category in a collection
    // null is a valid return value
    public static native String[] getAllCollectionSlotsInCategoryInCollection(String collectionName, String categoryName);

    // get the list of all the possible collection slots in a collection category in a collection page
    // null is a valid return value
    public static native String[] getAllCollectionSlotsInCategoryInPage(String pageName, String categoryName);

    // get the list of all the possible collection slots in a collection category in a collection book
    // null is a valid return value
    public static native String[] getAllCollectionSlotsInCategoryInBook(String bookName, String categoryName);

    // get the list of all the possible collection categories in a collection
    // null is a valid return value
    public static native String[] getAllCollectionSlotCategoriesInCollection(String collectionName);

    // get the list of all the possible collection categories in a collection page
    // null is a valid return value
    public static native String[] getAllCollectionSlotCategoriesInPage(String pageName);

    // get the list of all the possible collection categories in a collection book
    // null is a valid return value
    public static native String[] getAllCollectionSlotCategoriesInBook(String bookName);

    // get the list of all the possible collection categories
    // null is a valid return value
    public static native String[] getAllCollectionSlotCategories();

    //*********************************************************************
    // base class methods
    //*********************************************************************

    /** \internal */
    public base_class()
    {
        m_traceLoggingEnabled = false;
    }

    /**
    * @defgroup randomNumberMethods Random number methods
    */
    /*@{*/

    //*********************************************************************
    // random number functions
    //*********************************************************************

    /**
     * Computes a random number in the range [0,1)
     *
     * @return a random number
     */
    public static float rand()
    {
        return random.rand();
    }   // rand()

    /**
     * Computes a random float in the range [0,1), reseeding the generator
     * before doing so.
     *
     * @param seed      the new seed
     *
     * @return a random float
     */
    public static float rand(int seed)
    {
        return random.rand(seed);
    }   // rand(int)

    /**
     * Computes a random integer in the range [minVal, maxVal]
     *
     * @param minVal        lower value of random integer
     * @param maxVal        upper value of random integer
     *
     * @return a random integer
     */
    public static int rand(int minVal, int maxVal)
    {
        return random.rand(minVal, maxVal);
    }   // rand(int, int)

    /**
     * Computes a random float in the range [minVal, maxVal)
     *
     * @param minVal        lower value of random float
     * @param maxVal        upper value of random float
     *
     * @return a random float
     */
    public static float rand(float minVal, float maxVal)
    {
        return random.rand(minVal, maxVal);
    }   // rand(float, float)

    /**
     * Generates a random number based on rolling multiple dice.
     *
     * @param numDie        number of die to roll
     * @param dieSize       number of sides the die has
     * @param base          number to add to the result of rolling the dice
     *
     * @return the random number
     */
    public static int rand(int numDie, int dieSize, int base)
    {
        return random.rand(numDie, dieSize, base);
    }   // rand(int, int, int)

    /**
     * Generates a normalized random number based on rolling multiple dice.
     *
     * @param numDie        number of die to roll
     * @param dieSize       number of sides the die has
     *
     * @return the random number, normalized to [0, 1]
     */
    public static float randNormalized(int numDie, int dieSize)
    {
        return random.randNormalized(numDie, dieSize);
    }   // randNormalized

    /**
     * Reseeds the random number generator.
     *
     * @param seed      the new seed
     */
    public static void reseed(int seed)
    {
        random.reseed(seed);
    }   // reseed

    /**
     * Computes a random number with a gaussian distribution with 0 mean and std dev of 1.
     *
     * @return a random number
     */
    public static float gaussRand()
    {
        return random.gaussRand();
    }

    /**
     * Computes a random number with a gaussian distribution with a given mean and std dev.
     *
     * @param mean      the number's mean
     * @param stddev    the number's std dev
     *
     * @return a random number
     */
    public static float gaussRand(float mean, float stddev)
    {
        return random.gaussRand(mean, stddev);
    }

/*@}*/

    /**
    * @defgroup dataCheckingMethods Data checking methods
    */
    /*@{*/

    //*********************************************************************
    // data checking functions
    //*********************************************************************

    /**
     * Checks if an obj_id is null (null || 0).
     * @param id        the id to test
     * @return true if the id is null, false if not
     */
    public static boolean isIdNull(obj_id id)
    {
        return (id == null || id == obj_id.NULL_ID);
    }   // isIdValid

    /**
     * Checks if an obj_id is valid (not null and not being destroyed).
     * @param id        the id to test
     * @return true if the id is valid, false if not
     */
    public static boolean isIdValid(obj_id id)
    {
        return (!isIdNull(id) && !id.isBeingDestroyed());
    }   // isIdValid

    /**
     * Checks if an obj_id is valid (not null and not being destroyed).
     * @param id        the id to test
     * @return true if the id is valid, false if not
     */
    public static boolean isValidId(obj_id id)
    {
        return isIdValid(id);
    }   // isValidId

    /**
     * Checks if C thinks an object is authoritative. We usually use the flag on obj_id, but we've
     * noticed cases where they are getting out of synch for some unknown reason. This function will
     * reset the obj_id flag to the appropriate value.
     * @param id        id of the object to test
     * @return true if the object is authoritative, false if not
     */
    static native boolean __internalIsAuthoritative(long id);
    static boolean _internalIsAuthoritative(obj_id id)
    {
        return __internalIsAuthoritative(getLongWithNull(id));
    }

    /**
     * Checks to see if the object has a proxy object or an authoritative object on another game server
     * @param id        id of the object to test
     * @return true or false
     */
    private static native boolean _hasProxyOrAuthObject(long id);
    public static boolean hasProxyOrAuthObject(obj_id id)
    {
        return _hasProxyOrAuthObject(getLongWithNull(id));
    }

    /**
     * Returns the class name of a class.
     *
     * @param data      the data to get the class of
     *
     * @return the class name
     */
    public static String getDataType(Object data)
    {
        String result = data.getClass().toString();
        if (result.startsWith("java.lang.", 0))
            result = result.substring(10);
        return result;
    }   // getDataType

    /**
     * Tests to see if two objects are the same type.
     *
     * @param data1     1st object
     * @param data2     2nd object
     *
     * @return true if the objects are the same type
     */
    public static boolean isSameType(Object data1, Object data2)
    {
        return (data1.getClass() == data2.getClass());
    }   // isSameType()

    /**
     * Converts an object's data to a human readable string.
     *
     * @param data      object to convert
     *
     * @return the string
     */
    public static String toString(Object data)
    {
        return data.toString();
    }   // toString()

    /**
     * Compares two objects.
     *
     * @param data1     1st object
     * @param data2     2nd object
     *
     * @returns <, =, or > 0 if the data1 is the same type as data2, else throws
     *      ClassCastException
     */
    public static int compareTo(Object data1, Object data2)
    {
        return ((Comparable)data1).compareTo(data2);
    }   // compareTo()

    /**
     * Compares two objects.
     *
     * @param data1     1st object
     * @param data2     2nd object
     *
     * @returns true if the objects have the same data, false if not
     */
    public static boolean equals(Object data1, Object data2)
    {
        return data1.equals(data2);
    }   // equals()


/*@}*/

    /**
    * @defgroup creatureAttributeMethods Creature attribute methods
    */
    /*@{*/


    //*********************************************************************
    // attribute functions
    //*********************************************************************

    /**
     * Returns a creature's health.
     *
     * @param target        id of the creature
     *
     * @return the health, or ATTRIB_ERROR on fail
     */
    public static int getHealth(obj_id target)
    {
        return getAttrib(target, HEALTH);
    }   // getHealth()

    /**
     * Returns a creature's max health.
     *
     * @param target        id of the creature
     *
     * @return the max health, or ATTRIB_ERROR on fail
     */
    public static int getMaxHealth(obj_id target)
    {
        return getMaxAttrib(target, HEALTH);
    }   // getMaxHealth()

    /**
     * Sets a creature's health.
     *
     * @param target        id of the creature
     * @param value         new health value
     *
     * @return true on success, false on error
     */
    public static boolean setHealth(obj_id target, int value)
    {
        return setAttrib(target, HEALTH, value);
    }   // setHealth()

    /**
     * Adds to a creature's health.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToHealth(obj_id target, int value)
    {
        return addToAttrib(target, HEALTH, value);
    }   // addToHealth()

    /**
     * Adds a health modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addHealthModifier(obj_id target, int value, float duration,
        float attackRate, float decayRate)
    {
        return addAttribModifier(target, HEALTH, value, duration, attackRate,
            decayRate);
    }   // addHealthModifier()

    /**
     * Returns the health modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static attrib_mod[] getHealthModifiers(obj_id target)
    {
        return getAttribModifiers(target, HEALTH);
    }   // getHealthModifiers()

    /**
     * Returns a creature's constitution.
     *
     * @param target        id of the creature
     *
     * @return the constitution, or ATTRIB_ERROR on fail
     */
    public static int getConst(obj_id target)
    {
        return getAttrib(target, CONSTITUTION);
    }   // getConst()

    /**
     * Returns a creature's max constitution.
     *
     * @param target        id of the creature
     *
     * @return the max constitution, or ATTRIB_ERROR on fail
     */
    public static int getMaxConst(obj_id target)
    {
        return getMaxAttrib(target, CONSTITUTION);
    }   // getMaxConst()

    /**
     * Sets a creature's constitution.
     *
     * @param target        id of the creature
     * @param value         new constitution value
     *
     * @return true on success, false on error
     */
    public static boolean setConst(obj_id target, int value)
    {
        return setAttrib(target, CONSTITUTION, value);
    }   // setConst()

    /**
     * Adds to a creature's constitution.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToConst(obj_id target, int value)
    {
        return addToAttrib(target, CONSTITUTION, value);
    }   // addToConst()

    /**
     * Adds a constitution modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addConstModifier(obj_id target, int value, float duration,
        float attackRate, float decayRate)
    {
        return addAttribModifier(target, CONSTITUTION, value, duration,
            attackRate, decayRate);
    }   // addConstModifier()

    /**
     * Returns the constitution modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static attrib_mod[] getConstModifiers(obj_id target)
    {
        return getAttribModifiers(target, CONSTITUTION);
    }   // getConstModifiers()

    /**
     * Returns a creature's action.
     *
     * @param target        id of the creature
     *
     * @return the action, or ATTRIB_ERROR on fail
     */
    public static int getAction(obj_id target)
    {
        return getAttrib(target, ACTION);
    }   // getAction()

    /**
     * Returns a creature's max action.
     *
     * @param target        id of the creature
     *
     * @return the max action, or ATTRIB_ERROR on fail
     */
    public static int getMaxAction(obj_id target)
    {
        return getMaxAttrib(target, ACTION);
    }   // getMaxAction()

    /**
     * Sets a creature's action.
     *
     * @param target        id of the creature
     * @param value         new action value
     *
     * @return true on success, false on error
     */
    public static boolean setAction(obj_id target, int value)
    {
        return setAttrib(target, ACTION, value);
    }   // setAction()

    /**
     * Adds to a creature's action.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToAction(obj_id target, int value)
    {
        return addToAttrib(target, ACTION, value);
    }   // addToAction()

    /**
     * Adds an action modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addActionModifier(obj_id target, int value, float duration,
        float attackRate, float decayRate)
    {
        return addAttribModifier(target, ACTION, value, duration, attackRate,
            decayRate);
    }   // addActionModifier()

    /**
     * Returns the action modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static attrib_mod[] getActionModifiers(obj_id target)
    {
        return getAttribModifiers(target, ACTION);
    }   // getActionModifiers()

    /**
     * Returns a creature's stamina.
     *
     * @param target        id of the creature
     *
     * @return the stamina, or ATTRIB_ERROR on fail
     */
    public static int getStam(obj_id target)
    {
        return getAttrib(target, STAMINA);
    }   // getStam()

    /**
     * Returns a creature's max stamina.
     *
     * @param target        id of the creature
     *
     * @return the max stamina, or ATTRIB_ERROR on fail
     */
    public static int getMaxStam(obj_id target)
    {
        return getMaxAttrib(target, STAMINA);
    }   // getMaxStam()

    /**
     * Sets a creature's stamina.
     *
     * @param target        id of the creature
     * @param value         new stamina value
     *
     * @return true on success, false on error
     */
    public static boolean setStam(obj_id target, int value)
    {
        return setAttrib(target, STAMINA, value);
    }   // setStam()

    /**
     * Adds to a creature's stamina.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToStam(obj_id target, int value)
    {
        return addToAttrib(target, STAMINA, value);
    }   // addToStam()

    /**
     * Adds a stamina modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addStamModifier(obj_id target, int value, float duration,
        float attackRate, float decayRate)
    {
        return addAttribModifier(target, STAMINA, value, duration, attackRate,
            decayRate);
    }   // addStamModifier()

    /**
     * Returns the stamina modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static attrib_mod[] getStamModifiers(obj_id target)
    {
        return getAttribModifiers(target, STAMINA);
    }   // getStamModifiers()

    /**
     * Returns a creature's mind.
     *
     * @param target        id of the creature
     *
     * @return the mind, or ATTRIB_ERROR on fail
     */
    public static int getMind(obj_id target)
    {
        return getAttrib(target, MIND);
    }   // getMind()

    /**
     * Returns a creature's max mind.
     *
     * @param target        id of the creature
     *
     * @return the max mind, or ATTRIB_ERROR on fail
     */
    public static int getMaxMind(obj_id target)
    {
        return getMaxAttrib(target, MIND);
    }   // getMaxMind()

    /**
     * Sets a creature's mind.
     *
     * @param target        id of the creature
     * @param value         new mind value
     *
     * @return true on success, false on error
     */
    public static boolean setMind(obj_id target, int value)
    {
        return setAttrib(target, MIND, value);
    }   // setMind()

    /**
     * Adds to a creature's mind.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToMind(obj_id target, int value)
    {
        return addToAttrib(target, MIND, value);
    }   // addToMind()

    /**
     * Adds a mind modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addMindModifier(obj_id target, int value, float duration,
        float attackRate, float decayRate)
    {
        return addAttribModifier(target, MIND, value, duration, attackRate,
            decayRate);
    }   // addMindModifier()

    /**
     * Returns the mind modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static attrib_mod[] getMindModifiers(obj_id target)
    {
        return getAttribModifiers(target, MIND);
    }   // getMindModifiers()

    /**
     * Returns a creature's willpower.
     *
     * @param target        id of the creature
     *
     * @return the willpower, or ATTRIB_ERROR on fail
     */
    public static int getWill(obj_id target)
    {
        return getAttrib(target, WILLPOWER);
    }   // getWill()

    /**
     * Returns a creature's max willpower.
     *
     * @param target        id of the creature
     *
     * @return the max willpower, or ATTRIB_ERROR on fail
     */
    public static int getMaxWill(obj_id target)
    {
        return getMaxAttrib(target, WILLPOWER);
    }   // getMaxWill()

    /**
     * Sets a creature's willpower.
     *
     * @param target        id of the creature
     * @param value         new willpower value
     *
     * @return true on success, false on error
     */
    public static boolean setWill(obj_id target, int value)
    {
        return setAttrib(target, WILLPOWER, value);
    }   // setWill()

    /**
     * Adds to a creature's willpower.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToWill(obj_id target, int value)
    {
        return addToAttrib(target, WILLPOWER, value);
    }   // addToWill()

    /**
     * Adds a willpower modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addWillModifier(obj_id target, int value, float duration,
        float attackRate, float decayRate)
    {
        return addAttribModifier(target, WILLPOWER, value, duration, attackRate,
            decayRate);
    }   // addWillModifier()

    /**
     * Returns the willpower modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static attrib_mod[] getWillModifiers(obj_id target)
    {
        return getAttribModifiers(target, WILLPOWER);
    }   // getWillModifiers()


    /**
     * Returns a creature's fear.
     *
     * @param target        id of the creature
     *
     * @return the fear, or ATTRIB_ERROR on fail
     */
    public static float getFear(obj_id target)
    {
        return getMentalState(target, FEAR);
    }   // getFear()

    /**
     * Returns a creature's fear decay time.
     *
     * @param target        id of the creature
     *
     * @return the fear, or ATTRIB_ERROR on fail
     */
    public static float getFearDecay(obj_id target)
    {
        return getMentalStateDecay(target, FEAR);
    }   // getFear()

    /**
     * Returns a creature's max fear.
     *
     * @param target        id of the creature
     *
     * @return the max fear, or ATTRIB_ERROR on fail
     */
    public static float getMaxFear(obj_id target)
    {
        return getMaxMentalState(target, FEAR);
    }   // getMaxFear()

    /**
     * Sets a creature's fear.
     *
     * @param target        id of the creature
     * @param value         new fear value
     *
     * @return true on success, false on error
     */
    public static boolean setFear(obj_id target, float value)
    {
        return setMentalState(target, FEAR, value);
    }   // setFear()

    /**
     * Sets a creature's fear decay time.
     *
     * @param target        id of the creature
     * @param value         new fear decay value
     *
     * @return true on success, false on error
     */
    public static boolean setFearDecay(obj_id target, float value)
    {
        return setMentalStateDecay(target, FEAR, value);
    }   // setFearDecay()

    /**
     * Adds to a creature's fear.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToFear(obj_id target, float value)
    {
        return addToMentalState(target, FEAR, value);
    }   // addToFear()

    /**
     * Adds a fear modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addFearModifier(obj_id target, float value, float duration,
        float attackRate, float decayRate)
    {
        return addMentalStateModifier(target, FEAR, value, duration, attackRate,
            decayRate);
    }   // addFearModifier()

    /**
     * Returns the fear modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static mental_state_mod[] getFearModifiers(obj_id target)
    {
        return getMentalStateModifiers(target, FEAR);
    }   // getFearModifiers()

    /**
     * Returns a creature's anger.
     *
     * @param target        id of the creature
     *
     * @return the anger, or ATTRIB_ERROR on fail
     */
    public static float getAnger(obj_id target)
    {
        return getMentalState(target, ANGER);
    }   // getAnger()

    /**
     * Returns a creature's max anger.
     *
     * @param target        id of the creature
     *
     * @return the max anger, or ATTRIB_ERROR on fail
     */
    public static float getMaxAnger(obj_id target)
    {
        return getMaxMentalState(target, ANGER);
    }   // getMaxAnger()

    /**
     * Returns a creature's anger decay time.
     *
     * @param target        id of the creature
     *
     * @return the fear, or ATTRIB_ERROR on fail
     */
    public static float getAngerDecay(obj_id target)
    {
        return getMentalStateDecay(target, ANGER);
    }   // getAngerDecay()

    /**
     * Sets a creature's anger.
     *
     * @param target        id of the creature
     * @param value         new anger value
     *
     * @return true on success, false on error
     */
    public static boolean setAnger(obj_id target, float value)
    {
        return setMentalState(target, ANGER, value);
    }   // setAnger()

    /**
     * Sets a creature's anger decay time.
     *
     * @param target        id of the creature
     * @param value         new fear decay value
     *
     * @return true on success, false on error
     */
    public static boolean setAngerDecay(obj_id target, float value)
    {
        return setMentalStateDecay(target, ANGER, value);
    }   // setAngerDecay()

    /**
     * Adds to a creature's anger.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToAnger(obj_id target, float value)
    {
        return addToMentalState(target, ANGER, value);
    }   // addToAnger()

    /**
     * Adds a anger modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addAngerModifier(obj_id target, float value, float duration,
        float attackRate, float decayRate)
    {
        return addMentalStateModifier(target, ANGER, value, duration, attackRate,
            decayRate);
    }   // addAngerModifier()

    /**
     * Returns the anger modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static mental_state_mod[] getAngerModifiers(obj_id target)
    {
        return getMentalStateModifiers(target, ANGER);
    }   // getAngerModifiers()

    /**
     * Returns a creature's interest.
     *
     * @param target        id of the creature
     *
     * @return the interest, or ATTRIB_ERROR on fail
     */
    public static float getInterest(obj_id target)
    {
        return getMentalState(target, INTEREST);
    }   // getInterest()

    /**
     * Returns a creature's max interest.
     *
     * @param target        id of the creature
     *
     * @return the max interest, or ATTRIB_ERROR on fail
     */
    public static float getMaxInterest(obj_id target)
    {
        return getMaxMentalState(target, INTEREST);
    }   // getMaxInterest()

    /**
     * Returns a creature's interest decay time.
     *
     * @param target        id of the creature
     *
     * @return the fear, or ATTRIB_ERROR on fail
     */
    public static float getInterestDecay(obj_id target)
    {
        return getMentalStateDecay(target, INTEREST);
    }   // getInterestDecay()

    /**
     * Sets a creature's interest.
     *
     * @param target        id of the creature
     * @param value         new interest value
     *
     * @return true on success, false on error
     */
    public static boolean setInterest(obj_id target, float value)
    {
        return setMentalState(target, INTEREST, value);
    }   // setInterest()

    /**
     * Sets a creature's interest decay time.
     *
     * @param target        id of the creature
     * @param value         new fear decay value
     *
     * @return true on success, false on error
     */
    public static boolean setInterestDecay(obj_id target, float value)
    {
        return setMentalStateDecay(target, INTEREST, value);
    }   // setInterestDecay()

    /**
     * Adds to a creature's interest.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToInterest(obj_id target, float value)
    {
        return addToMentalState(target, INTEREST, value);
    }   // addToInterest()

    /**
     * Adds a interest modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addInterestModifier(obj_id target, float value, float duration,
        float attackRate, float decayRate)
    {
        return addMentalStateModifier(target, INTEREST, value, duration, attackRate,
            decayRate);
    }   // addInterestModifier()

    /**
     * Returns the interest modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static mental_state_mod[] getInterestModifiers(obj_id target)
    {
        return getMentalStateModifiers(target, INTEREST);
    }   // getInterestModifiers()

    /**
     * Returns a creature's distress.
     *
     * @param target        id of the creature
     *
     * @return the distress, or ATTRIB_ERROR on fail
     */
    public static float getDistress(obj_id target)
    {
        return getMentalState(target, DISTRESS);
    }   // getDistress()

    /**
     * Returns a creature's max distress.
     *
     * @param target        id of the creature
     *
     * @return the max distress, or ATTRIB_ERROR on fail
     */
    public static float getMaxDistress(obj_id target)
    {
        return getMaxMentalState(target, DISTRESS);
    }   // getMaxDistress()

    /**
     * Returns a creature's distress decay time.
     *
     * @param target        id of the creature
     *
     * @return the fear, or ATTRIB_ERROR on fail
     */
    public static float getDistressDecay(obj_id target)
    {
        return getMentalStateDecay(target, DISTRESS);
    }   // getAngerDecay()

    /**
     * Sets a creature's distress.
     *
     * @param target        id of the creature
     * @param value         new distress value
     *
     * @return true on success, false on error
     */
    public static boolean setDistress(obj_id target, float value)
    {
        return setMentalState(target, DISTRESS, value);
    }   // setDistress()

    /**
     * Sets a creature's distress decay time.
     *
     * @param target        id of the creature
     * @param value         new distress decay value
     *
     * @return true on success, false on error
     */
    public static boolean setDistressDecay(obj_id target, float value)
    {
        return setMentalStateDecay(target, DISTRESS, value);
    }   // setFearDecay()

    /**
     * Adds to a creature's distress.
     *
     * @param target        id of the creature
     * @param value         value to add
     *
     * @return true on success, false on error
     */
    public static boolean addToDistress(obj_id target, float value)
    {
        return addToMentalState(target, DISTRESS, value);
    }   // addToDistress()

    /**
     * Adds a distress modifier to a creature.
     *
     * @param target        id of the creature
     * @param value         value of the modifier
     * @param duration      how long the modifier lasts (sec)
     * @param attackRate    how long to go from 0 to the modifier value (sec)
     * @param decayRate     how long to go from the modifier value to 0 (sec)
     *
     * @return true on success, false on error
     */
    public static boolean addDistressModifier(obj_id target, float value, float duration,
        float attackRate, float decayRate)
    {
        return addMentalStateModifier(target, DISTRESS, value, duration, attackRate,
            decayRate);
    }   // addDistressModifier()

    /**
     * Returns the distress modifiers on a creature.
     *
     * @param target        id of the creature
     *
     * @return an array of modifiers, or null on error or if there are none
     */
    public static mental_state_mod[] getDistressModifiers(obj_id target)
    {
        return getMentalStateModifiers(target, DISTRESS);
    }   // getDistressModifiers()


    /**
     * Allow a creature to get Ai combat pulse updates
     *
     * @param target id of the creature
     *
     */
     private static native void _scheduleAiCombatPulse(long target);
     public static void scheduleAiCombatPulse(obj_id target)
     {
        _scheduleAiCombatPulse(getLongWithNull(target));
     }

    /*@}*/

    /**
     * @defgroup worldInfo Methods used for querying objects around a location in the world.
     * @{
     */

    /** Get an array of objects which are in range of a location.
     *This returns objects of all types.
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getObjectsInRange(location from, float range);
    public static obj_id[] getObjectsInRange(location from, float range)
    {
        long[] _ret_long = _getObjectsInRange(from, range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns objects which are creatures where the creature type (constructed from the niche, species, and race) & mask == type
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesInRange(location from, float range);
    public static obj_id[] getCreaturesInRange(location from, float range)
    {
        long[] _ret_long = _getCreaturesInRange(from, range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns objects which are creatures where the masked niche matches a given value
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @param niche The creature type to find.
     *  @param mask  A bitmask allowing you to ignore certain types of creatures, in order to get creatures of only a certain niche or species
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfNicheInRange(location from, float range, int niche, int mask);
    public static obj_id[] getCreaturesOfNicheInRange(location from, float range, int niche, int mask)
    {
        long[] _ret_long = _getCreaturesOfNicheInRange(from, range, niche, mask);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns creatures of a given species
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @param species The creature type to find.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfSpeciesInRange(location from, float range, int speciecs);
    public static obj_id[] getCreaturesOfSpeciesInRange(location from, float range, int speciecs)
    {
        long[] _ret_long = _getCreaturesOfSpeciesInRange(from, range, speciecs);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns objects which are creatures where the creature type (constructed from the niche, species, and race) & mask == type
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @param species  The creature type to find.
     *  @param race The race of the particular species
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfRaceInRange(location from, float range, int species, int race);
    public static obj_id[] getCreaturesOfRaceInRange(location from, float range, int species, int race)
    {
        long[] _ret_long = _getCreaturesOfRaceInRange(from, range, species, race);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns only objects which are not creatures.
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getNonCreaturesInRange(location from, float range);
    public static obj_id[] getNonCreaturesInRange(location from, float range)
    {
        long[] _ret_long = _getNonCreaturesInRange(from, range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns only objects which are NPCs (non-player creatures).
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getNPCsInRange(location from, float range);
    public static obj_id[] getNPCsInRange(location from, float range)
    {
        long[] _ret_long = _getNPCsInRange(from, range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns only objects which are player creature avatars.
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getPlayerCreaturesInRange(location from, float range);
    public static obj_id[] getPlayerCreaturesInRange(location from, float range)
    {
        long[] _ret_long = _getPlayerCreaturesInRange(from, range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns objects of all types.
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getObjectsInRange(long from, float range);
    public static obj_id[] getObjectsInRange(obj_id from, float range)
    {
        long[] _ret_long = _getObjectsInRange(getLongWithNull(from), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns objects which are creatures where the creature type (constructed from the niche, species, and race) & mask == type
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesInRange(long from, float range);
    public static obj_id[] getCreaturesInRange(obj_id from, float range)
    {
        long[] _ret_long = _getCreaturesInRange(getLongWithNull(from), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns objects which are creatures where the masked niche matches a given value
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @param niche The creature type to find.
     *  @param mask  A bitmask allowing you to ignore certain types of creatures, in order to get creatures of only a certain niche or species
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfNicheInRange(long from, float range, int niche, int mask);
    public static obj_id[] getCreaturesOfNicheInRange(obj_id from, float range, int niche, int mask)
    {
        long[] _ret_long = _getCreaturesOfNicheInRange(getLongWithNull(from), range, niche, mask);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns creatures of a given species
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @param species The creature type to find.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfSpeciesInRange(long from, float range, int speciecs);
    public static obj_id[] getCreaturesOfSpeciesInRange(obj_id from, float range, int speciecs)
    {
        long[] _ret_long = _getCreaturesOfSpeciesInRange(getLongWithNull(from), range, speciecs);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns objects which are creatures where the creature type (constructed from the niche, species, and race) & mask == type
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @param species  The creature type to find.
     *  @param race The race of the particular species
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfRaceInRange(long from, float range, int species, int race);
    public static obj_id[] getCreaturesOfRaceInRange(obj_id from, float range, int species, int race)
    {
        long[] _ret_long = _getCreaturesOfRaceInRange(getLongWithNull(from), range, species, race);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns only objects which are not creatures.
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getNonCreaturesInRange(long from, float range);
    public static obj_id[] getNonCreaturesInRange(obj_id from, float range)
    {
        long[] _ret_long = _getNonCreaturesInRange(getLongWithNull(from), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns only objects which are NPCs (non-player creatures).
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getNPCsInRange(long from, float range);
    public static obj_id[] getNPCsInRange(obj_id from, float range)
    {
        long[] _ret_long = _getNPCsInRange(getLongWithNull(from), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in range of a location.
     *  This returns only objects which are player creature avatars.
     *
     *  @param from  The center of the range
     *  @param range The distance to query.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getPlayerCreaturesInRange(long from, float range);
    public static obj_id[] getPlayerCreaturesInRange(obj_id from, float range)
    {
        long[] _ret_long = _getPlayerCreaturesInRange(getLongWithNull(from), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get an array of performance listeners in range of a performer.
     *
     * @param performer  The performer to look for
     * @param range The distance to query.
     * @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getPerformanceListenersInRange(long performer, float range);
    public static obj_id[] getPerformanceListenersInRange(obj_id performer, float range)
    {
        long[] _ret_long = _getPerformanceListenersInRange(getLongWithNull(performer), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get an array of performance watchers in range of a performer.
     *
     * @param performer  The performer to look for
     * @param range The distance to query.
     * @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getPerformanceWatchersInRange(long performer, float range);
    public static obj_id[] getPerformanceWatchersInRange(obj_id performer, float range)
    {
        long[] _ret_long = _getPerformanceWatchersInRange(getLongWithNull(performer), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in a cone of a location.
     *This returns objects of all types.
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getObjectsInCone(long coneCenterObject, long coneDirectionObject, float range, float angle);
    public static obj_id[] getObjectsInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle)
    {
        long[] _ret_long = _getObjectsInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
	/** Get an array of objects which are in a cone of a location.
     *This returns objects of all types.
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionLocation The position to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this position (scene value of the location ignored).
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getObjectsInCone(long coneCenterObject, location coneDirectionLocation, float range, float angle);
    public static obj_id[] getObjectsInCone(obj_id coneCenterObject, location coneDirectionLocation, float range, float angle)
    {
        long[] _ret_long = _getObjectsInCone(getLongWithNull(coneCenterObject), coneDirectionLocation, range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

	/** Get an array of creatures which are in a specified cone.
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @return null if there is an error, or an array of creatures which are in range.
     */
    private static native long[] _getCreaturesInCone(long coneCenterObject, long coneDirectionObject, float range, float angle);
    public static obj_id[] getCreaturesInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle)
    {
        long[] _ret_long = _getCreaturesInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of creatures which are in a specified cone.
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionLocation The position to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this position (scene value of the location ignored).
	 *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @return null if there is an error, or an array of creatures which are in range.
     */
    private static native long[] _getCreaturesInCone(long coneCenterObject, location coneDirectionLocation, float range, float angle);
    public static obj_id[] getCreaturesInCone(obj_id coneCenterObject, location coneDirectionLocation, float range, float angle)
    {
        long[] _ret_long = _getCreaturesInCone(getLongWithNull(coneCenterObject), coneDirectionLocation, range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

    /** Get an array of objects which are in a cone of a location.
     *  This returns objects which are creatures where the masked niche matches a given value
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @param niche                The creature type to find.
     *  @param mask                 A bitmask allowing you to ignore certain types of creatures, in
     *                              order to get creatures of only a certain niche or species
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfNicheInCone(long coneCenterObject, long coneDirectionObject, float range, float angle, int niche, int mask);
    public static obj_id[] getCreaturesOfNicheInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle, int niche, int mask)
    {
        long[] _ret_long = _getCreaturesOfNicheInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle, niche, mask);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in a cone of a location.
     *  This returns creatures of a given species
     *
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @param species              The creature type to find.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfSpeciesInCone(long coneCenterObject, long coneDirectionObject, float range, float angle, int speciecs);
    public static obj_id[] getCreaturesOfSpeciesInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle, int speciecs)
    {
        long[] _ret_long = _getCreaturesOfSpeciesInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle, speciecs);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in a cone of a location.
     *  This returns objects which are creatures where the creature type (constructed from the niche, species, and race) & mask == type
     *
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @param species              The creature type to find.
     *  @param race                 The race of the particular species
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getCreaturesOfRaceInCone(long coneCenterObject, long coneDirectionObject, float range, float angle, int species, int race);
    public static obj_id[] getCreaturesOfRaceInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle, int species, int race)
    {
        long[] _ret_long = _getCreaturesOfRaceInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle, species, race);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in a cone of a location.
     *  This returns only objects which are not creatures.
     *
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getNonCreaturesInCone(long coneCenterObject, long coneDirectionObject, float range, float angle);
    public static obj_id[] getNonCreaturesInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle)
    {
        long[] _ret_long = _getNonCreaturesInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in a cone of a location.
     *  This returns only objects which are NPCs (non-player creatures).
     *
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getNPCsInCone(long coneCenterObject, long coneDirectionObject, float range, float angle);
    public static obj_id[] getNPCsInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle)
    {
        long[] _ret_long = _getNPCsInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /** Get an array of objects which are in a cone of a location.
     *  This returns only objects which are player creature avatars.
     *
     *
     *  @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     *  @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this object's position.
     *  @param range                The distance to query from the center of the cone.  Note the cone
     *                              extends along the cone axis this distance, and does not necessarily
     *                              extend as far as the cone direction object's distance from the cone center.
     *  @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                              total cone angle is twice this angle; therefore, this angle
     *                              represents the angle swept out to each side of the cone axis.
     *  @return null if there is an error, or an array of objects which are in range.
     */
    private static native long[] _getPlayerCreaturesInCone(long coneCenterObject, long coneDirectionObject, float range, float angle);
    public static obj_id[] getPlayerCreaturesInCone(obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle)
    {
        long[] _ret_long = _getPlayerCreaturesInCone(getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Find an arbitrary location near a spot.
     * @todo Remove the "target" parameter -- not needed
     * @todo take into account terrain and objects in the way
     * @todo make a way to indicate there are no legal locations in the area
     * @param loc The spot
     * @param radius The maximum x or z distance from the spot
     * @return An arbitrary location within radius of loc.  Note that this function actually
     * finds a spot within a square centered on loc.
     */
    private static native location _findSpotNear(long target, location loc, float radius);
    public static location findSpotNear(obj_id target, location loc, float radius)
    {
        return _findSpotNear(getLongWithNull(target), loc, radius);
    }
    /**
     * Is an object facing towards a particular spot?
     * @param mob The object in question
     * @param target The location, in world coordinates
     * @return True if the object is facing towards the target.
     */
    private static native boolean _isFacing(long mob, location target);
    public static boolean isFacing(obj_id mob, location target)
    {
        return _isFacing(getLongWithNull(mob), target);
    }
    /**
     * Get the distance between two objects. The distance is in three dimensions,
     * i.e. it takes elevation into account. Note that this is the distance between
     * the bounding-sphere edges, not the centers.
     * @param target1 The first object
     * @param target2 The second object
     * @return The distance between target1 and target2, or -1 on error
     */
    private static native float _getDistance(long target1, long target2);
    public static float getDistance(obj_id target1, obj_id target2)
    {
        return _getDistance(getLongWithNull(target1), getLongWithNull(target2));
    }
    /**
     * Get the distance between two locations.
     * @param loc1 The first location
     * @param loc2 The second location
     * @return The distance between loc1 and loc2, or -1 on error
     */
    public static float getDistance(location loc1, location loc2)
    {
        if (loc1 == null || loc2 == null)
            return -1.0f;

        if (!loc1.area.equals(loc2.area))
            return -1.0f;

        if (loc1.cell == loc2.cell || ((loc1.cell == null || loc1.cell == obj_id.NULL_ID) &&
            (loc2.cell == null || loc2.cell == obj_id.NULL_ID)))
        {
            return loc1.distance(loc2);
        }

        return _getDistance(loc1, loc2);
    }
    /**
     * Get the distance between an object and a location
     * @param target    the object
     * @param loc       the location
     * @return The distance between loc1 and loc2, or -1 on error
     */
    public static float getDistance(obj_id target, location loc)
    {
        if (target == null || target == obj_id.NULL_ID || loc == null)
            return -1;

        return getDistance(getLocation(target), loc);
    }
    /**
     * Get the distance between two locations. Only called if the locations are in
     * different cells.
     * @param loc1 The first location
     * @param loc2 The second location
     * @return The distance between loc1 and loc2, or -1 on error
     */
    private static native float _getDistance(location loc1, location loc2);

    /**
     * Check to see if a location is within a conical frustum
     * @param testLoc The location we are checking
     * @param startLoc The center of one end of the frustum
     * @param endLoc The center of the other end of the frustum
     * @param startRadius The radius of the frustum at startLoc
     * @param endRadius The radius of the frustum at endLoc
     * @return true if the location is within the frustum, false if not or if the data is bad
     */
    private static native boolean _isLocationWithinConicalFrustum(location testLoc, location startLoc, location endLoc, float startRadius, float endRadius, boolean use2d);
    public static boolean isLocationWithinConicalFrustum(location testLoc, location startLoc, location endLoc, float startRadius, float endRadius)
    {
		if(testLoc == null || startLoc == null || endLoc == null)
			return false;

		if(!startLoc.area.equals(endLoc.area) || !testLoc.area.equals(startLoc.area))
			return false;

		//if everything is in the same cell we can do the math in java
		if((testLoc.cell == startLoc.cell && startLoc.cell == endLoc.cell)
		|| (isIdNull(testLoc.cell) && isIdNull(startLoc.cell) && isIdNull(endLoc.cell)))
		{
			vector testPoint = new vector(testLoc.x, testLoc.y, testLoc.z);
			vector startPoint = new vector(startLoc.x, startLoc.y, startLoc.z);
			vector endPoint = new vector(endLoc.x, endLoc.y, endLoc.z);

			return testPoint.isWithinConicalFrustum(startPoint, endPoint, startRadius, endRadius);
		}

		return _isLocationWithinConicalFrustum(testLoc, startLoc, endLoc, startRadius, endRadius, false);
	}

    public static boolean isLocationWithinConicalFrustum2d(location testLoc, location startLoc, location endLoc, float startRadius, float endRadius)
    {
		if(testLoc == null || startLoc == null || endLoc == null)
			return false;

		if(!startLoc.area.equals(endLoc.area) || !testLoc.area.equals(startLoc.area))
			return false;

		//if everything is in the same cell we can do the math in java
		if((testLoc.cell == startLoc.cell && startLoc.cell == endLoc.cell)
		|| (isIdNull(testLoc.cell) && isIdNull(startLoc.cell) && isIdNull(endLoc.cell)))
		{
			vector testPoint = new vector(testLoc.x, 0.0f, testLoc.z);
			vector startPoint = new vector(startLoc.x, 0.0f, startLoc.z);
			vector endPoint = new vector(endLoc.x, 0.0f, endLoc.z);

			return testPoint.isWithinConicalFrustum(startPoint, endPoint, startRadius, endRadius);
		}

		return _isLocationWithinConicalFrustum(testLoc, startLoc, endLoc, startRadius, endRadius, true);
	}


    /**
     * Check to see if a location is within a cone given a point, direction, range and angle
     * @param testLoc       The location we are checking
     * @param startLoc      The point of the cone
     * @param directionLoc  A point on the axis of the cone. This defines the direction and
     *                      centerline of the cone but not the distance
     * @param range         The range of the cone
     * @param halfAngle     The half angle of the cone in degrees--how far (in both directions)
     *                      the cone extends from the axis.
     * @return true if the location is within the cone, false if not or if the data is bad
     */
    private static native boolean _isLocationInCone(location testLoc, location startLoc, location directionLoc, float range, float halfAngle, boolean use2d);
    public static boolean isLocationInCone(location testLoc, location startLoc, location directionLoc, float range, float halfAngle)
    {
		if(testLoc == null || startLoc == null || directionLoc == null)
			return false;

		if(!startLoc.area.equals(directionLoc.area) || !testLoc.area.equals(startLoc.area))
			return false;

		//if everything is in the same cell we can do the math in java
		if((testLoc.cell == startLoc.cell && startLoc.cell == directionLoc.cell)
		|| (isIdNull(testLoc.cell) && isIdNull(startLoc.cell) && isIdNull(directionLoc.cell)))
		{
			vector testPoint = new vector(testLoc.x, testLoc.y, testLoc.z);
			vector startPoint = new vector(startLoc.x, startLoc.y, startLoc.z);
			vector directionPoint = new vector(directionLoc.x, directionLoc.y, directionLoc.z);

			return testPoint.isWithinCone(startPoint, directionPoint, range, halfAngle);
		}

		return _isLocationInCone(testLoc, startLoc, directionLoc, range, halfAngle, false);
	}

    public static boolean isLocationInCone2d(location testLoc, location startLoc, location directionLoc, float range, float halfAngle)
    {
		if(testLoc == null || startLoc == null || directionLoc == null)
			return false;

		if(!startLoc.area.equals(directionLoc.area) || !testLoc.area.equals(startLoc.area))
			return false;

		//if everything is in the same cell we can do the math in java
		if((testLoc.cell == startLoc.cell && startLoc.cell == directionLoc.cell)
		|| (isIdNull(testLoc.cell) && isIdNull(startLoc.cell) && isIdNull(directionLoc.cell)))
		{
			vector testPoint = new vector(testLoc.x, 0.0f, testLoc.z);
			vector startPoint = new vector(startLoc.x, 0.0f, startLoc.z);
			vector directionPoint = new vector(directionLoc.x, 0.0f, directionLoc.z);

			return testPoint.isWithinCone(startPoint, directionPoint, range, halfAngle);
		}

		return _isLocationInCone(testLoc, startLoc, directionLoc, range, halfAngle, true);
	}


    /**
     * Get the closest non-player creature to a location.
     * @todo Add a radius parameter
     * @param loc The location
     */
    private static native long _getClosestMobile(location loc);
    public static obj_id getClosestMobile(location loc)
    {
        return getObjIdWithNull(_getClosestMobile(loc));
    }
    /**
     * Get the closest player to a location.
     * @todo Add a radius parameter
     * @param loc The location
     */
    private static native long _getClosestPlayer(location loc);
    public static obj_id getClosestPlayer(location loc)
    {
        return getObjIdWithNull(_getClosestPlayer(loc));
    }
    /**
     * Get all the non-player creatures within a radius
     * @param loc The location
     * @param radius The radius
     */
    private static native long[] _getAllNpcs(location loc, float radius);
    public static obj_id[] getAllNpcs(location loc, float radius)
    {
        long[] _ret_long = _getAllNpcs(loc, radius);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get all the players within a radius
     * @param loc The location
     * @param radius The radius
     */
    private static native long[] _getAllPlayers(location loc, float radius);
    public static obj_id[] getAllPlayers(location loc, float radius)
    {
        long[] _ret_long = _getAllPlayers(loc, radius);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get the elevation of the terrain at a particular location.
     * @param loc The location to test (y coordinate is ignored)
     * @return The height of the terrain at that spot
     */
    public static native float getElevation(location loc);
    /**
     * Determine if the terrtain at the given location in the world is below the water (the location should be in world space, i.e. outside).
     * @param loc The location to test (y coordinate is ignored)
     * @return true if the xz location is below the water, else false
     */
    public static native boolean isBelowWater(location loc);
    /**
     * Find out the height of the water table at the given location (the location should be in world space, i.e. outside).
     * @param loc The location to test (y coordinate is ignored)
     * @return the height of the water table
     */
    public static native float getWaterTableHeight(location loc);

    /**
     * true if there is exposed water above the terrain in the given rect
     * @param x0 - ll x coord
     * @param y0 - ll y coord
     * @param x1 - ur x coord
     * @param y1 - ur y coord
     * @return true if exposed water in rect
     */
    public static native boolean isWaterInRect(float x0, float y0, float x1, float y1);

    /**
     * Ask the PlanetServer for a valid location of size locationRadius within the search circle.
     * @param receiver The obj_id of the object to receive the OnLocationReceived trigger
     * @param locationId An user-identifier for the location
     * @param searchX Search circle X
     * @param searchZ Search circle Z
     * @param searchRadius Search circle radius
     * @param locationRadius The size of the requested location
     * @param checkWater Should water should block the location?
     * @param checkSlope Should slope should block the location?
     */
    private static native boolean _requestLocation(long receiver, String locationId, location searchLocation, float searchRadius, float locationRadius, boolean checkWater, boolean checkSlope);
    public static boolean requestLocation (obj_id receiver, String locationId, location searchLocation, float searchRadius, float locationRadius, boolean checkWater, boolean checkSlope)
    {
        return _requestLocation(getLongWithNull(receiver), locationId, searchLocation, searchRadius, locationRadius, checkWater, checkSlope);
    }

    private static native boolean _isRelativePointOnSameFloorAsObject(long scriptObject, float relativeXLocation, float relativeZLocation);
    public static boolean isRelativePointOnSameFloorAsObject              (obj_id scriptObject, float relativeXLocation, float relativeZLocation)
    {
        return _isRelativePointOnSameFloorAsObject(getLongWithNull(scriptObject), relativeXLocation, relativeZLocation);
    }
    private static native float   _getFloorHeightAtRelativePointOnSameFloorAsObject(long scriptObject, float relativeXLocation, float relativeZLocation);
    public static float   getFloorHeightAtRelativePointOnSameFloorAsObject(obj_id scriptObject, float relativeXLocation, float relativeZLocation)
    {
        return _getFloorHeightAtRelativePointOnSameFloorAsObject(getLongWithNull(scriptObject), relativeXLocation, relativeZLocation);
    }
    private static native boolean _isOnAFloor(long scriptObject);
    public static boolean isOnAFloor                                      (obj_id scriptObject)
    {
        return _isOnAFloor(getLongWithNull(scriptObject));
    }

    /**
     * Returns the id of the object that target is standing on.
     * @param target  the object we want to check
     * @return id of the object that target is standing on or invalid if target is not standing on an object (e.g. standing on terrain)
     */
    private static native long _getStandingOn(long target);
    public static obj_id getStandingOn(obj_id target)
    {
        return getObjIdWithNull(_getStandingOn(getLongWithNull(target)));
    }

    /**
     * Are two objects both facing towards eachother?
     * @param mob1 The first object
     * @param mob2 The second object
     * @return True if each object is facing the other.
     */
    private static native boolean _areFacingEachOther(long mob1, long mob2);
    public static boolean areFacingEachOther(obj_id mob1, obj_id mob2)
    {
        return _areFacingEachOther(getLongWithNull(mob1), getLongWithNull(mob2));
    }
    /**
     * Get an arbitrary location between two locations
     * @param target1 the first location
     * @param target2 the second location
     * @return a valid location
     */
    public static native location getLocationBetweenLocs(location target1, location target2);
    /**
     * Get an arbitrary object within a range that has a script.
     * Note:  Does not guarantee to get the closest object.
     * @param loc where to look
     * @param range how far away to look
     * @param script the script to look for
     * @return An object with the script
     */
    private static native long _getFirstObjectWithScript(location loc, float range, String script);
    public static obj_id getFirstObjectWithScript(location loc, float range, String script)
    {
        return getObjIdWithNull(_getFirstObjectWithScript(loc, range, script));
    }
    /**
     * Get an arbitrary object within a range that has an object variable
     * Note:  Does not guarantee to get the closest object.
     * @param loc where to look
     * @param range how far away to look
     * @param script the object variable to look for
     * @return An object with the object variable
     */
    private static native long _getFirstObjectWithObjVar(location loc, float range, String objvar);
    public static obj_id getFirstObjectWithObjVar(location loc, float range, String objvar)
    {
        return getObjIdWithNull(_getFirstObjectWithObjVar(loc, range, objvar));
    }
    /**
     * Get an arbitrary object within a range that is made from a particular template
     * Note:  Does not guarantee to get the closest object.
     * @param loc where to look
     * @param range how far away to look
     * @param script the template to look for
     * @return An object that was created using the template
     */
    private static native long _getFirstObjectWithTemplate(location loc, float range, String templateName);
    public static obj_id getFirstObjectWithTemplate(location loc, float range, String templateName)
    {
        return getObjIdWithNull(_getFirstObjectWithTemplate(loc, range, templateName));
    }
    /**
     * Get all the objects within range that have a particular script.
     * @param loc where to look
     * @param range how far away to look
     * @param script the script to look for
     * @return All the objects in range with the script
     */
    private static native long[] _getAllObjectsWithScript(location loc, float range, String script);
    public static obj_id[] getAllObjectsWithScript(location loc, float range, String script)
    {
        long[] _ret_long = _getAllObjectsWithScript(loc, range, script);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get all the objects within range that have a particular object variable.
     * @param loc where to look
     * @param range how far away to look
     * @param objvar the object variable to look for
     * @return All the objects in range with the object variable.
     */
    private static native long[] _getAllObjectsWithObjVar(location loc, float range, String objvar);
    public static obj_id[] getAllObjectsWithObjVar(location loc, float range, String objvar)
    {
        long[] _ret_long = _getAllObjectsWithObjVar(loc, range, objvar);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get all the objects within range that were made from a particular template
     * @param loc where to look
     * @param range how far away to look
     * @param templateName the template to look for
     * @return All the objects in range that were made from the template
     */
    private static native long[] _getAllObjectsWithTemplate(location loc, float range, String templateName);
    public static obj_id[] getAllObjectsWithTemplate(location loc, float range, String templateName)
    {
        long[] _ret_long = _getAllObjectsWithTemplate(loc, range, templateName);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Compute the direction from one location to another.
     * @param loc1 The first location.
     * @param loc2 The target location.
     * @return The direction from loc1 to loc2.  0 indicates north, 90 indicates east, etc.
     */
    public static native float getDirection(location loc1, location loc2);
    /**
     * Is a particular object id valid?
     * @param target The object id
     * @return true if the object id refers to an object that is present on this server.
     */
    private static native boolean _exists(long target);
    public static boolean exists(obj_id target)
    {
        return _exists(getLongWithNull(target));
    }
    /**
     * Is the given location valid? (not underwater, not inside a building, etc.)
     * @param loc The position which we're testing
     * @param radius The distance around the position that must be empty for the position to be valid
     * @return True if there's nothing within radius of the position
     */
    public static native boolean isValidLocation(location loc, float radius);
    /**
     * Find a valid point inside the corral that's near the given point
     * @param corralCenter The center of the 'corral' that we'd like the object to be inside
     * @param corralRadius The size of the corral
     * @param desiredLoc The location that the valid location should be near (if possible)
     * @param objectRadius The size of the object we're trying to find a good location for
     * @return The valid location if one is found, otherwise NULL
     */
    public static native location getValidLocation(location corralCenter, float corralRadius, location desiredLoc, float objectRadius);
    /**
     * Tests to see if an object can see another object.
     * @param source        object that is looking
     * @param target        object that is being looked at
     * @return true if the source can see the target, false otherwise
     */
    private static native boolean _canSee(long source, long target);
    public static boolean canSee(obj_id source, obj_id target)
    {
        return _canSee(getLongWithNull(source), getLongWithNull(target));
    }
	/**
     * Tests to see if an object can see a location.
     * @param source        object that is looking
     * @param target        where the source is looking at
     * @return true if the source can see the target, false otherwise
     */
    private static native boolean _canSee(long source, location target);
    public static boolean canSee(obj_id source, location target)
    {
        return _canSee(getLongWithNull(source), target);
    }
    /**
     * Tests to see if an object can manipulate another object.
     * @param player        player that wants to manipulate something
     * @param target        object they want to manipulate
     * @param move                  bool whether they are moving the target
     * @param doPermission          bool whether or not to check ownership permissions
     * @param distance              maximum distance allowed
     * @param sendMessage           bool whether to send an error message to the client on failure
     * @param skipNoTradeCheck      bool ignore no trade restriction (***USE WISELY***)
     * @return true if the source can see the target, false otherwise
     */
    private static native boolean _canManipulate(long player, long target, boolean move, boolean doPermission, float distance, boolean sendMessage, boolean skipNoTradeCheck);
    public static boolean canManipulate(obj_id player, obj_id target, boolean move, boolean doPermission, float distance, boolean sendMessage)
    {
        return _canManipulate(getLongWithNull(player), getLongWithNull(target), move, doPermission, distance, sendMessage, false);
    }
    public static boolean canManipulateSkipNoTradeCheck(obj_id player, obj_id target, boolean move, boolean doPermission, float distance, boolean sendMessage)
    {
        return _canManipulate(getLongWithNull(player), getLongWithNull(target), move, doPermission, distance, sendMessage, true);
    }
    /*@}*/

    /**
     * @defgroup appearanceCustomization Appearance customization methods
     *
     * Methods used for querying and modifying customization data associated
     * with a specified tangible object.
     *
     * @{
     */

    /**
     * Retrieve the customization variables (custom_var instances) associated
     * with the specified tangible object.
     *
     * @param target  the obj_id representing the tangible object for which
     *                customization variables will be retrieved.
     *
     * @return  null if the object type is not derived from tangible object;
     *          null if the object does not have any customization variables;
     *          an array of custom_var instances, one for each customization
     *          variable exposed on the object.
     *
     * @depracated  don't use this until we can make casting from a custom_var
     *              to another type work within the Java VM.
     *
     * @see custom_var
     */
    private static native custom_var[] _getAllCustomVars(long target);
    public static custom_var[] getAllCustomVars(obj_id target)
    {
        return _getAllCustomVars(getLongWithNull(target));
    }

    /**
     * Retrieve the named customization variable influencing the given obj_id.
     *
     * @param target       identifies the object for which to return a customization
     *                     variable.
     * @param varPathName  the full path name for the variable (e.g. "/shared_owner/skinny").
     *
     * @return  the custom_var instance providing access to the customization variable.
     *          Will return null if the specified variable doesn't exist for the given
     *          object.
     *
     * @depracated  don't use this until we can make casting from a custom_var
     *              to another type work within the Java VM.
     */
    private static native custom_var _getCustomVarByName(long target, String varPathName);
    public static custom_var getCustomVarByName(obj_id target, String varPathName)
    {
        return _getCustomVarByName(getLongWithNull(target), varPathName);
    }

    /**
     * Retrieve the color of the specified palette color customization variable
     * associated with the given Object instance.
     *
     * Scripters should avoid calling this directly.  Instead, make use of the
     * palcolor_custom_var class.  To test if  a custom_var can be converted (casted)
     * to a palcolor_custom_var, call custom_var.isPalColor().
     *
     * @param target       the Object instance for which the color will be retrieved.
     * @param varPathName  the name of the palette color variable to retrieve.
     *
     * @return  the color of the palette color customization variable.
     *
     * @see color
     * @see palcolor_custom_var
     * @see palcolor_custom_var.getSelectedColor()
     * @see custom_var.isPalColor()
     */
    private static native color _getPalcolorCustomVarSelectedColor(long target, String varPathName);
    public static color getPalcolorCustomVarSelectedColor(obj_id target, String varPathName)
    {
        return _getPalcolorCustomVarSelectedColor(getLongWithNull(target), varPathName);
    }

    /**
     * Set the color of the palette color customization variable to the
     * color within the palette that is closest to the specified color.
     *
     * Scripters should avoid calling this directly.  Instead, make use of the
     * palcolor_custom_var class.  To test if  a custom_var can be converted (casted)
     * to a palcolor_custom_var, call custom_var.isPalColor().
     *
     * @param target       the Object instance for which the color will be retrieved.
     * @param varPathName  the name of the palette color variable to retrieve.
     * @param r            the red component of the desired color.  Must be in range 0..255, inclusive.
     * @param g            the green component of the desired color.  Must be in range 0..255, inclusive.
     * @param b            the blue component of the desired color.  Must be in range 0..255, inclusive.
     * @param a            the alpha component of the desired color.  Must be in range 0..255, inclusive.  Usually this should be 255.
     *
     * @see color
     * @see palcolor_custom_var
     * @see palcolor_custom_var.setToClosestColor()
     * @see custom_var.isPalColor()
     */
    private static native void _setPalcolorCustomVarClosestColor(long target, String varPathName, int r, int g, int b, int a);
    public static void setPalcolorCustomVarClosestColor(obj_id target, String varPathName, int r, int g, int b, int a)
    {
        _setPalcolorCustomVarClosestColor(getLongWithNull(target), varPathName, r, g, b, a);
    }

    /**
     * Retrieve all of the palette colors associated with the specified
     * palette color customization variable.
     *
     * Scripters should avoid calling this directly.  Instead, make use of the
     * palcolor_custom_var class.  To test if  a custom_var can be converted (casted)
     * to a palcolor_custom_var, call custom_var.isPalColor().
     *
     * @param target       the Object instance for which the color will be retrieved.
     * @param varPathName  the name of the palette color variable from which palette colors will be retrieved.
     *
     * @return  an ordered array of color instances, each entry representing a color in the palette.
     *          The color of palette entry zero is in returnArray[0].
     *
     * @see color
     * @see palcolor_custom_var
     * @see custom_var.isPalColor()
     */
    private static native color[] _getPalcolorCustomVarColors(long target, String varPathName);
    public static color[] getPalcolorCustomVarColors(obj_id target, String varPathName)
    {
        return _getPalcolorCustomVarColors(getLongWithNull(target), varPathName);
    }

    /**
     * Retrieve the int value for a ranged-int style customization variable.
     *
     * Scripters should not need to call this directly.  Retrieve a
     * custom_var instance that is compatible with ranged_int_custom_var.
     * Call ranged_int_custom_getLongWithNull(var) rather than this function unless
     * you really know what you're doing.
     *
     * This function works for instances of any of the engine's CustomizationVariable classes
     * derived from RangedIntCustomizationVariable.  On script side, this includes
     * the ranged_int_custom_var class.
     *
     * @param target       the Object containing the specified customization variable.
     * @param varPathName  the full pathname of the variable to retrieve.
     *
     * @return  the int value for the specified variable.  If the specified variable
     *          doesn't exist, a value of 0 is returned.
     */
    private static native int _getRangedIntCustomVarValue(long target, String varPathName);
    public static int getRangedIntCustomVarValue(obj_id target, String varPathName)
    {
        return _getRangedIntCustomVarValue(getLongWithNull(target), varPathName);
    }

    /**
     * Set the int value for a ranged-int style customization variable.
     *
     * Scripters should not need to call this directly.  Retrieve a
     * custom_var instance that is compatible with ranged_int_custom_var.
     * Call ranged_int_custom_var.setValue(newValue) rather than this function unless
     * you really know what you're doing.
     *
     * If the specified value is outside the valid range, this function does not change
     * the value of the variable.
     *
     * This function works for instances of any of the engine's CustomizationVariable classes
     * derived from RangedIntCustomizationVariable.  On script side, this includes
     * the ranged_int_custom_var class.
     *
     * @param target       the Object containing the specified customization variable.
     * @param varPathName  the full pathname of the variable to retrieve.
     *
     * @return  the int value for the specified variable.  If the specified variable
     *          doesn't exist, a value of 0 is returned.
     */
    private static native void _setRangedIntCustomVarValue(long target, String varPathName, int newValue);
    public static void setRangedIntCustomVarValue(obj_id target, String varPathName, int newValue)
    {
        _setRangedIntCustomVarValue(getLongWithNull(target), varPathName, newValue);
    }


    /**
     * Send a message to the channel-based output.
     *
     * @param channel the name of the channel to use
     * @param message the text to send
     */
    public native void printChannelMessage(String channel, String message);

    /*@}*/

    /**
     * @defgroup money Methods for dealing with money
     * @{
     */

    /**
     * Transfer cash from one object to another.
     *
     * @param source  the object supplying the money
     * @param target  the object receiving the money
     * @param amount  how much money to transfer
     * @param successCallbackFunction function to call if the transfer succeeds
     * @param failCallbackFunction function to call if the transfer fails
     * @param callbackData dictionary to pass to the callback
     * @return false if there is an error
     */
    private static native boolean _transferCashTo(long source, long target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData);
    public static boolean transferCashTo(obj_id source, obj_id target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData)
    {
        return _transferCashTo(getLongWithNull(source), getLongWithNull(target), amount, successCallbackFunction, failCallbackFunction, callbackData);
    }
    /**
     * Transfer bank credits from one object to another.
     *
     * @param source  the object supplying the money
     * @param target  the object receiving the money
     * @param amount  how much money to transfer
     * @param successCallbackFunction function to call if the transfer succeeds
     * @param failCallbackFunction function to call if the transfer fails
     * @param callbackData dictionary to pass to the callback
     * @return false if there is an error
     */
    private static native boolean _transferBankCreditsTo(long source, long target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData);
    public static boolean transferBankCreditsTo(obj_id source, obj_id target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData)
    {
        return _transferBankCreditsTo(getLongWithNull(source), getLongWithNull(target), amount, successCallbackFunction, failCallbackFunction, callbackData);
    }
    /**
     * Transfer bank credits from an object to a named account.
     *
     * @param source  the object supplying the money
     * @param target  the account receiving the money
     * @param amount  how much money to transfer
     * @param successCallbackFunction function to call if the transfer succeeds
     * @param failCallbackFunction function to call if the transfer fails
     * @param callbackData dictionary to pass to the callback
     * @return false if there is an error
     */
    private static native boolean _transferBankCreditsToNamedAccount(long source, String target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData);
    public static boolean transferBankCreditsToNamedAccount(obj_id source, String target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData)
    {
        return _transferBankCreditsToNamedAccount(getLongWithNull(source), target, amount, successCallbackFunction, failCallbackFunction, callbackData);
    }
    /**
     * Transfer bank credits from a named account to an object
     *
     * @param source  the account supplying the money
     * @param target  the object receiving the money
     * @param amount  how much money to transfer
     * @param successCallbackFunction function to call if the transfer succeeds
     * @param failCallbackFunction function to call if the transfer fails
     * @param callbackData dictionary to pass to the callback
     * @return false if there is an error
     */
    private static native boolean _transferBankCreditsFromNamedAccount(String source, long target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData);
    public static boolean transferBankCreditsFromNamedAccount(String source, obj_id target, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData)
    {
        return _transferBankCreditsFromNamedAccount(source, getLongWithNull(target), amount, successCallbackFunction, failCallbackFunction, callbackData);
    }
    /**
     * Withdraw credits from the object's bank account, placing them in the objects inventory
     *
     * @param source  the object
     * @param amount  how much money to transfer
     * @param successCallbackFunction function to call if the transfer succeeds
     * @param failCallbackFunction function to call if the transfer fails
     * @param callbackData dictionary to pass to the callback
     * @return false if there is an error
     */
    private static native boolean _withdrawCashFromBank(long source, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData);
    public static boolean withdrawCashFromBank(obj_id source, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData)
    {
        return _withdrawCashFromBank(getLongWithNull(source), amount, successCallbackFunction, failCallbackFunction, callbackData);
    }
    /**
     * Remove credits from the object's inventory, placing them in the object's bank account
     *
     * @param source  the object
     * @param amount  how much money to transfer
     * @param successCallbackFunction function to call if the transfer succeeds
     * @param failCallbackFunction function to call if the transfer fails
     * @param callbackData dictionary to pass to the callback
     * @return false if there is an error
     */
    private static native boolean _depositCashToBank(long source, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData);
    public static boolean depositCashToBank(obj_id source, int amount, String successCallbackFunction, String failCallbackFunction, dictionary callbackData)
    {
        return _depositCashToBank(getLongWithNull(source), amount, successCallbackFunction, failCallbackFunction, callbackData);
    }

    /**
     * deposit 1 billion from bank/cash into galactic reserve
     */
    private static native void _depositToGalacticReserve(long player);
    public static void depositToGalacticReserve(obj_id player)
    {
        _depositToGalacticReserve(getLongWithNull(player));
    }

    /**
     * withdraw 1 billion from galactic reserve into bank/cash
     */
    private static native void _withdrawFromGalacticReserve(long player);
    public static void withdrawFromGalacticReserve(obj_id player)
    {
        _withdrawFromGalacticReserve(getLongWithNull(player));
    }

    /**
     * must be at a bank terminal in Mos Eisley, Theed, or Coronet to access the Galactic Reserve
     */
    private static native boolean _canAccessGalacticReserve(long player);
    public static boolean canAccessGalacticReserve(obj_id player)
    {
        return _canAccessGalacticReserve(getLongWithNull(player));
    }

    /**
     * Get the amount of cash an object is carrying.
     * Note:  This function may lag behind the actual value.
     * You cannot assume that a transfer of less money than the value returned will always succeed.
     *
     * @param source  the object
     * @return The amount of cash the object is carrying.
     */
    private static native int _getCashBalance(long source);
    public static int getCashBalance(obj_id source)
    {
        return _getCashBalance(getLongWithNull(source));
    }
    /**
     * Get the amount of money in an object's bank account
     * Note:  This function may lag behind the actual value.
     * You cannot assume that a transfer of less money than the value returned will always succeed.
     *
     * @param source  the object
     * @return The amount of money in the object's bank account, or 0 if the object has no bank account
     */
    private static native int _getBankBalance(long source);
    public static int getBankBalance(obj_id source)
    {
        return _getBankBalance(getLongWithNull(source));
    }
    /**
     * Get the total amount of money an object has
     * Note:  This function may lag behind the actual value.
     * You cannot assume that a transfer of less money than the value returned will always succeed.
     *
     * @param source  the object
     * @return bank balance + cash
     */
    private static native int _getTotalMoney(long source);
    public static int getTotalMoney(obj_id source)
    {
        return _getTotalMoney(getLongWithNull(source));
    }
    private static native void _getMoneyFromOfflineObject(long sourceObject, int amount, String target, String successCallbackFunction, String failCallbackFunction, dictionary callbackData);
    public static void getMoneyFromOfflineObject(obj_id sourceObject, int amount, String target, String successCallbackFunction, String failCallbackFunction, dictionary callbackData)
    {
        _getMoneyFromOfflineObject(getLongWithNull(sourceObject), amount, target, successCallbackFunction, failCallbackFunction, callbackData);
    }

    private static native void _openBankContainer(long bank, long player);
    public static void openBankContainer(obj_id bank, obj_id player)
    {
        _openBankContainer(getLongWithNull(bank), getLongWithNull(player));
    }
    private static native void _quitBank(long player);
    public static void quitBank(obj_id player)
    {
        _quitBank(getLongWithNull(player));
    }
    private static native void _joinBank(long player, String bankName);
    public static void joinBank(obj_id player, String bankName)
    {
        _joinBank(getLongWithNull(player), bankName);
    }

    public static native boolean isCommoditiesServerAvailable();

    private static native void _createVendorMarket(long player, long container, int entranceCharge);
    public static void createVendorMarket(obj_id player, obj_id container, int entranceCharge)
    {
        _createVendorMarket(getLongWithNull(player), getLongWithNull(container), entranceCharge);
    }
    private static native void _updateVendorValue(long container);
    public static void updateVendorValue(obj_id container)
    {
        _updateVendorValue(getLongWithNull(container));
    }
    private static native void _setSalesTax(int salesTax, long bank, long container);
    public static void setSalesTax(int salesTax, obj_id bank, obj_id container)
    {
        _setSalesTax(salesTax, getLongWithNull(bank), getLongWithNull(container));
    }
    private static native void _requestVendorItemCount(long vendor);
    public static void requestVendorItemCount(obj_id vendor)
    {
        _requestVendorItemCount(getLongWithNull(vendor));
    }
    private static native void _requestPlayerVendorCount(long player);
    public static void requestPlayerVendorCount(obj_id player)
    {
        _requestPlayerVendorCount(getLongWithNull(player));
    }
    private static native void _updateVendorSearchOption(long vendor, boolean enable);
    public static void updateVendorSearchOption(obj_id vendor, boolean enable)
    {
        _updateVendorSearchOption(getLongWithNull(vendor), enable);
    }
    // returns -1 if the information is not available, most likely because it's not
    // a valid player character or the player character is no longer in the DB
    private static native int  _getPlayerLastLoginTime(long player);
    public static int  getPlayerLastLoginTime(obj_id player)
    {
        return _getPlayerLastLoginTime(getLongWithNull(player));
    }
    private static native void _setEntranceCharge(long vendor, int entranceCharge);
    public static void setEntranceCharge(obj_id vendor, int entranceCharge)
    {
        _setEntranceCharge(getLongWithNull(vendor), entranceCharge);
    }

    /**
    * MapLocationTypes
    */

    public static final int MLT_STATIC    = 0;            // static locations.  Things like buildings whos map locations are not persisted.  All static locations should be loaded from a load beacon
    public static final int MLT_DYNAMIC   = 1;            // dynamic locations.  Things like camps that are not persisted
    public static final int MLT_PERSIST   = 2;            // persistant locations.  Things like player vendors & houses
    public static final int MLT_NUM_TYPES = 3;

    public static final byte MLF_INACTIVE  = 0x01;
    public static final byte MLF_ACTIVE    = 0x02;

    /**
    * @param category must not be null
    * @param subCategory can be null
    * @param mapLoctionType one of MLT_STATIC, MLT_DYNAMIC, or MLT_PERSIST
    * @param flags bitwise combination of MLF_* flags.  Some, like MLF_INACTIVE and MLF_ACTIVE, are mutually exclusive
    */

    private static native boolean        _addPlanetaryMapLocation(long locationId, String locationName, int xLoc, int yLoc, String category, String subCategory, int mapLocationType, byte flags);
    public static boolean        addPlanetaryMapLocation    (obj_id locationId, String locationName, int xLoc, int yLoc, String category, String subCategory, int mapLocationType, byte flags)
    {
        return _addPlanetaryMapLocation(getLongWithNull(locationId), locationName, xLoc, yLoc, category, subCategory, mapLocationType, flags);
    }

    /**
    * Hack to make planetary map work again
    */

    public static boolean        addPlanetaryMapLocation    (obj_id locationId, String locationName, int xLoc, int yLoc, String category, String subCategory, int mapLocationType, int flags)
    {
        return addPlanetaryMapLocation (locationId, locationName, xLoc, yLoc, category, subCategory, mapLocationType, (byte)flags);
    }

	/**
	* @param category must not be null
	* @param subCategory can be null
	* @param mapLoctionType one of MLT_STATIC, MLT_DYNAMIC, or MLT_PERSIST
	* @param flags bitwise combination of MLF_* flags.  Some, like MLF_INACTIVE and MLF_ACTIVE, are mutually exclusive
	*/

	private static native boolean _addPlanetaryMapLocationIgnoreLocationCountLimits(long locationId, String locationName, int xLoc, int yLoc, String category, String subCategory, int mapLocationType, byte flags);
	public static boolean addPlanetaryMapLocationIgnoreLocationCountLimits(obj_id locationId, String locationName, int xLoc, int yLoc, String category, String subCategory, int mapLocationType, byte flags)
	{
		return _addPlanetaryMapLocationIgnoreLocationCountLimits(getLongWithNull(locationId), locationName, xLoc, yLoc, category, subCategory, mapLocationType, flags);
	}

	/**
	* Hack to make planetary map work again
	*/

	public static boolean addPlanetaryMapLocationIgnoreLocationCountLimits(obj_id locationId, String locationName, int xLoc, int yLoc, String category, String subCategory, int mapLocationType, int flags)
	{
		return addPlanetaryMapLocationIgnoreLocationCountLimits(locationId, locationName, xLoc, yLoc, category, subCategory, mapLocationType, (byte)flags);
	}

    /**
    * @return true if location was removed
    */

    private static native boolean        _removePlanetaryMapLocation(long locationId);
    public static boolean        removePlanetaryMapLocation (obj_id locationId)
    {
        return _removePlanetaryMapLocation(getLongWithNull(locationId));
    }

    /**
    * @param category can be null
    * @param subCategory can be null
    */

    public static native map_location[] getPlanetaryMapLocations   (String category, String subCategory);

    /**
    * @param category can be null if you want the root categories.  Non-null retrieves the subcategories for the specified category
    */
    public static native String[]       getPlanetaryMapCategories   (String category);

    /**
    *
    */
    private static native map_location   _getPlanetaryMapLocation(long locationId);
    public static map_location   getPlanetaryMapLocation     (obj_id locationId)
    {
        return _getPlanetaryMapLocation(getLongWithNull(locationId));
    }

    //

    private static native void _setAttributeAttained(long serverObjectId, int attribute);
    public static void setAttributeAttained(obj_id serverObjectId, int attribute)
    {
        _setAttributeAttained(getLongWithNull(serverObjectId), attribute);
    }
    private static native void _clearAttributeAttained(long serverObjectId, int attribute);
    public static void clearAttributeAttained(obj_id serverObjectId, int attribute)
    {
        _clearAttributeAttained(getLongWithNull(serverObjectId), attribute);
    }
    private static native boolean _hasAttributeAttained(long serverObjectId, int attribute);
    public static boolean hasAttributeAttained(obj_id serverObjectId, int attribute)
    {
        return _hasAttributeAttained(getLongWithNull(serverObjectId), attribute);
    }

    private static native void _setAttributeInterested(long serverObjectId, int attribute);
    public static void setAttributeInterested(obj_id serverObjectId, int attribute)
    {
        _setAttributeInterested(getLongWithNull(serverObjectId), attribute);
    }
    private static native void _clearAttributeInterested(long serverObjectId, int attribute);
    public static void clearAttributeInterested(obj_id serverObjectId, int attribute)
    {
        _clearAttributeInterested(getLongWithNull(serverObjectId), attribute);
    }
    private static native boolean _hasAttributeInterested(long serverObjectId, int attribute);
    public static boolean hasAttributeInterested(obj_id serverObjectId, int attribute)
    {
        return _hasAttributeInterested(getLongWithNull(serverObjectId), attribute);
    }

    private static native boolean _isInterested(long serverObjectId1, long serverObjectId2);
    public static boolean isInterested(obj_id serverObjectId1, obj_id serverObjectId2)
    {
        return _isInterested(getLongWithNull(serverObjectId1), getLongWithNull(serverObjectId2));
    }


    /*@}*/
/**
    * @defgroup regionMethods Methods for working with Suis
    * @{
*/

    public static class sui_event_type
    {
        private static int private_index = 0;
        public static int SET_none = private_index++;
        public static int SET_onButton = private_index++;
        public static int SET_onCheckbox = private_index++;
        public static int SET_onEnabledChanged = private_index++;
        public static int SET_onGenericSelection = private_index++;
        public static int SET_onSliderbar = private_index++;
        public static int SET_onTabbedPane = private_index++;
        public static int SET_onTextbox = private_index++;
        public static int SET_onVisibilityChanged = private_index++;
        public static int SET_onClosedOk = private_index++;
        public static int SET_onClosedCancel = private_index++;
        public static int SET_numEventTypes = private_index++;

        public static String names[] =
        {
            "none",
            "onButton",
            "onCheckbox",
            "onEnabledChanged",
            "onGenericSelection",
            "onSliderbar",
            "onTabbedPane",
            "onTextbox",
            "onVisibilityChanged",
            "onClosedOk",
            "onClosedCancel",
            "numEventTypes"
        };
    };

    /**
     * Create a SUI page.
     * @return a handle to the page for use in other Sui functions
     */
    private static native int       _createSUIPage(String pageName, long owner, long player);
    public static int       createSUIPage            (String pageName, obj_id owner, obj_id player)
    {
        return _createSUIPage(pageName, getLongWithNull(owner), getLongWithNull(player));
    }


    /**
     * Create a SUI page.
     * This method implicitly sets the callbacks for the events SET_onClosedOk, SET_onClosedCancel
     * @return a handle to the page for use in other SUI functions
     */
    public static int       createSUIPage            (String pageName, obj_id owner, obj_id player, String callbackFunction)
    {
        final int pid = createSUIPage(pageName, owner, player);
        if (pid < 0)
            return pid;

        subscribeToSUIEvent(pid, sui_event_type.SET_onClosedOk, null, callbackFunction);
        subscribeToSUIEvent(pid, sui_event_type.SET_onClosedCancel, null, callbackFunction);
        return pid;
    }

    /**
     * Clear the given datasource for the SUI page.  New values can then be set into the datasource with addSUIDataItem
     */
    public static native boolean   clearSUIDataSource       (int pageId, String dataSource);
    public static native boolean   clearSUIDataSourceContainer(int pageId, String dataSource);

    /**
     * Add an item to a datasource.  Datasources are used for things such as entries in list boxes, tab names, etc.
     */
    public static native boolean   addSUIDataItem           (int pageId, String dataSource, String dataItemValue);

    public static native boolean   addSUIDataSourceContainer(int pageId, String dataSourceContainerParent, String DataSourceContainerChild);

    public static native boolean   addSUIDataSource			(int pageId, String dataSourceParent, String DataSourceChild);
    /**
     * Add a child widget to the current SUI page.  This can  be used to add buttons, checkboxes, or other items to a generic page
     */
    public static native boolean   addSUIChildWidget        (int pageId, String widgetType, String widgetName, String partentWidgetName);

    /**
     * Set a property on the page.  This can be used to clear checkbox values, set colors/sizes on widgets, or almost any other visual element
     */
    public static native boolean   setSUIProperty           (int pageId, String widgetName, String propertyName, String propertyValue);

    /**
     * Set a property on the page using out-of-band data.  This can be used to clear checkbox values, set colors/sizes on widgets, or almost any other visual element
     */
    public static boolean   setSUIPropertyOOB        (int pageId, String widgetName, String propertyName, String oobPropertyValue)
    {
        return setSUIProperty (pageId, widgetName, propertyName, "\0" + oobPropertyValue);
    }

    /**
     * Subscribe to an event.  When the event occurs, the messagehandler will return a dictionary full of all the subscribed values.
     * This is useful for finding out when a button is pressed, etc...
     */
    public static native boolean   subscribeToSUIEvent   (int pageId, int eventType, String eventWidgetName, String callback);

    /**
     * Modify the callback for an event subscription.
     * This is useful for finding out when a button is pressed, etc...
     */
    public static boolean   modifySUIEventCallback   (int pageId, int eventType, String eventWidgetName, String callback)
    {
        return subscribeToSUIEvent(pageId, eventType, eventWidgetName, callback);
    }

    /**
     * Subscribe to a property.  When the event occurs, the messagehandler will return a dictionary full of all the subscribed values.
     * This is useful for finding out about radio/checkbox selecttions, text in text fields, etc.
     */
    public static native boolean   subscribeToSUIPropertyForEvent   (int pageId, int eventType, String eventWidgetName, String propertyWidgetName, String propertyName);

    /**
     * Subscribe to a property for the Ok/Cancel events.  When either event occurs, the messagehandler will return a dictionary full of all the subscribed values.
     * This is useful for finding out about radio/checkbox selecttions, text in text fields, etc.
     */
    public static boolean   subscribeToSUIProperty   (int pageId, String propertyWidgetName, String propertyName)
    {
        boolean result = true;

        result = subscribeToSUIPropertyForEvent   (pageId, sui_event_type.SET_onClosedOk, null, propertyWidgetName, propertyName) && result;
        result = subscribeToSUIPropertyForEvent   (pageId, sui_event_type.SET_onClosedCancel, null, propertyWidgetName, propertyName) && result;

        return result;
    }

    /**
     * Show a SUI page.  After creating and filling out the page, call this to commit the page and send it to the client.
     */
    public static native boolean   showSUIPage              (int pageId);

    /**
     * Flush changes to an active SUI page.  Call this after setting properties on an active page.
     */
    public static boolean   flushSUIPage              (int pageId)
    {
        return showSUIPage(pageId);
    }

    /**
     * Force a given SUI page to be closed.  This can be useful if the player takes too long, runs away from the place where the SUI is appropriate, etc.
     */
    public static native boolean   forceCloseSUIPage        (int pageId);

    private static native boolean   _setSUIAssociatedObject(int pageId, long obj);
    public static boolean   setSUIAssociatedObject   (int pageId, obj_id obj)
    {
        return _setSUIAssociatedObject(pageId, getLongWithNull(obj));
    }

    private static native boolean   _setSUIAssociatedLocation(int pageId, long obj);
    public static boolean   setSUIAssociatedLocation   (int pageId, obj_id obj)
    {
        return _setSUIAssociatedLocation(pageId, getLongWithNull(obj));
    }

    public static native boolean   setSUIMaxRangeToObject   (int pageId, float range);


    /**
     * Client-side UI minigames. Data dictionary is read by minigame for needed info.
     * Including a "table" oid will allow a result to be returned.
     */
    private static native boolean _clientMinigameOpen (long player, dictionary data);
    public static boolean clientMinigameOpen(obj_id player, dictionary data)
    {
    	return _clientMinigameOpen(getLongWithNull(player), data);
    }

    private static native boolean _clientMinigameClose (long player, dictionary data);
    public static boolean clientMinigameClose (obj_id player, dictionary data)
    {
		return _clientMinigameClose(getLongWithNull(player), data);
    }


    //-----------------------------------------------------------------------

    public static native void      createRectRegion(location lowerLeftLocation, location upperRightLocation, String name, int pvp, int buildable, int municipal, int geography, int minDifficulty, int maxDifficulty, int spawnable, int mission, boolean visible, boolean notify);
    public static native void      createCircleRegion(location center, float radius, String name, int pvp, int buildable, int municipal, int geography, int minDifficulty, int maxDifficulty, int spawnable, int mission, boolean visible, boolean notify);

    private static native long _createCircleRegionWithSpawn(location center, float radius, String name, int pvp, int buildable, int municipal, int geography, int minDifficulty, int maxDifficulty, int spawnable, int mission, boolean visible, boolean notify, String spawnTable, int duration);
    public static obj_id createCircleRegionWithSpawn(location center, float radius, String name, int pvp, int buildable, int municipal, int geography, int minDifficulty, int maxDifficulty, int spawnable, int mission, boolean visible, boolean notify, String spawnTable, int duration)
    {
		return getObjIdWithNull( _createCircleRegionWithSpawn(center, radius, name, pvp, buildable, municipal, geography, minDifficulty, maxDifficulty, spawnable, mission, visible, notify, spawnTable, duration));
    }


    public static native region[]  getRegionsAtPoint(location l);
    public static native region[]  getRegions(String planetName);
    public static native region[]  getRegionsWithPvP(String planetName, int value);
    public static native region[]  getRegionsWithBuildable(String planetName, int value);
    public static native region[]  getRegionsWithMunicipal(String planetName, int value);
    public static native region[]  getRegionsWithGeographical(String planetName, int value);
    public static native region[]  getRegionsWithDifficulty(String planetName, int value);
    public static native region[]  getRegionsWithSpawnable(String planetName, int value);
    public static native region[]  getRegionsWithMission(String planetName, int value);
    public static native region[]  getRegionsWithPvPAtPoint(location loc, int value);
    public static native region[]  getRegionsWithBuildableAtPoint(location loc, int value);
    public static native region[]  getRegionsWithMunicipalAtPoint(location loc, int value);
    public static native region[]  getRegionsWithGeographicalAtPoint(location loc, int value);
    public static native region[]  getRegionsWithDifficultyAtPoint(location loc, int value);
    public static native region[]  getRegionsWithSpawnableAtPoint(location loc, int value);
    public static native region[]  getRegionsWithMissionAtPoint(location loc, int value);
    public static native region    getSmallestRegionAtPoint(location l);
    public static native region    getSmallestVisibleRegionAtPoint(location l);
    public static native boolean   deleteRegion(region r);
    public static native boolean   wipeRegionsFromPlanet(String planetName);
    public static native location  findPointInRegion(region r);
    public static native region    getRegion(String planetName, String regionName);
    public static native boolean   isNotifyRegion(region r);

    /**
     * Get information on a 3d region given its name
     *
     * @param regionName the name of the 3d region
     * @return a dictionary consisting of all the entries of the corresponding row of the table the 3d region was created from.
     */
    public static native dictionary get3dRegionByName(String regionName);
    /**
     * Get information on the smallest 3d region at a given point
     *
     * @param loc the point to search for regions
     * @return a dictionary consisting of all the entries of the corresponding row of the table the 3d region was created from.
     */
    public static native dictionary getSmallest3dRegionAtPoint(location loc);
    /**
     * Get information on all 3d regions at a given point
     *
     * @param loc the point to search for regions
     * @return an array of dictionaries, one per region, from smallest to largest at the specified location, with each consisting of all the entries of the corresponding row of the table the 3d region was created from.
     */
    public static native dictionary[] get3dRegionsAtPoint(location loc);
    /**
     * create a nonpersisted sphere region
     *
     * @param regionName  name of the new region
     * @param center  center of the new region sphere
     * @param radius  radius of the new region sphere
     * @param regionDictionary  dictionary of any additional information associated with the region
     */
    public static native void createSphereRegion(String regionName, vector center, float radius, dictionary regionDictionary);
    /**
     * create a nonpersisted axially aligned box region
     *
     * @param regionName  name of the new region
     * @param extentMin  minimum x,y,z corner of the new region aabox
     * @param extentMax  maximum x,y,z corner of the new region aabox
     * @param regionDictionary  dictionary of any additional information associated with the region
     */
    public static native void createBoxRegion(String regionName, vector extentMin, vector extentMax, dictionary regionDictionary);
    /**
     * destroy a 3d region
     *
     * @param regionName  the name of the 3d region to destroy
     */
    public static native void destroy3dRegion(String regionName);

    /**
     * Play a client event. The event will be seen by all the clients around the main client (which may not be the
     * object the event is happening to).
     */
    public static boolean   playClientEventObj(obj_id client, String eventType, obj_id objectReceivingEvent, String hardpoint)
    {
        return playClientEventObj(client, eventType, objectReceivingEvent, hardpoint, null);
    }
    /**
     * Play a client event. The event will only be seen by the clients passed to the function.
     */
    public static boolean playClientEventObj(obj_id[] clients, String eventType, obj_id objectReceivingEvent, String hardpoint)
    {
        return playClientEventObj(clients, eventType, objectReceivingEvent, hardpoint, null);
    }
    private static native boolean   _playClientEventObj(long client, String eventType, long objectReceivingEvent, String hardpoint, transform offset);
    public static boolean   playClientEventObj(obj_id client, String eventType, obj_id objectReceivingEvent, String hardpoint, transform offset)
    {
        return _playClientEventObj(getLongWithNull(client), eventType, getLongWithNull(objectReceivingEvent), hardpoint, offset);
    }
    private static native boolean _playClientEventObj(long[] clients, String eventType, long objectReceivingEvent, String hardpoint, transform offset);
    public static boolean playClientEventObj(obj_id[] clients, String eventType, obj_id objectReceivingEvent, String hardpoint, transform offset)
    {
        long[] _clients = null;
        if (clients != null)
        {
            _clients = new long[clients.length];
            for (int _i = 0; _i < clients.length; ++_i)
                _clients[_i] = getLongWithNull(clients[_i]);
        }
        return _playClientEventObj(_clients, eventType, getLongWithNull(objectReceivingEvent), hardpoint, offset);
    }
    private static native boolean   _playClientEventLoc(long client, String eventSourceType, String eventDestType, location loc, float terrainDelta);
    public static boolean   playClientEventLoc(obj_id client, String eventSourceType, String eventDestType, location loc, float terrainDelta)
    {
        return _playClientEventLoc(getLongWithNull(client), eventSourceType, eventDestType, loc, terrainDelta);
    }
    private static native boolean _playClientEventLoc(long[] clients, String eventSourceType, String eventDestType, location loc, float terrainDelta);
    public static boolean playClientEventLoc(obj_id[] clients, String eventSourceType, String eventDestType, location loc, float terrainDelta)
    {
        long[] _clients = null;
        if (clients != null)
        {
            _clients = new long[clients.length];
            for (int _i = 0; _i < clients.length; ++_i)
                _clients[_i] = getLongWithNull(clients[_i]);
        }
        return _playClientEventLoc(_clients, eventSourceType, eventDestType, loc, terrainDelta);
    }

    /**
     * Play a client effect. The effect will be seen by all the clients around the main client (which may not be the
     * object the effect is happening to).
     */
    public static boolean   playClientEffectObj(obj_id client, String effectName, obj_id objectReceivingEffect, String hardpoint)
    {
        return playClientEffectObj(client, effectName, objectReceivingEffect, hardpoint, null, null);
    }
    /**
     * Play a client effect. The effect will only be seen by the clients passed to the function.
     */
    public static boolean playClientEffectObj(obj_id[] clients, String effectName, obj_id objectReceivingEffect, String hardpoint)
    {
        return playClientEffectObj(clients, effectName, objectReceivingEffect, hardpoint, null, null);
    }

    public static boolean playClientEffectObj(obj_id client, String effectName, obj_id objectReceivingEffect, String hardpoint, transform offset)
    {
        return playClientEffectObj(client, effectName, objectReceivingEffect, hardpoint, offset, null);
    }
    public static boolean playClientEffectObj(obj_id[] clients, String effectName, obj_id objectReceivingEffect, String hardpoint, transform offset)
    {
        return playClientEffectObj(clients, effectName, objectReceivingEffect, hardpoint, offset, null);
    }
    public static boolean playClientEffectLoc(obj_id client, String effectName, location loc, float terrainDelta)
    {
        return playClientEffectLoc(client, effectName, loc, terrainDelta, null);
    }
    public static boolean playClientEffectLoc(obj_id[] clients, String effectName, location loc, float terrainDelta)
    {
        return playClientEffectLoc(clients, effectName, loc, terrainDelta, null);
    }

    private static native boolean _playClientEffectObj(long client, String effectName, long objectReceivingEffect, String hardpoint, transform offset, String label);
    public static boolean playClientEffectObj(obj_id client, String effectName, obj_id objectReceivingEffect, String hardpoint, transform offset, String label)
    {
        return _playClientEffectObj(getLongWithNull(client), effectName, getLongWithNull(objectReceivingEffect), hardpoint, offset, label);
    }
    private static native boolean _playClientEffectObj(long[] clients, String effectName, long objectReceivingEffect, String hardpoint, transform offset, String label);
    public static boolean playClientEffectObj(obj_id[] clients, String effectName, obj_id objectReceivingEffect, String hardpoint, transform offset, String label)
    {
        long[] _clients = null;
        if (clients != null)
        {
            _clients = new long[clients.length];
            for (int _i = 0; _i < clients.length; ++_i)
                _clients[_i] = getLongWithNull(clients[_i]);
        }
        return _playClientEffectObj(_clients, effectName, getLongWithNull(objectReceivingEffect), hardpoint, offset, label);
    }
    private static native boolean _playClientEffectLoc(long client, String effectName, location loc, float terrainDelta, String label);
    public static boolean playClientEffectLoc(obj_id client, String effectName, location loc, float terrainDelta, String label)
    {
        return _playClientEffectLoc(getLongWithNull(client), effectName, loc, terrainDelta, label);
    }
    private static native boolean _playClientEffectLoc(long[] clients, String effectName, location loc, float terrainDelta, String label);
    public static boolean playClientEffectLoc(obj_id[] clients, String effectName, location loc, float terrainDelta, String label)
    {
        long[] _clients = null;
        if (clients != null)
        {
            _clients = new long[clients.length];
            for (int _i = 0; _i < clients.length; ++_i)
                _clients[_i] = getLongWithNull(clients[_i]);
        }
        return _playClientEffectLoc(_clients, effectName, loc, terrainDelta, label);
    }

    public static boolean stopClientEffectObjByLabel(obj_id objectPlayingEffect, String label)
    {
        return stopClientEffectObjByLabel(objectPlayingEffect, objectPlayingEffect, label);
    }

	public static boolean stopClientEffectObjByLabel(obj_id client, obj_id objectPlayingEffect, String label)
	{
		return stopClientEffectObjByLabel(client, objectPlayingEffect, label, true);
	}

	public static boolean stopClientEffectObjByLabel(obj_id[] clients, obj_id objectPlayingEffect, String label)
	{
		return stopClientEffectObjByLabel(clients, objectPlayingEffect, label, true);
	}

    private static native boolean _stopClientEffectObjByLabel(long client, long objectPlayingEffect, String label, boolean softTerminate);
    public static boolean stopClientEffectObjByLabel(obj_id client, obj_id objectPlayingEffect, String label, boolean softTerminate)
    {
        return _stopClientEffectObjByLabel(getLongWithNull(client), getLongWithNull(objectPlayingEffect), label, softTerminate);
    }
    private static native boolean _stopClientEffectObjByLabel(long[] clients, long objectPlayingEffect, String label, boolean softTerminate);
    public static boolean stopClientEffectObjByLabel(obj_id[] clients, obj_id objectPlayingEffect, String label, boolean softTerminate)
    {
        long[] _clients = null;
        if (clients != null)
        {
            _clients = new long[clients.length];
            for (int _i = 0; _i < clients.length; ++_i)
                _clients[_i] = getLongWithNull(clients[_i]);
        }
        return _stopClientEffectObjByLabel(_clients, getLongWithNull(objectPlayingEffect), label, softTerminate);
    }

    private static native boolean _playUiEffect(long client, String effectString);
    public static boolean playUiEffect(obj_id client, String effectString)
    {
        return _playUiEffect(getLongWithNull(client), effectString);
    }

    /**
     * Create a client side projectile that travels from start toward end.
     *
     * @param client                    all clients observing this client will see the projectile
     * @param weaponObjectTemplateName  the name of the weapon object template to use as the projectile
     * @param start                     starting location
     * @param end                       ending location used to determine the direction the projectile travels
     * @param speed                     how fast the projectile moves
     * @param expiration                how long the projectile lasts
     * @param trail                     whether or not the projectile has a trail
     * @param r                         the red value of the trail
     * @param g                         the green value of the trail
     * @param b                         the blue value of the trail
     * @param a                         the alpha value of the trail
     * @return true if the client exists and all parameters convert correctly
     */

    private static native boolean _createClientProjectile(long client, String weaponObjectTemplateName, location start, location end,
        float speed, float expiration, boolean trail, int r, int g, int b, int a);
    public static boolean createClientProjectile(obj_id client, String weaponObjectTemplateName, location start, location end,
        float speed, float expiration, boolean trail, int r, int g, int b, int a)
    {
        return _createClientProjectile(getLongWithNull(client), weaponObjectTemplateName, start, end, speed, expiration, trail, r, g, b, a);
    }

    /**
     * Create a client side projectile that travels from object toward object.
     *
     * @param client                    all clients observing this client will see the projectile
     * @param weaponObjectTemplateName  the name of the weapon object template to use as the projectile
     * @param source                    source object
     * @param sourceHardpoint           Optional starting hardpoint for the projectile
     * @param target                    target object
     * @param targetHardpoint           Optional target hardpoint for the projectile
     * @param speed                     how fast the projectile moves
     * @param expiration                how long the projectile lasts
     * @param trail                     whether or not the projectile has a trail
     * @param r                         the red value of the trail
     * @param g                         the green value of the trail
     * @param b                         the blue value of the trail
     * @param a                         the alpha value of the trail
     * @return true if the client exists and all parameters convert correctly
     */

    private static native boolean _createClientProjectileObjectToObject(long client, String weaponObjectTemplateName, long source, String sourceHardpoint, long target,
       String targetHardpoint, float speed, float expiration, boolean trail, int r, int g, int b, int a);

    public static boolean createClientProjectileObjectToObject(obj_id client, String weaponObjectTemplateName, obj_id source, String sourceHardpoint, obj_id target,
       String targetHardpoint, float speed, float expiration, boolean trail, int r, int g, int b, int a)
    {
       return _createClientProjectileObjectToObject(getLongWithNull(client), weaponObjectTemplateName, getLongWithNull(source), sourceHardpoint, getLongWithNull(target), targetHardpoint, speed, expiration, trail, r, g, b, a);
    }

    /**
     * Create a client side projectile that travels from location to object.
     *
     * @param client                    all clients observing this client will see the projectile
     * @param weaponObjectTemplateName  the name of the weapon object template to use as the projectile
     * @param source                    source location
     * @param target                    target object
     * @param targetHardpoint           Optional target hardpoint for the projectile
     * @param speed                     how fast the projectile moves
     * @param expiration                how long the projectile lasts
     * @param trail                     whether or not the projectile has a trail
     * @param r                         the red value of the trail
     * @param g                         the green value of the trail
     * @param b                         the blue value of the trail
     * @param a                         the alpha value of the trail
     * @return true if the client exists and all parameters convert correctly
     */

    private static native boolean _createClientProjectileLocationToObject(long client, String weaponObjectTemplateName, location source, long target, String targetHardpoint,
       float speed, float expiration, boolean trail, int r, int g, int b, int a);
    public static boolean createClientProjectileLocationToObject(obj_id client, String weaponObjectTemplateName, location source, obj_id target, String targetHardpoint,
       float speed, float expiration, boolean trail, int r, int g, int b, int a)
    {
       return _createClientProjectileLocationToObject(getLongWithNull(client), weaponObjectTemplateName, source, getLongWithNull(target), targetHardpoint, speed, expiration, trail, r, g, b, a);
    }

    /**
     * Create a client side projectile that travels from object toward location.
     *
     * @param client                    all clients observing this client will see the projectile
     * @param weaponObjectTemplateName  the name of the weapon object template to use as the projectile
     * @param source                    source object
     * @param sourceHardpoint           Optional starting hardpoint for the projectile
     * @param target                    target location
     * @param speed                     how fast the projectile moves
     * @param expiration                how long the projectile lasts
     * @param trail                     whether or not the projectile has a trail
     * @param r                         the red value of the trail
     * @param g                         the green value of the trail
     * @param b                         the blue value of the trail
     * @param a                         the alpha value of the trail
     * @return true if the client exists and all parameters convert correctly
     */

    private static native boolean _createClientProjectileObjectToLocation(long client, String weaponObjectTemplateName, long source, String sourceHardpoint, location target, float speed,
       float expiration, boolean trail, int r, int g, int b, int a);
    public static boolean createClientProjectileObjectToLocation(obj_id client, String weaponObjectTemplateName, obj_id source, String sourceHardpoint, location target, float speed,
       float expiration, boolean trail, int r, int g, int b, int a)
    {
    	return _createClientProjectileObjectToLocation(getLongWithNull(client), weaponObjectTemplateName, getLongWithNull(source), sourceHardpoint, target, speed, expiration, trail, r, g, b, a);
    }
    /**
     * Play music for a specified player
     *
     * @param player     the person to hear the music
     * @param musicName  the music to play
     * @return whether player existed
     */
    private static native boolean _play2dNonLoopingMusic(long player, String soundTemplateName);
    public static boolean play2dNonLoopingMusic(obj_id player, String soundTemplateName)
    {
        return _play2dNonLoopingMusic(getLongWithNull(player), soundTemplateName);
    }

    /**
     * Play sound for a specified player
     *
     * @param player     the person to hear the sound
     * @param soundTemplateName  the sound to play
     * @return whether player existed
     */
    private static native boolean _play2dNonLoopingSound(long player, String soundTemplateName);
    public static boolean play2dNonLoopingSound(obj_id player, String soundTemplateName)
    {
        return _play2dNonLoopingSound(getLongWithNull(player), soundTemplateName);
    }

    /**
     * Play sound for a specified player (deprecated [overused] script hook)
     *
     * @param player     the person to hear the sound
     * @param soundTemplateName  the sound to play
     * @return whether player existed
     */
    public static boolean playMusic(obj_id player, String soundTemplateName)
    {
        return play2dNonLoopingSound(player, soundTemplateName);
    }

    public static native void _playCutScene(long player, String cutSceneName);
    public static void playCutScene(obj_id player, String cutSceneName)
    {
        _playCutScene(getLongWithNull(player), cutSceneName);
    }


    /**
     * Play music for a specified player
     *
     * @param listener      the person to hear the music
     * @param sourcePlayer  the person playing the music
     * @param musicName     the music to play
     * @param playType      category of the type of music
     * @param loop          whether to loop the music
     * @return true on success, false on failure
     */
    private static native boolean   _playMusic(long listener, long player, String musicName, int playType, boolean loop);
    public static boolean   playMusic(obj_id listener, obj_id player, String musicName, int playType, boolean loop)
    {
        return _playMusic(getLongWithNull(listener), getLongWithNull(player), musicName, playType, loop);
    }

    /**
     * Get the extents of the given region
     *
     * @param r the region to find the extent of
     * @return NULL for an invalid region, or an object array of locations where the lower left corner is location[0] and the upper right corner is location[1]
     */
    public static native location[] getRegionExtent(region r);

    /**
     * Get the terrain height at the given x-z location on the current planet
     *
     * @param x the x location on the planet
     * @param z the z location on the planet
     * @return the terrain height at that location
     */
    public static native float getHeightAtLocation(float x, float z);

    /**
     * Get the cover value at the given x-z location on the current planet
     *
     * @param x the x location on the planet
     * @param z the z location on the planet
     * @return the cover value at that location
     */
    public static native float getCoverAtLocation(float x, float z);

    /**
     * Get a location that isn't in water, and isn't too steep
     *
     * @param hintX the x size of the good location needed
     * @param hintZ the z size of the good location needed
     * @param searchRectLL the lower left point of the large rectangle
     * @param searchRectUR the upper right point of the large rectangle
     * @param dontCheckWater ignore water when finding a good location, only validate slope
     * @param dontCheckSlope ignore slope when finding a good location, only validate water
     */
    public static native location getGoodLocation(float hintX, float hintZ, location searchRectLL, location searchRectUR, boolean dontCheckWater, boolean dontCheckSlope);

    /**
     * Get a location that isn't in water, and isn't too steep, and avoids static collidable objects
     *
     * @param hintX the x size of the good location needed
     * @param hintZ the z size of the good location needed
     * @param searchRectLL the lower left point of the large rectangle
     * @param searchRectUR the upper right point of the large rectangle
     * @param dontCheckWater ignore water when finding a good location, only validate slope
     * @param dontCheckSlope ignore slope when finding a good location, only validate water
     * @param staticObjDistance a good location must be atleast this far from any static collidable objects.
     */
    public static native location getGoodLocationAvoidCollidables(float hintX, float hintZ, location searchRectLL, location searchRectUR, boolean dontCheckWater, boolean dontCheckSlope, float staticObjDistance);

    /**
     *  Put the client into structure placement mode
     *
     * @param player object id of the player
     * @param deed object id of the deed
     * @param serverObjectTemplateName object template name of the building to place
     */
    private static native boolean _enterClientStructurePlacementMode(long player, long deed, String serverObjectTemplateName);
    public static boolean enterClientStructurePlacementMode(obj_id player, obj_id deed, String serverObjectTemplateName)
    {
        return _enterClientStructurePlacementMode(getLongWithNull(player), getLongWithNull(deed), serverObjectTemplateName);
    }

    /**
     *  Query the lot system to see if the building can be placed
     *
     * @param serverObjectTemplateName object template name of the building to place
     * @param position the world space position to verify (passed from trigger)
     * @param rotation the rotation of the building (passed from trigger)
     * @return -1 if unsucessful, value >= 0 which indicates the height at which you must raise the structure above the terrain
     */
    public static native float canPlaceStructure(String serverObjectTemplateName, location position, int rotation);

    /**
     *  Query the lot system to see if the building can be placed
     *
     * @param serverObjectTemplateName object template name of the building to place
     * @param position the world space position to verify (passed from trigger)
     * @param rotation the rotation of the building (passed from trigger)
     * @return the object id of the temporary building object
     */
    private static native long _createTemporaryStructure(String serverObjectTemplateName, location position, int rotation);
    public static obj_id createTemporaryStructure(String serverObjectTemplateName, location position, int rotation)
    {
        return getObjIdWithNull(_createTemporaryStructure(serverObjectTemplateName, position, rotation));
    }

    /**
     *  Query the structure footprint to find its cost
     *
     * @param serverObjectTemplateName object template name of the building to place
     * @return the number of structure footprint lots
     */
    public static native int getNumberOfLots(String serverObjectTemplateName);

    /**
     *  Query the local terrain time
     *
     * @return time from 0..1 (time < dayLength is day, time >= dayLength is night)
     */
    public static native float getLocalTime();

    /**
     *  Query the local terrain day length
     *
     * @return the day/night split from 0..1 (ie. 0.5 is the split between day/night)
     */
    public static native float getLocalDayLength();

    /**
     *  Set the state of the weather
     *
     * @param weatherIndex 0=clear, 1=mild, 2=heavy, 3=severe
     * @param weatherWindVelocityX x and z combine to produce the direction and speed of the wind in m/s
     * @param weatherWindVelocityZ x and z combine to produce the direction and speed of the wind in m/s
     * @return true if successful
     */
    public static native boolean setWeatherData (int weatherIndex, float weatherWindVelocityX, float weatherWindVelocityZ);

    /**
     *  Create a /find client path
     *
     * @param player object id of the player
     * @param start starting position of client path
     * @param end ending position of client path
     * @return true for success, false for failure
     */
    private static native boolean _createClientPath(long player, location start, location end);
    public static boolean createClientPath(obj_id player, location start, location end)
    {
        return _createClientPath(getLongWithNull(player), start, end);
    }

    /**
     *  Create an advanced client path.
     *
     * @param player object id of the player
     * @param start starting position of client path
     * @param end ending position of client path
     * @param appearance entry in the shared client_path_appearances table.
     * @return true for success, false for failure
     */
    private static native boolean _createClientPathAdvanced(long player, location start, location end, String appearance);
    public static boolean createClientPathAdvanced(obj_id player, location start, location end, String appearance)
    {
        return _createClientPathAdvanced(getLongWithNull(player), start, end, appearance);
    }


    /**
     *  Destroy the /find client path or an advanced path.
     *
     * @param player object id of the player
     * @return true for success, false for failure
     */
    private static native boolean _destroyClientPath(long player);
    public static boolean destroyClientPath(obj_id player)
    {
        return _destroyClientPath(getLongWithNull(player));
    }

    /**
     *  Add a travel point to the specified planet.  Travel points are used for the departure and arrival locations for tickets.
     *
     * @param planet the planet to add the travel point
     * @param name the name of the travel point
     * @param location the location to bind the travel point to
     * @return true of successful
     */

    // *****WARNING*****
    // this must be kept in sync with TravelPoint::TravelPointType in C++
    // *****WARNING*****
    public static final int TPT_Unknown              = 0x00000000;
    public static final int TPT_NPC_Starport         = 0x00000001;
    public static final int TPT_NPC_Shuttleport      = 0x00000002;
    public static final int TPT_NPC_StaticBaseBeacon = 0x00000004;
    public static final int TPT_PC_Shuttleport       = 0x00000008;
    public static final int TPT_PC_CampShuttleBeacon = 0x00000010;

    public static native boolean addPlanetTravelPoint (String planetName, String travelPointName, location location, int cost, boolean interplanetary, int type);

    /**
     *  Remove a travel point to the specified planet.
     *
     * @param planet the planet to remove the travel point
     * @param name the name of the travel point
     * @return true of successful
     */
    public static native boolean removePlanetTravelPoint (String planetName, String travelPointName);

    /**
     *  Get a list of all travel points for a planet
     *
     * @param planet the planet to get the travel points from
     * @return string array of travel points
     */
    public static native String[] getPlanetTravelPoints (String planetName);

    /**
     *  Get the GCW contested region that the travel point is in, if any
     *
     * @param planet the planet
     * @param name the name of the travel point
     * @return the GCW contested region that the travel point is in, if any
     */
    public static native String getPlanetTravelPointGcwContestedRegion (String planetName, String travelPointName);

    /**
     *  Get location of a travel point
     *
     * @param planet the planet
     * @param name the name of the travel point
     * @return obj_id of the travel point, NULL if invalid
     */
    public static native location getPlanetTravelPointLocation (String planetName, String travelPointName);

    /**
     *  Get of cost of a travel point
     *
     * @param planet the planet
     * @param name the name of the travel point
     * @return int the cost, 0 of unsuccessful
     */
    public static native int getPlanetTravelPointCost (String planetName, String travelPointName);

    /**
     *  Get of cost of a travel point
     *
     * @param planet the planet
     * @param name the name of the travel point
     * @return int the cost, 0 of unsuccessful
     */
    public static native boolean getPlanetTravelPointInterplanetary (String planetName, String travelPointName);

    /**
     *  Get of cost of a traveling between planets
     *
     * @param planet1 the departure planet
     * @param planet2 the arrival planet
     * @return int the cost, 0 of unsuccessful
     */
    public static native int getPlanetTravelCost (String planetName1, String planetName2);

    /**
     *  Put the client into ticket purchase mode
     *
     * @param player the client network id
     * @param startingPlanet the departure planet
     * @param startingTravelPointName the departure travel point name
     * @param instantTravel whether or not the purchase mode was initiated by an instant travel request
     * @return true if successful
     */
    private static native boolean _enterClientTicketPurchaseMode(long player, String startingPlanetName, String startingTravelPointName, boolean instantTravel);
    public static boolean enterClientTicketPurchaseMode (obj_id player, String startingPlanetName, String startingTravelPointName, boolean instantTravel)
    {
        return _enterClientTicketPurchaseMode(getLongWithNull(player), startingPlanetName, startingTravelPointName, instantTravel);
    }

    /**
     * Check whether an area has too many players for travel
     *
     * @param planet the planet (or space scene)
     * @param x the x-coordinate of the area
     * @param z the z-coordinate of the area
     * @return true if the area has too many players
     */
    public static native boolean isAreaTooFullForTravel (String planetName, int x, int z);

    /**
     * Send a request to the planet server for both object1 and object2 to be moved to the same game server.
     *   The planet server will try to move one of the objects to the server the other object is on.
     *   This operation may not be successful. Which object to move is determined by the planet server.
     *
     * @param object1 object id of the first object
     * @param object2 object id of the second object
     */
    private static native void _requestSameServer(long object1, long object2);
    public static void requestSameServer(obj_id object1, obj_id object2)
    {
        _requestSameServer(getLongWithNull(object1), getLongWithNull(object2));
    }

    /**
     *  Ask the client to trigger a newbie tutorial response
     *
     * @param player the client network id
     * @param request the response requested
     * @return true if successful
     */
    private static native boolean _newbieTutorialRequest(long player, String request);
    public static boolean newbieTutorialRequest (obj_id player, String request)
    {
        return _newbieTutorialRequest(getLongWithNull(player), request);
    }

    /**
     *  Ask the client to enable/disable a hud element
     *
     * @param player the client network id
     * @param name the name of the hud element to enable/disable
     * @param enable true for enable, false for disable
     * @param blinkTime amount of time in seconds to blink the hud element
     * @return true if successful
     */
    private static native boolean _newbieTutorialEnableHudElement(long player, String name, boolean enable, float blinkTime);
    public static boolean newbieTutorialEnableHudElement (obj_id player, String name, boolean enable, float blinkTime)
    {
        return _newbieTutorialEnableHudElement(getLongWithNull(player), name, enable, blinkTime);
    }

    /**
     *  Ask the client to enable/disable an interface element
     *
     * @param player the client network id
     * @param name the name of the interface element to enable/disable
     * @param enable true for enable, false for disable
     * @return true if successful
     */
    private static native boolean _newbieTutorialEnableInterfaceElement(long player, String name, boolean enable);
    public static boolean newbieTutorialEnableInterfaceElement (obj_id player, String name, boolean enable)
    {
        return _newbieTutorialEnableInterfaceElement(getLongWithNull(player), name, enable);
    }

    /**
     *  Ask the client to change a toolbar slot
     *
     */
    private static native boolean _newbieTutorialSetToolbarElement(long player, int slot, String commandName);
    public static boolean newbieTutorialSetToolbarElement (obj_id player, int slot, String commandName)
    {
        return _newbieTutorialSetToolbarElement((player == null) ? 0 : player.getValue(), slot, commandName);
    }
    private static native boolean _newbieTutorialSetToolbarElement(long player, int slot, long obj);
    public static boolean newbieTutorialSetToolbarElement (obj_id player, int slot, obj_id obj)
    {
        return _newbieTutorialSetToolbarElement((player == null) ? 0 : player.getValue(), slot, (obj == null) ? 0 : obj.getValue());
    }

    /**
     *  Ask the client to higlight a UI element
     *
     */
    private static native boolean _newbieTutorialHighlightUIElement(long player, String widgetPath, float time);
    public static boolean newbieTutorialHighlightUIElement (obj_id player, String widgetPath, float time)
    {
        return _newbieTutorialHighlightUIElement((player == null) ? 0 : player.getValue(), widgetPath, time);
    }
    public static boolean newbieTutorialHighlightUIElement (obj_id player, String widgetPath, boolean enable)
    {
        return _newbieTutorialHighlightUIElement((player == null) ? 0 : player.getValue(), widgetPath, enable ? 0.0f : -1.0f);
    }
    /**
    * Send the starting locations and their available states to the player
    * @param locations null to send all the locations in the datatable.  A valid array of location names otherwise.  You should usually use null.
    * @param player  the player to send the locations to
    */

    private static native void     _newbieTutorialSendStartingLocationsToPlayer(long player, String [] locations);
    public static void     newbieTutorialSendStartingLocationsToPlayer (obj_id player, String [] locations)
    {
        _newbieTutorialSendStartingLocationsToPlayer(getLongWithNull(player), locations);
    }

    /**
    * Tell the player if their selection was valid or not
    */

    private static native void     _newbieTutorialSendStartingLocationSelectionResult(long player, String name, boolean result);
    public static void     newbieTutorialSendStartingLocationSelectionResult (obj_id player, String name, boolean result)
    {
        _newbieTutorialSendStartingLocationSelectionResult(getLongWithNull(player), name, result);
    }

    /**
    * Get the array of starting location names
    */

    public static native String[] getStartingLocations                        ();

    /**
    * Find out if a starting location is available
    */

    public static native boolean  isStartingLocationAvailable   (String name);

    /**
    * @return null if name is invalid
    */

    public static native location getStartingLocationInfo       (String name);

    /*@}*/
/**
    * @defgroup dataTable Methods for working with custom data tables
    * @{
    */
    /**
     * Get an integer value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the row to get the value from (use 0 for the first row).
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static native int dataTableGetInt(String table, int row, String column);
    /**
     * Get an integer value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the row to get the value from (use 0 for the first row).
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static native int dataTableGetInt(String table, int row, int column);
    /**
     * Get an integer value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the string value in column 0 of the row to get the value from
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static int dataTableGetInt(String table, String row, String column)
    {
        int rowNum = dataTableSearchColumnForString(row, 0, table);
        if ( rowNum == -1 )
            return -1;
        return dataTableGetInt(table, rowNum, column);
    }
    /**
     * Get an integer value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the string value in column 0 of the row to get the value from
     * @param  column the number of the column to get the value from (use 0 for the 1st column)
     * @return the value in the cell
     */
    public static int dataTableGetInt(String table, String row, int column)
    {
        int rowNum = dataTableSearchColumnForString(row, 0, table);
        if ( rowNum == -1 )
            return -1;
        return dataTableGetInt( table, rowNum, column);
    }
    /**
     * Get an float value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the row to get the value from (use 0 for the first row).
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static native float  dataTableGetFloat(String table, int row, String column);
    /**
     * Get an float value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the row to get the value from (use 0 for the first row).
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static native float  dataTableGetFloat(String table, int row, int column);
    /**
     * Get a Float value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the string value in column 0 of the row to get the value from
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static float dataTableGetFloat(String table, String row, String column)
    {
        int rowNum = dataTableSearchColumnForString(row, 0, table);
        if ( rowNum == -1 )
            return -1;
        return dataTableGetFloat(table, rowNum, column);
    }
    /**
     * Get a Float value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the string value in column 0 of the row to get the value from
     * @param  column the number of the column to get the value from (use 0 for the 1st column)
     * @return the value in the cell
     */
    public static float dataTableGetFloat(String table, String row, int column)
    {
        int rowNum = dataTableSearchColumnForString(row, 0, table);
        if ( rowNum == -1 )
            return -1;
        return dataTableGetFloat( table, rowNum, column);
    }
    /**
     * Get an string value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the row to get the value from (use 0 for the first row).
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static native String dataTableGetString(String table, int row, String column);
    /**
     * Get an string value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the row to get the value from (use 0 for the first row).
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static native String dataTableGetString(String table, int row, int column);
    /**
     * Get a String value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the string value in column 0 of the row to get the value from
     * @param  column the name of the column to get the value from
     * @return the value in the cell
     */
    public static String dataTableGetString(String table, String row, String column)
    {
        int rowNum = dataTableSearchColumnForString(row, 0, table);
        if ( rowNum == -1 )
            return null;
        return dataTableGetString(table, rowNum, column);
    }
    /**
     * Get a String value from a cell in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the string value in column 0 of the row to get the value from
     * @param  column the number of the column to get the value from (use 0 for the 1st column)
     * @return the value in the cell
     */
    public static String dataTableGetString(String table, String row, int column)
    {
        int rowNum = dataTableSearchColumnForString(row, 0, table);
        if ( rowNum == -1 )
            return null;
        return dataTableGetString(table, rowNum, column);
    }
    /**
     * Get an integer array from a column in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  column the name of the column to get the value from
     * @return the column
     */
    public static native int[] dataTableGetIntColumn(String table, String column);
    public static native int[] dataTableGetIntColumnNoDefaults(String table, String column);
    /**
     * Get a float array from a column in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  column the name of the column to get the value from
     * @return the column
     */
    public static native float[] dataTableGetFloatColumn(String table, String column);
    public static native float[] dataTableGetFloatColumnNoDefaults(String table, String column);
    /**
     * Get a string array from a column in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  column the name of the column to get the value from
     * @return the column
     */
    public static native String[] dataTableGetStringColumn(String table, String column);
    public static native String[] dataTableGetStringColumnNoDefaults(String table, String column);
    /**
     * Get a int array from a column in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  column the name of the column to get the value from
     * @return the column
     */
    public static native int[] dataTableGetIntColumn(String table, int column);
    public static native int[] dataTableGetIntColumnNoDefaults(String table, int column);
    /**
         * Get a float array from a column in a data table compiled with the DataTableTool
         *
         * @param  table the name of the data table
         * @param  column the name of the column to get the value from
         * @return the column
     */
    public static native float[] dataTableGetFloatColumn(String table, int column);
    public static native float[] dataTableGetFloatColumnNoDefaults(String table, int column);
    /**
         * Get a string array from a column in a data table compiled with the DataTableTool
         *
         * @param  table the name of the data table
         * @param  column the name of the column to get the value from
         * @return the column
     */
    public static native String[] dataTableGetStringColumn(String table, int column);
    public static native String[] dataTableGetStringColumnNoDefaults(String table, int column);
    public static native boolean  dataTableOpen(String table);
    public static native int dataTableGetColumnType(String table, String column);
    public static native int dataTableGetColumnType(String table, int column);
    /**
         * Find out whether a given column name exists within a table
         *
         * @param  table the name of the data table
         * @param  column the name of the column to query
         * @return true if the column exists
     */
    public static native boolean  dataTableHasColumn(String table, String column);
    /**
     * Get the number of the columns in a data table
     *
     * @param  table the name of the data table
     * @return the number of columns
     */
    public static native int dataTableGetNumColumns (String table);
    /**
     * Get the number of the rows in a data table
     *
     * @param  table the name of the data table
     * @return the number of rows
     */
    public static native int dataTableGetNumRows (String table);
    /**
     * Get dictionary from a data table for a row.  You access the elements of the dict via the column names
     *
     * @param  table the name of the data table
     * @param  row   the row to get the value from (use 0 for the first row).
     * @return a dictionary with the elements of the row.
     */
    public static native dictionary dataTableGetRow (String table, int row);
    /**
     * Get a Dictionary value from a Row in a data table compiled with the DataTableTool
     *
     * @param  table the name of the data table
     * @param  row   the string value in column 0 of the row to get the value from
     * @return the value in the cell
     */
    public static dictionary dataTableGetRow(String table, String row)
    {
        int rowNum = dataTableSearchColumnForString(row, 0, table);
        if ( rowNum == -1 )
            return null;
        return dataTableGetRow(table, rowNum);
    }
    /**
     * Get the name of a particular column.
     *
     * @param  table     the name of the data table
     * @param  columns   the columns to get the name of(use 0 for the first column).
     * @return a string that is the name of the column.
     */
    public static native String   dataTableGetColumnName(String table, int column);
    /**
     * Get the names of columns in a data table.
     *
     * @param  table     the name of the data table.
     * @return a string array that is the names of the columns.
     */
    public static native String[] dataTableGetColumnNames(String table);
    /**
     * Search for a row in a datatable that contains a specified string.
     *
     * @param  entry     the thing to search for
     * @param  column    which column to search in
     * @param  table     the name of the data table.
     * @return the row number that contains that entry.
     */
    public static native int dataTableSearchColumnForString(String entry, String column, String table);
    /**
     * Search for a row in a datatable that contains a specified int.
     *
     * @param  entry     the thing to search for
     * @param  column    which column to search in
     * @param  table     the name of the data table.
     * @return the row number that contains that entry.
     */
    public static native int dataTableSearchColumnForInt(int entry, String column, String table);
    /**
     * Search for a row in a datatable that contains a specified string.
     *
     * @param  entry     the thing to search for
     * @param  column    which column to search in
     * @param  table     the name of the data table.
     * @return the row number that contains that entry.
     */
    public static native int dataTableSearchColumnForString(String entry, int column, String table);
    /**
     * Search for a row in a datatable that contains a specified int.
     *
     * @param  entry     the thing to search for
     * @param  column    which column to search in
     * @param  table     the name of the data table.
     * @return the row number that contains that entry.
     */
    public static native int dataTableSearchColumnForInt(int entry, int column, String table);
    /**
     * Find the column index for a column name.
     *
     * @param table     the name of the data table
     * @param column    the column to look up
     * @return the column number, or -1 on error
     */
    public static native int dataTableFindColumnNumber(String table, String column);
    /**
     * Add a row to a datatable, if allowed from a config option.
     *
     * @param  table  the name of the data table
     * @param  row    the row to add, as a dictionary of column name to value
     */
    public static native void dataTableAddRow(String table, dictionary row);


    /*@}*/

    /**
    * @defgroup commandQueue Methods for dealing with command queues
    * @{
    */
    /**
     * Enqueue a command on a creature's command queue to be executed.
     *
     * @param  actor       the creature on which to enqueue the command
     * @param  commandHash the hash value for the command to execute
     * @param  target      the target of the command, if any
     * @param  params      any additional parameters to the command
     * @param  priority    priority at which to execute (may be default)
     * @return whether successful
     */
    private static native boolean _queueCommand(long actor, int commandHash, long target, String params, int priority);
    public static boolean queueCommand(obj_id actor, int commandHash, obj_id target, String params, int priority)
    {
        return _queueCommand(getLongWithNull(actor), commandHash, getLongWithNull(target), params, priority);
    }

    /**
     * Clear a creature's command queue (only the clearable commands).
     *
     * @param  actor  the creature on which to clear the command queue
     * @return whether successful
     */
    private static native boolean _queueClear(long actor);
    public static boolean queueClear(obj_id actor)
    {
        return _queueClear(getLongWithNull(actor));
    }
    /**
     * Check if any commands of a particular command group are in the queue.
     *
     * @param  actor  the creature on which to check for commands
     * @param  group  hash of the command group name to check for
     * @return whether commands from the specified group are present
     */
    private static native boolean _queueHasCommandFromGroup(long actor, int group);
    public static boolean queueHasCommandFromGroup(obj_id actor, int group)
    {
        return _queueHasCommandFromGroup(getLongWithNull(actor), group);
    }
    /**
     * Clear a commands of a specified group from a creature's command queue.
     *
     * @param  actor  the creature on which to clear the commands
     * @param  group  hash of the command group name to clear commands from
     * @return whether successful
     */
    private static native boolean _queueClearCommandsFromGroup(long actor, int group);
    public static boolean queueClearCommandsFromGroup(obj_id actor, int group)
    {
        return _queueClearCommandsFromGroup(getLongWithNull(actor), group);
    }
    /**
     * Returns the max range a player can be from a target to execute a given command.
     * @param commandHash       the command to get the range for
     * @return the range, or -1 if an unknown command
     */
    public static native float   getCommandMaxRange(int commandHash);

    /**
     * Sets the specified duration timer for the currently executing command
     *
     * @param actor      creature who's command queue we're going to access
     * @param timerClass TIMER_WARMUP, TIMER_EXECUTE, or TIMER_COOLDOWN
     * @param newTime    the new time for this command.
     */
    private static native boolean _setCommandTimerValue(long actor, int timerClass, float newTime );
    public static boolean setCommandTimerValue(obj_id actor, int timerClass, float newTime )
    {
        return _setCommandTimerValue(getLongWithNull(actor), timerClass, newTime);
    }

    /**
     * Returns the crc32 of the current command in the command queue
     *
     * @param actor      creature who's command queue we're going to access, or 0 on error
     */
    private static native int _getCurrentCommand(long actor );
    public static int getCurrentCommand(obj_id actor )
    {
        return _getCurrentCommand(getLongWithNull(actor));
    }

    /**
     * Returns the time left in a specified cooldown timer group
     *
     * @param actor      creature who's command queue we're going to access
     * @param group      the cooldown timer group
     * @return           the time left in the cooldown group.
     */
    private static native float   _getCooldownTimeLeft(long actor, int cooldownGroup );
    public static float   getCooldownTimeLeft(obj_id actor, int cooldownGroup )
    {
        return _getCooldownTimeLeft(getLongWithNull(actor), cooldownGroup);
    }

    /**
     * Returns the time left in a specified cooldown timer group
     *
     * @param actor      creature who's command queue we're going to access
     * @param command    the name of the command
     * @return           the time left in the cooldown group.
     */
    private static native float   _getCooldownTimeLeft(long actor, String command );
    public static float   getCooldownTimeLeft(obj_id actor, String command )
    {
        return _getCooldownTimeLeft(getLongWithNull(actor), command);
    }

    /*@}*/

    /**
     * @defgroup permissions Cell/Building permission methods
     */
    /**
     * Get the banned list for a cell or building
     *
     * @param target   the cell or building to get permissions for
     *
     * @return the banned list
     */
    private static native String[] _permissionsGetBanned(long target);
    public static String[] permissionsGetBanned(obj_id target)
    {
        return _permissionsGetBanned(getLongWithNull(target));
    }
    /**
     * Get the allowed list for a cell or building
     *
     * @param target   the cell or building to get permissions for
     *
     * @return the allowed list
     */
    private static native String[] _permissionsGetAllowed(long target);
    public static String[] permissionsGetAllowed(obj_id target)
    {
        return _permissionsGetAllowed(getLongWithNull(target));
    }
    /**
     * Get whether a cell or building is public
     *
     * @param target   the cell or building to get permissions for
     *
     * @return true if public, false if not found or private
     */
    private static native boolean _permissionsIsPublic(long target);
    public static boolean permissionsIsPublic(obj_id target)
    {
        return _permissionsIsPublic(getLongWithNull(target));
    }
    /**
     * check if someone is allowed in a cell/building
     *
     * @param target   the cell or building to test permissions on
     * @param who      the person to test permissions for
     */
    private static native boolean _permissionsIsAllowed(long target, long who);
    public static boolean permissionsIsAllowed(obj_id target, obj_id who)
    {
        return _permissionsIsAllowed(getLongWithNull(target), getLongWithNull(who));
    }
    /**
     * add someone to a cell or building's allowed list
     *
     * @param target   the cell or building to set permissions for
     * @param name     name or id string to add to allowed list
     */
    private static native void _permissionsAddAllowed(long target, String name);
    public static void permissionsAddAllowed(obj_id target, String name)
    {
        _permissionsAddAllowed(getLongWithNull(target), name);
    }
    /**
     * remove someone from a cell or building's allowed list
     *
     * @param target   the cell or building to set permissions for
     * @param name     name or id string to remove from allowed list
     */
    private static native void _permissionsRemoveAllowed(long target, String name);
    public static void permissionsRemoveAllowed(obj_id target, String name)
    {
        _permissionsRemoveAllowed(getLongWithNull(target), name);
    }

	private static native void _permissionsRemoveAllAllowed(long target);
	public static void permissionsRemoveAllAllowed(obj_id target)
	{
		_permissionsRemoveAllAllowed(getLongWithNull(target));
	}

    /**
     * add someone to a cell or building's banned list
     *
     * @param target   the cell or building to set permissions for
     * @param name     name or id string to add to banned list
     */
    private static native void _permissionsAddBanned(long target, String name);
    public static void permissionsAddBanned(obj_id target, String name)
    {
        _permissionsAddBanned(getLongWithNull(target), name);
    }
    /**
     * remove someone from a cell or building's banned list
     *
     * @param target   the cell or building to set permissions for
     * @param name     name or id string to remove from banned list
     */
    private static native void _permissionsRemoveBanned(long target, String name);
    public static void permissionsRemoveBanned(obj_id target, String name)
    {
        _permissionsRemoveBanned(getLongWithNull(target), name);
    }

	private static native void _permissionsRemoveAllBanned(long target);
	public static void permissionsRemoveAllBanned(obj_id target)
	{
		_permissionsRemoveAllBanned(getLongWithNull(target));
	}
    /**
     * make a cell or building public
     *
     * @param target   the cell or building to set permissions for
     */
    private static native void _permissionsMakePublic(long target);
    public static void permissionsMakePublic(obj_id target)
    {
        _permissionsMakePublic(getLongWithNull(target));
    }
    /**
     * make a cell or building private
     *
     * @param target   the cell or building to set permissions for
     */
    private static native void _permissionsMakePrivate(long target);
    public static void permissionsMakePrivate(obj_id target)
    {
        _permissionsMakePrivate(getLongWithNull(target));
    }
    /**
     * expel an object from a building
     *
     * @param target object to expel
     **/
    private static native void _expelFromBuilding(long target);
    public static void expelFromBuilding(obj_id target)
    {
        _expelFromBuilding(getLongWithNull(target));
    }

    /*@}*/

    /**
     * @defgroup jedi Jedi methods
     */
    /*@{*/

        // @defgroup jedi_states The Jedi states
        // @{
        // the Jedi states. Note that these can be ored together when calling getJedi()
        // Please note that, although these states are implemented as a bitfield, they are
        // mutually exclusive.  Setting the state of a jedi to JEDI_STATE_JEDI also makes
        // them FORCE_SENSITIVE (conceptually) - but you should not set the state to
        // (JEDI_STATE_JEDI | JEDI_STATE_FORCE_SENSITIVE) because that is an invalid call.
        //
        // The exact mapping is NONE -> NONE, FORCE_SENS -> FORCE_SENS,
        // JEDI -> FORCE_SENS | JEDI, FORCE_RANK_LIGHT -> FORCE_SENS | JEDI | FORCE_RANK_LIGHT,
        // FORCE_RANK_DARK -> FORCE_SENS | JEDI | FORCE_RANK_DARK
        public static final int JEDI_STATE_NONE               = 0;
        public static final int JEDI_STATE_FORCE_SENSITIVE    = 0x00000001;
        public static final int JEDI_STATE_JEDI               = 0x00000002;
        public static final int JEDI_STATE_FORCE_RANKED_LIGHT = 0x00000004;
        public static final int JEDI_STATE_FORCE_RANKED_DARK  = 0x00000008;
        // }@

    public static final int IGNORE_JEDI_STAT = Integer.MAX_VALUE;

    /**
     * Returns if new Jedi tracking is enabled.
     */
    public static boolean getEnableNewJediTracking()
    {
        return script_entry.getEnableNewJediTracking();
    }

    /**
     * Returns if a player has a Jedi slot available to them.
     * @param player        the player to test
     * @return true if the player has a Jedi slot, false if not
     */
    private static native boolean _hasJediSlot(long player);
    public static boolean hasJediSlot(obj_id player)
    {
        return _hasJediSlot(getLongWithNull(player));
    }

    /**
     * Adds a Jedi slot to a player's available character slots.
     * @param player        the player to test
     * @return true on success, false on error
     */
    private static native boolean _addJediSlot(long player);
    public static boolean addJediSlot(obj_id player)
    {
        return _addJediSlot(getLongWithNull(player));
    }

    /**
     * Returns if a creature is a Jedi or not.
     * @param target        the creature to test
     * @return the true if the creature is a jedi, false if not
     */
    private static native boolean _isJedi(long target);
    public static boolean isJedi(obj_id target)
    {
        return _isJedi(getLongWithNull(target));
    }
    /**
     * Returns if a creature is "has" a certain Jedi state.
     * @param target        the creature to test
     * @return the true if the creature qualifies for the input state, false if not
     */
    public static boolean isJediState(obj_id target, int state)
    {
        if(state == JEDI_STATE_NONE)
            return false;
        else if(state == JEDI_STATE_FORCE_SENSITIVE)
            return getJediState(target) != JEDI_STATE_NONE;
        else if(state == JEDI_STATE_JEDI)
            return isJedi(target);
        else if(state == JEDI_STATE_FORCE_RANKED_LIGHT || state == JEDI_STATE_FORCE_RANKED_DARK)
            return getJediState(target) == state;
        else
            return false;
    }
    /**
     * Returns the state of a Jedi.
     * @param jedi      the Jedi to get
     * @return the state, or -1 on error
     */
    private static native int _getJediState(long jedi);
    public static int getJediState(obj_id jedi)
    {
        return _getJediState(getLongWithNull(jedi));
    }
    /**
     * Sets the state of a Jedi.
     * @param jedi      the Jedi to set
     * @param state     the state to set
     * @return true on success, false on error
     */
    private static native boolean _setJediState(long jedi, int state);
    public static boolean setJediState(obj_id jedi, int state)
    {
        return _setJediState(getLongWithNull(jedi), state);
    }
    /**
     * Returns the visibility of a Jedi.
     * @param jedi      the Jedi to get
     * @return the visibility, or -1 on error
     */
    private static native int _getJediVisibility(long jedi);
    public static int getJediVisibility(obj_id jedi)
    {
        return _getJediVisibility(getLongWithNull(jedi));
    }
    /**
     * Sets the visibility of a Jedi.
     * @param jedi          the Jedi to set
     * @param visibility    the visibility to set
     * @return true on success, false on error
     */
    private static native boolean _setJediVisibility(long jedi, int visibility);
    public static boolean setJediVisibility(obj_id jedi, int visibility)
    {
        return _setJediVisibility(getLongWithNull(jedi), visibility);
    }
    /**
     * Changes the current visibility of a Jedi.
     * @param jedi          the Jedi to change
     * @param delta         the amount to add to the Jedi's current visibility
     * @return true on success, false on error
     */
    private static native boolean _changeJediVisibility(long jedi, int delta);
    public static boolean changeJediVisibility(obj_id jedi, int delta)
    {
        return _changeJediVisibility(getLongWithNull(jedi), delta);
    }

	/**
	 * Sets the bounty value of a Jedi.
	 * @param jedi          the Jedi to set
	 * @param bountyValue   the bounty value to set
	 * @return true on success, false on error
	 */
	private static native boolean _setJediBountyValue(long jedi, int bountyValue);
	public static boolean setJediBountyValue(obj_id jedi, int bountyValue)
	{
		return _setJediBountyValue(getLongWithNull(jedi), bountyValue);
	}

	/**
	 * Sends a request to find Jedi characters. Limits are passed in for statistics that the caller is interested in;
	 * the Jedi returned will have the requested value or greater for the statistic if the value given is >= 0, or
	 * less than the statistic if the value given is < 0. If the statistic should be ignored, IGNORE_JEDI_STAT should
	 * be passed in as the limit value. The exception to this is the minLevel and maxLevel parameters, which always
	 * specify the (inclusive) minLevel and maxLevel filter
	 *
	 * @param visibility        limit for visibility statistic
	 * @param bountyValue       limit for bounty value statistic
	 * @param minLevel          minimum Jedi level (inclusive)
	 * @param maxLevel          maximum Jedi level (inclusive)
	 * @param hoursAlive        limit for hours alive statistic
	 * @param bounties          limit for number of bounties on the Jedi statistic
	 *
	 * @return a dictionary with info on the Jedi that meet the criteria. The dictionary will
	 *                          contain the following data (which are parallel arrays):
	 *
	 *                          obj_id[]   id             obj_ids for the Jedi
	 *                          string[]   name           names of the Jedi
	 *                          location[] location       the location of the Jedi (very approximate); only the x,y,z values are valid
	 *                          string[]   scene          the scene/planet of the Jedi
	 *                          int[]      visibility     visibility value for the Jedi
	 *                          int[]      bountyValue    bounty value for the Jedi
	 *                          int[]      level          level for the Jedi
	 *                          int[]      hoursAlive     hours alive value for the Jedi
	 *                          int[]      state          the state of the Jedi
	 *                          obj_id[][] bounties       list of bounty hunters tracking the jedi
	 *                          boolean[]  online         flag if the Jedi is online or not
	 *                          int[]      faction        the faction of the Jedi (as returned by pvpGetAlignedFaction())
	 *                          int[]      ??????         one int[] will be returned for every data name set via the function
	 *                                                    updateJediScriptData(); if the function wasn't called for a Jedi/name pair
	 *                                                    the returned value will be 0
	 *
	 *                          Note that this data may not be 100% accurate when you get it, due to delays
	 *                          sending mesasges around, etc.
	 */
	public static dictionary requestJedi(int visibility, int bountyValue, int minLevel, int maxLevel, int hoursAlive, int bounties)
    {
        return requestJedi(visibility, bountyValue, minLevel, maxLevel, hoursAlive, bounties, IGNORE_JEDI_STAT);
    }

	/**
	 * Sends a request to find Jedi characters. Limits are passed in for statistics that the caller is interested in;
	 * the Jedi returned will have the requested value or greater for the statistic if the value given is >= 0, or
	 * less than the statistic if the value given is < 0. If the statistic should be ignored, IGNORE_JEDI_STAT should
	 * be passed in as the limit value. The exception to this is the minLevel and maxLevel parameters, which always
	 * specify the (inclusive) minLevel and maxLevel filter
	 *
	 * @param visibility        limit for visibility statistic
	 * @param bountyValue       limit for bounty value statistic
	 * @param minLevel          minimum Jedi level (inclusive)
	 * @param maxLevel          maximum Jedi level (inclusive)
	 * @param hoursAlive        limit for hours alive statistic
	 * @param bounties          limit for number of bounties on the Jedi statistic
	 * @param state             which state(s) the Jedi should have (IGNORE_JEDI_STAT = any)
	 *
	 * @return a dictionary with info on the Jedi that meet the criteria. The dictionary will
	 *                          contain the following data (which are parallel arrays):
	 *
	 *                          obj_id[]   id             obj_ids for the Jedi
	 *                          string[]   name           names of the Jedi
	 *                          location[] location       the location of the Jedi (very approximate); only the x,y,z values are valid
	 *                          string[]   scene          the scene/planet of the Jedi
	 *                          int[]      visibility     visibility value for the Jedi
	 *                          int[]      bountyValue    bounty value for the Jedi
	 *                          int[]      level          level for the Jedi
	 *                          int[]      hoursAlive     hours alive value for the Jedi
	 *                          int[]      state          state of the Jedi
	 *                          obj_id[][] bounties       list of bounty hunters tracking the jedi
	 *                          boolean[]  online         flag if the Jedi is online or not
	 *                          int[]      faction        the faction of the Jedi (as returned by pvpGetAlignedFaction())
	 *                          int[]      ??????         one int[] will be returned for every data name set via the function
	 *                                                    updateJediScriptData(); if the function wasn't called for a Jedi/name pair
	 *                                                    the returned value will be 0
	 *
	 *                          Note that this may not be 100% accurate when you get it, due to delays
	 *                          sending mesasges around, etc.
	 */
	public static dictionary requestJedi(int visibility, int bountyValue, int minLevel, int maxLevel, int hoursAlive, int bounties, int state)
    {
        dictionary result = _requestJedi(visibility, bountyValue, minLevel, maxLevel, hoursAlive, bounties, state);
        if (result != null)
        {
            // Copy the scene data into the location data of the result returned by a requestJedi call, since some
            // designers can't handle the idea of parallel arrays
            location[] loc = result.getLocationArray("location");
            String[] scene = result.getStringArray("scene");
            if (loc != null && scene != null && loc.length == scene.length)
            {
                for ( int i = 0; i < loc.length; ++i )
                {
                    loc[i].area = scene[i];
                }
            }
        }
        return result;
    }
	private static native dictionary _requestJedi(int visibility, int bountyValue, int minLevel, int maxLevel, int hoursAlive, int bounties, int state);

    /**
     * Sends a request to find a specific Jedi.
     *
     * @param id        the Jedi's id
     *
     * @return a dictionary with info on the Jedi that meet the criteria. The data in the dictionary is the
     * same as for the requestJedi above, but returns single data values instead of arrays. The return value
     * is null if the obj_id passed in isn't a registered Jedi
     */
    public static dictionary requestJedi(obj_id id)
    {
        dictionary result = _requestJedi(id);
        if (result != null)
        {
            // Copy the scene data into the location data of the result returned by a requestJedi call, since some
            // designers can't handle the idea of parallel arrays
            location loc = result.getLocation("location");
            String scene = result.getString("scene");
            if (loc != null && scene != null)
            {
                loc.area = scene;
            }
        }
        return result;
    }
    private static native dictionary __requestJedi(long id);
    private static dictionary _requestJedi(obj_id id)
    {
        return __requestJedi(getLongWithNull(id));
    }

    /**
     * Requests to assign a bounty hunter to track down a Jedi.
     *
     * @param target            the Jedi to hunt
     * @param hunter            the bounty hunter
     * @param successCallback   name of a messageHandler than will be called if the
     *                          bounty was assigned
     * @param failCallback      name of a messageHandler than will be called if the
     *                          bounty was not assigned
     *
     *                          The params dictionary will contain the following data:
     *
     *                          obj_id  jedi        the Jedi to hunt
     *                          obj_id  hunter      the bounty hunter
     *                          int     bounties    number of bounties on the Jedi (including the one just assigned, if successful)
     *
     * @return true if the request was sent, false if there was an error
     */
    public static boolean requestJediBounty(obj_id target, obj_id hunter, String successCallback, String failCallback)
    {
        return requestJediBounty(target, hunter, successCallback, failCallback, getSelf());
    }
    private static native boolean _requestJediBounty(long target, long hunter, String successCallback, String failCallback, long self);
    private static boolean requestJediBounty(obj_id target, obj_id hunter, String successCallback, String failCallback, obj_id self)
    {
        return _requestJediBounty(getLongWithNull(target), getLongWithNull(hunter), successCallback, failCallback, getLongWithNull(self));
    }

    /**
     * Removes a bounty from a Jedi.
     *
     * @param target        the Jedi
     * @param hunter        the player hunting the Jedi
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _removeJediBounty(long target, long hunter);
    public static boolean removeJediBounty(obj_id target, obj_id hunter)
    {
        return _removeJediBounty(getLongWithNull(target), getLongWithNull(hunter));
    }

    /**
     * Removes all the bounties on a Jedi.
     *
     * @param target        the Jedi
     *
     * @return true on success, false if there was an error
     */
    private static native boolean _removeAllJediBounties(long target);
    public static boolean removeAllJediBounties(obj_id target)
    {
        return _removeAllJediBounties(getLongWithNull(target));
    }

    /**
     * Returns a list of players who are hunting a Jedi.
     *
     * @param target        the Jedi
     *
     * @return an array of hunter ids, or null on error
     */
    private static native long[] _getJediBounties(long target);
    public static obj_id[] getJediBounties(obj_id target)
    {
        long[] _ret_long = _getJediBounties(getLongWithNull(target));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

	/**
	 * Checks to see if a bounty hunter has a bounty on a target
	 *
	 * @param target            the Jedi to hunt
	 * @param hunter            the bounty hunter
	 *
	 * @return true or false
	 */
	public static boolean isBeingHuntedByBountyHunter(obj_id target, obj_id hunter)
	{
		return _isBeingHuntedByBountyHunter(getLongWithNull(target), getLongWithNull(hunter));
	}
	private static native boolean _isBeingHuntedByBountyHunter(long target, long hunter);

    /**
     * Returns a list of Jedi being hunted by the bounty hunter.
     *
     * @param hunter        the bounty hunter
     *
     * @return an array of jedi ids, or null on error
     */
    private static native long[] _getBountyHunterBounties(long hunter);
	public static obj_id[] getBountyHunterBounties(obj_id hunter)
    {
		long[] _ret_long = _getBountyHunterBounties(getLongWithNull(hunter));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

    /**
     * Adds data about a Jedi to the Jedi manager.
     * @param target    the Jedi
     * @param name      the data name
     * @param value     the data value
     */
    private static native void _updateJediScriptData(long target, String name, int value);
    public static void updateJediScriptData(obj_id target, String name, int value)
    {
        _updateJediScriptData(getLongWithNull(target), name, value);
    }

    /**
     * Removes data about a Jedi from the Jedi manager.
     * @param target    the Jedi
     * @param name      the data name
     * @param value     the data value
     */
    private static native void _removeJediScriptData(long target, String name);
    public static void removeJediScriptData(obj_id target, String name)
    {
        _removeJediScriptData(getLongWithNull(target), name);
    }

    /*@} jedi*/

    /**
     * @defgroup pvp Pvp methods
     */
    /*@{*/
    /**
     * Allows script to make an object (i.e. like a turret) attackable
     *
     * @param dest the object to make attackable
     * @param value true or false
     *
     */
    private static native void _pvpSetAttackableOverride(long dest, boolean value);
    public static void pvpSetAttackableOverride(obj_id dest, boolean value)
    {
        _pvpSetAttackableOverride(getLongWithNull(dest), value);
    }
    /**
     * Check whether an object is allowed to attack another.
     *
     * @param  actor  actor for the aggressive action
     * @param  target target for the aggressive action
     * @return whether allowed
     */
    private static native boolean _pvpCanAttack(long actor, long target);
    public static boolean pvpCanAttack(obj_id actor, obj_id target)
    {
        return _pvpCanAttack(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
     * Check whether an object is allowed to help another.
     *
     * @param  actor  actor for the helping action
     * @param  target target for the helping action
     * @return whether allowed
     */
    private static native boolean _pvpCanHelp(long actor, long target);
    public static boolean pvpCanHelp(obj_id actor, obj_id target)
    {
        return _pvpCanHelp(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
     * Handle an aggressive action having been done.
     *
     * @param  actor  actor for the aggressive action
     * @param  target target for the aggressive action
     */
    private static native void _pvpAttackPerformed(long actor, long target);
    public static void pvpAttackPerformed(obj_id actor, obj_id target)
    {
        _pvpAttackPerformed(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
     * Handle a helping action having been done.
     *
     * @param  actor  actor for the helping action
     * @param  target target for the helping action
     */
    private static native void _pvpHelpPerformed(long actor, long target);
    public static void pvpHelpPerformed(obj_id actor, obj_id target)
    {
        _pvpHelpPerformed(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
     * Set mercenary faction (Imperial or Rebel or 0) for a neutral player character
     *
     * @param dest      object to set on
     * @param factionId id for the faction
     * @param declared  declared (or covert)
     */
    private static native void _pvpNeutralSetMercenaryFaction(long dest, int factionId, boolean declared);
    public static void pvpNeutralSetMercenaryFaction(obj_id dest, int factionId, boolean declared)
    {
        _pvpNeutralSetMercenaryFaction(getLongWithNull(dest), factionId, declared);
    }
    /**
     * Get mercenary faction (Imperial or Rebel or 0) for a neutral player character
     *
     * @param who object to get mercenary faction from
     * @return string hash value for the faction
     */
    private static native int _pvpNeutralGetMercenaryFaction(long who);
    public static int pvpNeutralGetMercenaryFaction(obj_id who)
    {
        return _pvpNeutralGetMercenaryFaction(getLongWithNull(who));
    }
    /**
     * Get mercenary declared (vs covert) state for a neutral player character
     *
     * @param who object to get mercenary faction from
     * @return boolean
     */
    private static native boolean _pvpNeutralIsMercenaryDeclared(long who);
    public static boolean pvpNeutralIsMercenaryDeclared(obj_id who)
    {
        return _pvpNeutralIsMercenaryDeclared(getLongWithNull(who));
    }
    /**
     * Set aligned faction for an object
     *
     * @param dest      object to set on
     * @param factionId id for the faction
     */
    private static native void _pvpSetAlignedFaction(long dest, int factionId);
    public static void pvpSetAlignedFaction(obj_id dest, int factionId)
    {
        _pvpSetAlignedFaction(getLongWithNull(dest), factionId);
    }
    /**
     * Set an object to on leave
     *
     * @param dest      object to set on
     */
    private static native void _pvpMakeOnLeave(long dest);
    public static void pvpMakeOnLeave(obj_id dest)
    {
        _pvpMakeOnLeave(getLongWithNull(dest));
    }
    /**
     * Set an object to covert
     *
     * @param dest      object to set on
     */
    private static native void _pvpMakeCovert(long dest);
    public static void pvpMakeCovert(obj_id dest)
    {
        _pvpMakeCovert(getLongWithNull(dest));
    }
    /**
     * Set an object to declared
     *
     * @param dest      object to set on
     */
    private static native void _pvpMakeDeclared(long dest);
    public static void pvpMakeDeclared(obj_id dest)
    {
        _pvpMakeDeclared(getLongWithNull(dest));
    }
    /**
     * Set an object to neutral
     *
     * @param dest      object to set on
     */
    private static native void _pvpMakeNeutral(long dest);
    public static void pvpMakeNeutral(obj_id dest)
    {
        _pvpMakeNeutral(getLongWithNull(dest));
    }
    /**
     * Flag an object as begining to become covert
     *
     * @param dest      object to set on
     */
    private static native void _pvpPrepareToBeCovert(long dest);
    public static void pvpPrepareToBeCovert(obj_id dest)
    {
        _pvpPrepareToBeCovert(getLongWithNull(dest));
    }
    /**
     * Flag an object as begining to become declared
     *
     * @param dest      object to set on
     */
    private static native void _pvpPrepareToBeDeclared(long dest);
    public static void pvpPrepareToBeDeclared(obj_id dest)
    {
        _pvpPrepareToBeDeclared(getLongWithNull(dest));
    }
    /**
     * Flag an object as begining to become neutral
     *
     * @param dest      object to set on
     */
    // this currently does nothing visually on the client
    private static native void _pvpPrepareToBeNeutral(long dest);
    public static void pvpPrepareToBeNeutral(obj_id dest)
    {
        _pvpPrepareToBeNeutral(getLongWithNull(dest));
    }
    /**
     * Set a personal enemy flag on an object
     *
     * @param dest      object to set on
     * @param enemy     enemy object
     */
    private static native void _pvpSetPersonalEnemyFlag(long dest, long enemy);
    public static void pvpSetPersonalEnemyFlag(obj_id dest, obj_id enemy)
    {
        _pvpSetPersonalEnemyFlag(getLongWithNull(dest), getLongWithNull(enemy));
    }
    /**
     * Set a permanent personal enemy flag on an object
     *
     * @param dest      object to set on
     * @param enemy     enemy object
     */
    private static native void _pvpSetPermanentPersonalEnemyFlag(long dest, long enemy);
    public static void pvpSetPermanentPersonalEnemyFlag(obj_id dest, obj_id enemy)
    {
        _pvpSetPermanentPersonalEnemyFlag(getLongWithNull(dest), getLongWithNull(enemy));
    }
    /**
     * Set a faction enemy flag on an object
     *
     * @param dest      object to set on
     * @param factionId enemy faction
     */
    private static native void _pvpSetFactionEnemyFlag(long dest, int factionId);
    public static void pvpSetFactionEnemyFlag(obj_id dest, int factionId)
    {
        _pvpSetFactionEnemyFlag(getLongWithNull(dest), factionId);
    }
    /**
     * Set the "guild war cool down period" enemy flag on an object
     * to prevent it from participating in any guild war related
     * pvp for a period of time
     *
     * @param dest      object to set on
     */
    private static native void _pvpSetGuildWarCoolDownPeriodEnemyFlag(long dest);
    public static void pvpSetGuildWarCoolDownPeriodEnemyFlag(obj_id dest)
    {
        _pvpSetGuildWarCoolDownPeriodEnemyFlag(getLongWithNull(dest));
    }
    /**
     * Get the pvp type for an object
     *
     * @param who object to get pvp type from
     * @return pvp type for the object
     */
    private static native int _pvpGetType(long who);
    public static int pvpGetType(obj_id who)
    {
        return _pvpGetType(getLongWithNull(who));
    }
    /**
     * Get the aligned faction type for an object (string hash of faction name)
     *
     * @param who object to get aligned faction from
     * @return string hash value for the faction
     */
    private static native int _pvpGetAlignedFaction(long who);
    public static int pvpGetAlignedFaction(obj_id who)
    {
        return _pvpGetAlignedFaction(getLongWithNull(who));
    }
    /**
     * Get the enemy flags on an object
     *
     * @param who object to get enemy flags from
     * @return array of enemy flag specifiers ("enemyId enemyAlign expireTime")
     */
    private static native String[] _pvpGetEnemyFlags(long who);
    public static String[] pvpGetEnemyFlags(obj_id who)
    {
        return _pvpGetEnemyFlags(getLongWithNull(who));
    }
    /**
     * Check whether the target is either a personal or faction enemy of the actor
     *
     * @param actor   person checking enemy status
     * @param target  target to check enemy status on
     * @return true if enemy, false if not or on error
     */
    private static native boolean _pvpIsEnemy(long actor, long target);
    public static boolean pvpIsEnemy(obj_id actor, obj_id target)
    {
        return _pvpIsEnemy(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
     * Check whether the actor and target are currently dueling
     *
     * @param actor   actor
     * @param target  target
     * @return true if dueling, false if not or on error
     */
    private static native boolean _pvpIsDueling(long actor, long target);
    public static boolean pvpIsDueling(obj_id actor, obj_id target)
    {
        return _pvpIsDueling(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
     * Check whether the target has a battlefield enemy flag
     *
     * @param target  person to look for a battlefield enemy flag on
     * @return true if enemy, false if not or on error
     */
    private static native boolean _pvpHasBattlefieldEnemyFlag(long target);
    public static boolean pvpHasBattlefieldEnemyFlag(obj_id target)
    {
        return _pvpHasBattlefieldEnemyFlag(getLongWithNull(target));
    }
    /**
     * Check whether the target has any temp enemy flags
     *
     * @param target  person to check for enemy flags
     * @return true if the target has any timed enemy flags, false if not or on error
     */
    private static native boolean _pvpHasAnyTempEnemyFlags(long target);
    public static boolean pvpHasAnyTempEnemyFlags(obj_id target)
    {
        return _pvpHasAnyTempEnemyFlags(getLongWithNull(target));
    }
    /**
     * Get a list of obj_ids from the enemy flags on target
     *
     * @param target  person to check for enemy flags
     * @return array of enemy ids
     */
    private static native long[] _pvpGetPersonalEnemyIds(long target);
    public static obj_id[] pvpGetPersonalEnemyIds(obj_id target)
    {
        long[] _ret_long = _pvpGetPersonalEnemyIds(getLongWithNull(target));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Remove any temp enemy flags for the specified enemy id from the target
     *
     * @param target  the person to remove flags from
     * @param enemyId the id of the enemy to remove flags for, or a 0 id for all non-FEFs
     */
    private static native void _pvpRemoveTempEnemyFlags(long target, long enemyId);
    public static void pvpRemoveTempEnemyFlags(obj_id target, obj_id enemyId)
    {
        _pvpRemoveTempEnemyFlags(getLongWithNull(target), getLongWithNull(enemyId));
    }
    /**
     * Get an array of enemy objects which are in range of a location.
     *
     * @param actor The actor for the enemy check
     * @param from  The center of the range
     * @param range The distance to query.
     * @return null if there is an error, or an array of enemy objects which are in range.
     */
    private static native long[] _pvpGetEnemiesInRange(long actor, long from, float range);
    public static obj_id[] pvpGetEnemiesInRange(obj_id actor, obj_id from, float range)
    {
        long[] _ret_long = _pvpGetEnemiesInRange(getLongWithNull(actor), getLongWithNull(from), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get an array of enemy objects which are in a cone of a location.
     *
     * @param actor                The actor for the enemy check
     * @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     * @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                             the coneCenterObject position to this object's position.
     * @param range                The distance to query from the center of the cone.  Note the cone
     *                             extends along the cone axis this distance, and does not necessarily
     *                             extend as far as the cone direction object's distance from the cone center.
     * @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                             total cone angle is twice this angle; therefore, this angle
     *                             represents the angle swept out to each side of the cone axis.
     * @return null if there is an error, or an array of enemy objects which are in range.
     */
    private static native long[] _pvpGetEnemiesInCone(long actor, long coneCenterObject, long coneDirectionObject, float range, float angle);
    public static obj_id[] pvpGetEnemiesInCone(obj_id actor, obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle)
    {
        long[] _ret_long = _pvpGetEnemiesInCone(getLongWithNull(actor), getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
	/**
     * Get an array of enemy objects which are in a cone of a location.
     *
     * @param actor                The actor for the enemy check
     * @param coneCenterObject     The object at the center (base, pointy part) of the cone.
	 * @param coneDirectionLocation The position to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this position (scene value of the location ignored).
     * @param range                The distance to query from the center of the cone.  Note the cone
     *                             extends along the cone axis this distance, and does not necessarily
     *                             extend as far as the cone direction object's distance from the cone center.
     * @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                             total cone angle is twice this angle; therefore, this angle
     *                             represents the angle swept out to each side of the cone axis.
     * @return null if there is an error, or an array of enemy objects which are in range.
     */
    private static native long[] _pvpGetEnemiesInCone(long actor, long coneCenterObject, location coneDirectionLocation, float range, float angle);
    public static obj_id[] pvpGetEnemiesInCone(obj_id actor, obj_id coneCenterObject, location coneDirectionLocation, float range, float angle)
    {
        long[] _ret_long = _pvpGetEnemiesInCone(getLongWithNull(actor), getLongWithNull(coneCenterObject), coneDirectionLocation, range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get an array of attackable objects which are in range of a location.
     *
     * @param actor The actor for the canAttack check
     * @param from  The center of the range
     * @param range The distance to query.
     * @return null if there is an error, or an array of attackable objects which are in range.
     */
    private static native long[] _pvpGetTargetsInRange(long actor, long from, float range);
    public static obj_id[] pvpGetTargetsInRange(obj_id actor, obj_id from, float range)
    {
        long[] _ret_long = _pvpGetTargetsInRange(getLongWithNull(actor), getLongWithNull(from), range);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get an array of attackable objects which are in a cone of a location.
     *
     * @param actor                The actor for the canAttack check
     * @param coneCenterObject     The object at the center (base, pointy part) of the cone.
     * @param coneDirectionObject  An object to orient the axis of the cone.  The axis goes from
     *                             the coneCenterObject position to this object's position.
     * @param range                The distance to query from the center of the cone.  Note the cone
     *                             extends along the cone axis this distance, and does not necessarily
     *                             extend as far as the cone direction object's distance from the cone center.
     * @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                             total cone angle is twice this angle; therefore, this angle
     *                             represents the angle swept out to each side of the cone axis.
     * @return null if there is an error, or an array of attackable objects which are in range.
     */
    private static native long[] _pvpGetTargetsInCone(long actor, long coneCenterObject, long coneDirectionObject, float range, float angle);
    public static obj_id[] pvpGetTargetsInCone(obj_id actor, obj_id coneCenterObject, obj_id coneDirectionObject, float range, float angle)
    {
        long[] _ret_long = _pvpGetTargetsInCone(getLongWithNull(actor), getLongWithNull(coneCenterObject), getLongWithNull(coneDirectionObject), range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
	/**
     * Get an array of attackable objects which are in a cone of a location.
     *
     * @param actor                The actor for the canAttack check
     * @param coneCenterObject     The object at the center (base, pointy part) of the cone.
	 * @param coneDirectionLocation The position to orient the axis of the cone.  The axis goes from
     *                              the coneCenterObject position to this position (scene value of the location ignored).
	 * @param range                The distance to query from the center of the cone.  Note the cone
     *                             extends along the cone axis this distance, and does not necessarily
     *                             extend as far as the cone direction object's distance from the cone center.
     * @param angle                The cone angle, in degrees, that the cone sweeps out.  The
     *                             total cone angle is twice this angle; therefore, this angle
     *                             represents the angle swept out to each side of the cone axis.
     * @return null if there is an error, or an array of attackable objects which are in range.
     */
    private static native long[] _pvpGetTargetsInCone(long actor, long coneCenterObject, location coneDirectionLocation, float range, float angle);
    public static obj_id[] pvpGetTargetsInCone(obj_id actor, obj_id coneCenterObject, location coneDirectionLocation, float range, float angle)
    {
        long[] _ret_long = _pvpGetTargetsInCone(getLongWithNull(actor), getLongWithNull(coneCenterObject), coneDirectionLocation, range, angle);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Check whether a faction has another faction as an opponent
     *
     * @param faction1  id for faction to check opponents of
     * @param faction2  id for potential opponent
     * @return whether factions are opposed
     */
    public static native boolean pvpAreFactionsOpposed(int faction1, int faction2);
    /**
     * Get a person's faction on a particular battlefield
     *
     * @param target  the person to get the faction for
     * @param region  the battlefield region
     * @return the faction id or 0
     */
    private static native int _pvpBattlefieldGetFaction(long target, region battleRegion);
    public static int pvpBattlefieldGetFaction(obj_id target, region battleRegion)
    {
        return _pvpBattlefieldGetFaction(getLongWithNull(target), battleRegion);
    }
    /**
     * Check whether a person is a participant on a battlefield
     *
     * @param target  the person to check
     * @param region  the battlefield region
     * @return whether the person is involved in the battlefield
     */
    private static native boolean _pvpBattlefieldIsParticipant(long target, region battleRegion);
    public static boolean pvpBattlefieldIsParticipant(obj_id target, region battleRegion)
    {
        return _pvpBattlefieldIsParticipant(getLongWithNull(target), battleRegion);
    }
    /**
     * Set the faction a person is fighting for on a battlefield
     *
     * @param target   the person
     * @param region   the battlefield region
     * @param faction  the faction, or 0 to remove
     */
    private static native void _pvpBattlefieldSetParticipant(long target, region battleRegion, int factionId);
    public static void pvpBattlefieldSetParticipant(obj_id target, region battleRegion, int factionId)
    {
        _pvpBattlefieldSetParticipant(getLongWithNull(target), battleRegion, factionId);
    }
    /**
     * Get the battlefield participants of a particular faction
     *
     * @param region  the battlefield region
     * @param faction the faction, or 0 for all factions
     */
    private static native long[] _pvpBattlefieldGetParticipantsForFaction(region battleRegion, int factionId);
    public static obj_id[] pvpBattlefieldGetParticipantsForFaction(region battleRegion, int factionId)
    {
        long[] _ret_long = _pvpBattlefieldGetParticipantsForFaction(battleRegion, factionId);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Clear the participant data for a battlefield region
     *
     * @param region   the battlefield region
     */
    public static native void pvpBattlefieldClearParticipants(region battleRegion);
    /**
     * Remove all temp enemy flags from an object (generally used for death)
     *
     * @param target  the object to strip enemy flags from
     */
    private static native void _pvpRemoveAllTempEnemyFlags(long target);
    public static void pvpRemoveAllTempEnemyFlags(obj_id target)
    {
        _pvpRemoveAllTempEnemyFlags(getLongWithNull(target));
    }
    /**
   * Returns whether pvpAttackPerformed(actor, target) would result in aligned enemy flags on actor.
     */
    private static native boolean _pvpWouldAttackCauseAlignedEnemyFlag(long actor, long target);
    public static boolean pvpWouldAttackCauseAlignedEnemyFlag(obj_id actor, obj_id target)
    {
        return _pvpWouldAttackCauseAlignedEnemyFlag(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
   * Returns whether pvpHelpPerformed(actor, target) would result in aligned enemy flags on actor.
     */
    private static native boolean _pvpWouldHelpCauseAlignedEnemyFlag(long actor, long target);
    public static boolean pvpWouldHelpCauseAlignedEnemyFlag(obj_id actor, obj_id target)
    {
        return _pvpWouldHelpCauseAlignedEnemyFlag(getLongWithNull(actor), getLongWithNull(target));
    }
    /**
     * Check whether actor has target as a personal enemy.
     *
     * @param  actor
     * @param  target
     * @return whether actor has target as a personal enemy
     */
    private static native boolean _pvpHasPersonalEnemyFlag(long actor, long target);
    public static boolean pvpHasPersonalEnemyFlag(obj_id actor, obj_id target)
    {
        return _pvpHasPersonalEnemyFlag(getLongWithNull(actor), getLongWithNull(target));
    }

    /**
     * Remove any personal enemy flags for the specified enemy id from the target
     *
     * @param target  the person to remove flags from
     * @param enemyId the id of the enemy to remove flags for
     */
    private static native void _pvpRemovePersonalEnemyFlags(long target, long enemyId);
    public static void pvpRemovePersonalEnemyFlags(obj_id target, obj_id enemyId)
    {
        _pvpRemovePersonalEnemyFlags(getLongWithNull(target), getLongWithNull(enemyId));
    }

	/**
	 * Adjust the current GCW points for the specified player character
	 *
	 * @param target     the player character
	 * @param adjustment adjustment value
	 */
	private static native void _pvpModifyCurrentGcwPoints(long target, int adjustment);
	public static void pvpModifyCurrentGcwPoints(obj_id target, int adjustment)
	{
		_pvpModifyCurrentGcwPoints(getLongWithNull(target), adjustment);
	}

	/**
	 * Adjust the current PvP kills for the specified player character
	 *
	 * @param target     the player character
	 * @param adjustment adjustment value
	 */
	private static native void _pvpModifyCurrentPvpKills(long target, int adjustment);
	public static void pvpModifyCurrentPvpKills(obj_id target, int adjustment)
	{
		_pvpModifyCurrentPvpKills(getLongWithNull(target), adjustment);
	}

	/**
	 * Get the current GCW rank for the specified player character
	 *
	 * @param target     the player character
	 * @return the current GCW rank for the specified player character
	 */
	private static native int _pvpGetCurrentGcwRank(long target);
	public static int pvpGetCurrentGcwRank(obj_id target)
	{
		return _pvpGetCurrentGcwRank(getLongWithNull(target));
	}

	/**
	 * Get the maximum GCW imperial rank for the specified player character
	 *
	 * @param target     the player character
	 * @return the maximum GCW imperial rank for the specified player character
	 */
	private static native int _pvpGetMaxGcwImperialRank(long target);
	public static int pvpGetMaxGcwImperialRank(obj_id target)
	{
		return _pvpGetMaxGcwImperialRank(getLongWithNull(target));
	}

	/**
	 * Get the maximum GCW rebel rank for the specified player character
	 *
	 * @param target     the player character
	 * @return the maximum GCW rebel rank for the specified player character
	 */
	private static native int _pvpGetMaxGcwRebelRank(long target);
	public static int pvpGetMaxGcwRebelRank(obj_id target)
	{
		return _pvpGetMaxGcwRebelRank(getLongWithNull(target));
	}

	/**
	 * Get the current GCW points for the specified player character
	 *
	 * @param target     the player character
	 * @return the current GCW points for the specified player character
	 */
	private static native int _pvpGetCurrentGcwPoints(long target);
	public static int pvpGetCurrentGcwPoints(obj_id target)
	{
		return _pvpGetCurrentGcwPoints(getLongWithNull(target));
	}

	/**
	 * Get the current GCW rating for the specified player character
	 *
	 * @param target     the player character
	 * @return the current GCW rating for the specified player character
	 */
	private static native int _pvpGetCurrentGcwRating(long target);
	public static int pvpGetCurrentGcwRating(obj_id target)
	{
		return _pvpGetCurrentGcwRating(getLongWithNull(target));
	}

	/**
	 * Get the current PvP kills for the specified player character
	 *
	 * @param target     the player character
	 * @return the current PvP kills for the specified player character
	 */
	private static native int _pvpGetCurrentPvpKills(long target);
	public static int pvpGetCurrentPvpKills(obj_id target)
	{
		return _pvpGetCurrentPvpKills(getLongWithNull(target));
	}

	/**
	 * Get the lifetime GCW points for the specified player character
	 *
	 * @param target     the player character
	 * @return the lifetime GCW points for the specified player character
	 */
	private static native long _pvpGetLifetimeGcwPoints(long target);
	public static long pvpGetLifetimeGcwPoints(obj_id target)
	{
		return _pvpGetLifetimeGcwPoints(getLongWithNull(target));
	}

	/**
	 * Get the maximum imperial GCW rating for the specified player character
	 *
	 * @param target     the player character
	 * @return the maximum imperial GCW rating for the specified player character
	 */
	private static native int _pvpGetMaxGcwImperialRating(long target);
	public static int pvpGetMaxGcwImperialRating(obj_id target)
	{
		return _pvpGetMaxGcwImperialRating(getLongWithNull(target));
	}

	/**
	 * Get the maximum rebel GCW rating for the specified player character
	 *
	 * @param target     the player character
	 * @return the maximum rebel GCW rating for the specified player character
	 */
	private static native int _pvpGetMaxGcwRebelRating(long target);
	public static int pvpGetMaxGcwRebelRating(obj_id target)
	{
		return _pvpGetMaxGcwRebelRating(getLongWithNull(target));
	}

	/**
	 * Get the lifetime PvP kills for the specified player character
	 *
	 * @param target     the player character
	 * @return the lifetime PvP kills for the specified player character
	 */
	private static native int _pvpGetLifetimePvpKills(long target);
	public static int pvpGetLifetimePvpKills(obj_id target)
	{
		return _pvpGetLifetimePvpKills(getLongWithNull(target));
	}

	/**
	 * Get the next GCW rating recalculation time for the specified player character
	 *
	 * @param target     the player character
	 * @return the next GCW rating recalculation time for the specified player character
	 */
	private static native int _pvpGetNextGcwRatingCalcTime(long target);
	public static int pvpGetNextGcwRatingCalcTime(obj_id target)
	{
		return _pvpGetNextGcwRatingCalcTime(getLongWithNull(target));
	}

	/**
	 * sets the GCW information for the specified player character
	 *
	 * @param target     the player character
	 */
	private static native void _ctsUseOnlySetGcwInfo(long target, int currentGcwPoints, int currentGcwRating, int currentPvpKills, long lifetimeGcwPoints, int maxGcwImperialRating, int maxGcwRebelRating, int lifetimePvpKills, int nextGcwRatingCalcTime);
	public static void ctsUseOnlySetGcwInfo(obj_id target, int currentGcwPoints, int currentGcwRating, int currentPvpKills, long lifetimeGcwPoints, int maxGcwImperialRating, int maxGcwRebelRating, int lifetimePvpKills, int nextGcwRatingCalcTime)
	{
		_ctsUseOnlySetGcwInfo(getLongWithNull(target), currentGcwPoints, currentGcwRating, currentPvpKills, lifetimeGcwPoints, maxGcwImperialRating, maxGcwRebelRating, lifetimePvpKills, nextGcwRatingCalcTime);
	}

	/**
	 * gcwCategory must be defined in data/sku.0/sys.server/compiled/game/datatables/gcw/gcw_score_category.iff
	 *
	 * source is informational only and is included in the CS log for tracking purpose;
	 * for example, if a character is doing the contribution, it can be the oid and/or name
	 * of the character; if a guild is doing the contribution, it can be the guild id and/or
	 * guild name; if a player city is doing the contribution, it can be the city id and/or
	 * city name
	 *
	 * sourceOid is optional and indicates the object that's making the adjustment;
	 * it (if specified) will be used to track the object's contribution to the GCW
	 */
	private static native void _adjustGcwImperialScore(String source, long sourceOid, String gcwCategory, int adjustment);
	public static void adjustGcwImperialScore(String source, obj_id sourceOid, String gcwCategory, int adjustment)
	{
		_adjustGcwImperialScore(source, getLongWithNull(sourceOid), gcwCategory, adjustment);
	}

	private static native void _adjustGcwRebelScore(String source, long sourceOid, String gcwCategory, int adjustment);
	public static void adjustGcwRebelScore(String source, obj_id sourceOid, String gcwCategory, int adjustment)
	{
		_adjustGcwRebelScore(source, getLongWithNull(sourceOid), gcwCategory, adjustment);
	}

	/**
	 * gcwCategory must be defined in data/sku.0/sys.server/compiled/game/datatables/gcw/gcw_score_category.iff
	 *
	 * returns and int between 0 and 100 (inclusive) indicating the % that the imperial is
	 * winning/losing in the specified GCW score category; the rebel score is 100 - imperial score;
	 * 50 indicates a tie, which is also returned if the gcwCategory is not defined
	 * in data/sku.0/sys.server/compiled/game/datatables/gcw/gcw_score_category.iff
	 */
	public static native int getGcwImperialScorePercentile(String gcwCategory);

	/**
	 * gcwGroup must be defined in data/sku.0/sys.server/compiled/game/datatables/gcw/gcw_score_category.iff
	 *
	 * returns and int between 0 and 100 (inclusive) indicating the % that the imperial is
	 * winning/losing in the specified GCW group; the rebel score is 100 - imperial score;
	 * 50 indicates a tie, which is also returned if the gcwGroup is not defined
	 * in data/sku.0/sys.server/compiled/game/datatables/gcw/gcw_score_category.iff
	 */
	public static native int getGcwGroupImperialScorePercentile(String gcwGroup);

	/**
	 * Returns the dictionary containing the information about GCW factional
	 * presence activity; the information is formatted in a form suitable for
	 * displaying in a SUI table
	 *
	 * the values in the dictionary are as follows:
	 * column - string array containing the column header for the SUI table
	 * columnType - string array containing the column type for the SUI table
	 * column0 ... columnN - the string array containing the values of each
	 *     column in the SUI table, there will be as many column string array
	 *     as there are columns in the SUI table (i.e. column.length)
	*/
	public static native dictionary getGcwFactionalPresenceTableDictionary();

	/**
	 * Returns the dictionary containing the information about GCW contribution
	 * tracking for the specified player; the information is formatted in a form
	 * suitable for displaying in a SUI table
	 *
	 * the values in the dictionary are as follows:
	 * column - string array containing the column header for the SUI table
	 * columnType - string array containing the column type for the SUI table
	 * column0 ... columnN - the string array containing the values of each
	 *     column in the SUI table, there will be as many column string array
	 *     as there are columns in the SUI table (i.e. column.length)
	*/
	private static native dictionary _getGcwContributionTrackingTableDictionary(long player);
	public static dictionary getGcwContributionTrackingTableDictionary(obj_id player)
	{
		return _getGcwContributionTrackingTableDictionary(getLongWithNull(player));
	}

	/**
	 * Returns the list of GCW regions that can be a GCW defender region
	 * for the player city/guild GCW Region Defender system
	*/
	private static String[] gcwDefenderRegions = null; // cache the list, since it doesn't change

	private static native String[] _getGcwDefenderRegions();
	public static String[] getGcwDefenderRegions()
	{
		if ((gcwDefenderRegions == null) || (gcwDefenderRegions.length <= 0))
			gcwDefenderRegions = _getGcwDefenderRegions();

		return gcwDefenderRegions;
	}

	/**
	 * Returns the list of GCW Region Defender imperial cities
	 * Returns the list of GCW Region Defender rebel cities
	 * Returns the version number of the list of GCW Region Defender cities
	 *
         * the array of data will correspond with the GCW regions
         * returned from getGcwDefenderRegions()
	*/
	private static String[] gcwDefenderRegionsCitiesImperial = null; // cache the list
	private static String[] gcwDefenderRegionsCitiesRebel = null; // cache the list
	private static int gcwDefenderRegionsCitiesVersion = -1; // version number to detect stale cache

	private static native String[] _getGcwDefenderRegionsCitiesImperial();
	private static native String[] _getGcwDefenderRegionsCitiesRebel();
	private static native int getGcwDefenderRegionsCitiesVersion();

	public static String[] getGcwDefenderRegionsCitiesImperial()
	{
		final int currentVersion = getGcwDefenderRegionsCitiesVersion();
		if ((currentVersion != gcwDefenderRegionsCitiesVersion) || (gcwDefenderRegionsCitiesImperial == null) || (gcwDefenderRegionsCitiesRebel == null))
		{
			gcwDefenderRegionsCitiesImperial = _getGcwDefenderRegionsCitiesImperial();
			gcwDefenderRegionsCitiesRebel = _getGcwDefenderRegionsCitiesRebel();
			gcwDefenderRegionsCitiesVersion = currentVersion;
		}

		return gcwDefenderRegionsCitiesImperial;
	}

	public static String[] getGcwDefenderRegionsCitiesRebel()
	{
		final int currentVersion = getGcwDefenderRegionsCitiesVersion();
		if ((currentVersion != gcwDefenderRegionsCitiesVersion) || (gcwDefenderRegionsCitiesImperial == null) || (gcwDefenderRegionsCitiesRebel == null))
		{
			gcwDefenderRegionsCitiesImperial = _getGcwDefenderRegionsCitiesImperial();
			gcwDefenderRegionsCitiesRebel = _getGcwDefenderRegionsCitiesRebel();
			gcwDefenderRegionsCitiesVersion = currentVersion;
		}

		return gcwDefenderRegionsCitiesRebel;
	}

	/**
	 * Returns the list of GCW Region Defender imperial guilds
	 * Returns the list of GCW Region Defender rebel guilds
	 * Returns the version number of the list of GCW Region Defender guilds
	 *
         * the array of data will correspond with the GCW regions
         * returned from getGcwDefenderRegions()
	*/
	private static String[] gcwDefenderRegionsGuildsImperial = null; // cache the list
	private static String[] gcwDefenderRegionsGuildsRebel = null; // cache the list
	private static int gcwDefenderRegionsGuildsVersion = -1; // version number to detect stale cache

	private static native String[] _getGcwDefenderRegionsGuildsImperial();
	private static native String[] _getGcwDefenderRegionsGuildsRebel();
	private static native int getGcwDefenderRegionsGuildsVersion();

	public static String[] getGcwDefenderRegionsGuildsImperial()
	{
		final int currentVersion = getGcwDefenderRegionsGuildsVersion();
		if ((currentVersion != gcwDefenderRegionsGuildsVersion) || (gcwDefenderRegionsGuildsImperial == null) || (gcwDefenderRegionsGuildsRebel == null))
		{
			gcwDefenderRegionsGuildsImperial = _getGcwDefenderRegionsGuildsImperial();
			gcwDefenderRegionsGuildsRebel = _getGcwDefenderRegionsGuildsRebel();
			gcwDefenderRegionsGuildsVersion = currentVersion;
		}

		return gcwDefenderRegionsGuildsImperial;
	}

	public static String[] getGcwDefenderRegionsGuildsRebel()
	{
		final int currentVersion = getGcwDefenderRegionsGuildsVersion();
		if ((currentVersion != gcwDefenderRegionsGuildsVersion) || (gcwDefenderRegionsGuildsImperial == null) || (gcwDefenderRegionsGuildsRebel == null))
		{
			gcwDefenderRegionsGuildsImperial = _getGcwDefenderRegionsGuildsImperial();
			gcwDefenderRegionsGuildsRebel = _getGcwDefenderRegionsGuildsRebel();
			gcwDefenderRegionsGuildsVersion = currentVersion;
		}

		return gcwDefenderRegionsGuildsRebel;
	}

	/**
	 * Returns the list of imperial cities defending the GCW region
	 * Returns the list of rebel cities defending the GCW region
	 * Returns the list of imperial guilds defending the GCW region
	 * Returns the list of rebel guilds defending the GCW region
	*/
	public static native int[] getGcwDefenderRegionCitiesImperial(String gcwCategory);
	public static native int[] getGcwDefenderRegionCitiesRebel(String gcwCategory);
	public static native int[] getGcwDefenderRegionGuildsImperial(String gcwCategory);
	public static native int[] getGcwDefenderRegionGuildsRebel(String gcwCategory);

	/**
	 * Returns the current bonus % for each imperial city/guild defending the GCW region
	 * Returns the current bonus % for each rebel city/guild defending the GCW region
	*/
	public static native float getGcwDefenderRegionImperialBonus(String gcwCategory);
	public static native float getGcwDefenderRegionRebelBonus(String gcwCategory);

    /**
     * Returns the master object at the center of a battlefield.
     *
     * @param battlefieldRegion the region for the battlefield
     * @return the id of the master object
     */
    private static native long _getBattlefieldRegionMasterObject(region battlefieldRegion);
    public static obj_id getBattlefieldRegionMasterObject(region battlefieldRegion)
    {
        return getObjIdWithNull(_getBattlefieldRegionMasterObject(battlefieldRegion));
    }
    /**
     * Sets the name of the region to associate a battlefield marker with.
     * @param marker  the battlefield marker object
     * @param regionName  the name of the battlefield region
     */
    private static native void _setBattlefieldMarkerRegionName(long marker, String regionName);
    public static void setBattlefieldMarkerRegionName(obj_id marker, String regionName)
    {
        _setBattlefieldMarkerRegionName(getLongWithNull(marker), regionName);
    }
    /*@}*/

    /**
     * @defgroup guild guild methods
     */
    /*@{*/
    /**
     * Get the id for the guild a creature is in.
     *
     * @param target  the creature to check
     * @return the guild id or 0 if none
     */
    private static native int _getGuildId(long target);
    public static int getGuildId(obj_id target)
    {
        return _getGuildId(getLongWithNull(target));
    }
    /**
     * Get the ids of all guilds that exist.
     *
     * @return the array of guild ids
     */
    public static native int[] getAllGuildIds();
    /**
     * Get the master guild object
     *
     * @return the master guild object
     */
    private static native long _getMasterGuildObject();
    public static obj_id getMasterGuildObject()
    {
        return getObjIdWithNull(_getMasterGuildObject());
    }
    /**
     * Get the ids of all guilds which have declared war on the specified guild.
     *
     * @param guildId the id of the guild to find enemies for
     * @return the array of ids for guilds that have declared war on guildId
     */
    public static native int[] getGuildsAtWarWith(int guildId);
    /**
     * Returns the dictionary containing the information about all active
     * guild wars with at least 1 kill; the information is formatted in
     * a form suitable for displaying in a SUI table
     *
     * the values in the dictionary are as follows:
     * column - string array containing the column header for the SUI table
     * columnType - string array containing the column type for the SUI table
     * column0 ... columnN - the string array containing the values of each
     *     column in the SUI table, there will be as many column string array
     *     as there are columns in the SUI table (i.e. column.length)
     */
    public static native dictionary getMasterGuildWarTableDictionary();
    /**
     * Returns the dictionary containing the information about the 100 most
     * recently ended guild wars with at least 1 kill; the information is
     * formatted in a form suitable for displaying in a SUI table
     *
     * the values in the dictionary are as follows:
     * column - string array containing the column header for the SUI table
     * columnType - string array containing the column type for the SUI table
     * column0 ... columnN - the string array containing the values of each
     *     column in the SUI table, there will be as many column string array
     *     as there are columns in the SUI table (i.e. column.length)
     */
    public static native dictionary getInactiveGuildWarTableDictionary();
    /**
     * Find the id of a guild given its name or abbreviation.
     *
     * @param name the name or abbreviation of a guild to find
     * @return the guild id if a match is found, or 0 if not.
     */
    public static native int findGuild(String name);
    /**
     * Create a guild.
     *
     * @param name the name of the new guild
     * @param abbrev the abbreviation of the new guild
     * @return the guildId of the new guild, or 0 if name or abbrev was invalid
     */
    public static native int createGuild(String name, String abbrev);
    /**
     * Disband a guild.
     *
     * @param guildId the id of the guild to disband
     */
    public static native void disbandGuild(int guildId);
    /**
     * Check whether a guild still exists.
     *
     * @param guildId the id of the guild to check
     * @return whether the guild still exists
     */
    public static native boolean guildExists(int guildId);
    /**
     * Get the name of a guild.
     *
     * @param guildId the id of the guild to check
     * @return the guild name
     */
    public static native String guildGetName(int guildId);
    /**
     * Get the abbreviation of a guild.
     *
     * @param guildId the id of the guild to check
     * @return the guild abbreviation
     */
    public static native String guildGetAbbrev(int guildId);
    /**
     * Get the current leader of a guild.
     *
     * @param guildId the id of the guild to check
     * @return the guild leader's id
     */
    private static native long _guildGetLeader(int guildId);
    public static obj_id guildGetLeader(int guildId)
    {
        return getObjIdWithNull(_guildGetLeader(guildId));
    }
    /**
     * Get the guild's election previous end time and next end time in calendar time
     *
     * @param guildId the id of the guild to check
     */
    public static native int guildGetElectionPreviousEndTime(int guildId);
    public static native int guildGetElectionNextEndTime(int guildId);
    /**
     * Get the guild's current factional alignment
     *
     * If the guild is not currently aligned, get the guild's most recent factional alignment
     *
     * If the guild is not currently aligned, get the time that the guild left the most recent factional alignment
     *
     * @param guildId the id of the guild to get
     */
    public static native int guildGetCurrentFaction(int guildId);
    public static native int guildGetPreviousFaction(int guildId);
    public static native int guildGetTimeLeftPreviousFaction(int guildId);
    /**
     * Get the guild's current GCW defender region
     *
     * If the guild has a current GCW defender region, get the time the guild joined the current GCW defender region
     *
     * If the guild doesn't have a current GCW defender region, get the guild's most recently joined GCW defender region
     *
     * If the guild doesn't have a current GCW defender region, get the time the guild left the most recently joined GCW defender region
     *
     * @param guildId the id of the guild to get
     */
    public static native String guildGetCurrentGcwDefenderRegion(int guildId);
    public static native int guildGetTimeJoinedCurrentGcwDefenderRegion(int guildId);
    public static native String guildGetPreviousGcwDefenderRegion(int guildId);
    public static native int guildGetTimeLeftPreviousGcwDefenderRegion(int guildId);
    /**
     * Get the ids of all members of a guild - this includes people sponsored for membership.
     *
     * @param guildId the id of the guild to check
     * @return the array of member ids
     */
    private static native long[] _guildGetMemberIds(int guildId);
    public static obj_id[] guildGetMemberIds(int guildId)
    {
        long[] _ret_long = _guildGetMemberIds(guildId);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get the ids of all members of a guild who have the specified permisions;
     * guild.GUILD_PERMISSIONS_NONE (i.e. 0) just for people sponsored for membership.
     *
     * @param guildId the id of the guild to check
     * @return the array of member ids
     */
    private static native long[] _guildGetMemberIdsWithPermissions(int guildId, int permissions);
    public static obj_id[] guildGetMemberIdsWithPermissions(int guildId, int permissions)
    {
        long[] _ret_long = _guildGetMemberIdsWithPermissions(guildId, permissions);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Returns the number of members (excluding sponsored) in the guild;
     * Returns the number of sponsored in the guild;
     * Returns the number of members + spnosored in the guild;
     * Returns the number of members in the guild who are guild war PvP enabled
     *
     * @param guildId the id of the guild to check
     */
    public static native int guildGetCountMembersOnly(int guildId);
    public static native int guildGetCountSponsoredOnly(int guildId);
    public static native int guildGetCountMembersAndSponsored(int guildId);
    public static native int guildGetCountMembersGuildWarPvPEnabled(int guildId);
    /**
     * Get the name of a guild member.
     *
     * @param guildId the id of the guild to check
     * @param member the id of the member to check
     * @return the name of the guild member
     */
    private static native String _guildGetMemberName(int guildId, long member);
    public static String guildGetMemberName(int guildId, obj_id member)
    {
        return _guildGetMemberName(guildId, getLongWithNull(member));
    }

    /**
     * Get the profession of a guild member.
     *
     * @param guildId the id of the guild to check
     * @param member the id of the member to check
     * @return the profession of the guild member, which has a very likely chance of
     *         being null or empty, as this information requires that the guild member
     *         logs in at least once after this functionality is enabled in order
     *         to populate the information, and some guild members have long been
     *         deleted and purged from the DB, so they will never populate this
     *         information
     */
    private static native String _guildGetMemberProfession(int guildId, long member);
    public static String guildGetMemberProfession(int guildId, obj_id member)
    {
        return _guildGetMemberProfession(guildId, getLongWithNull(member));
    }

    /**
     * Get the level of a guild member.
     *
     * @param guildId the id of the guild to check
     * @param member the id of the member to check
     * @return the level of the guild member, which will be 0 if the information
     *         is not available, which has a very likely chance of happening,
     *         as this information requires that the guild member logs in at
     *         least once after this functionality is enabled in order to
     *         populate the information, and some guild members have long been
     *         deleted and purged from the DB, so they will never populate this
     *         information
     */
    private static native int _guildGetMemberLevel(int guildId, long member);
    public static int guildGetMemberLevel(int guildId, obj_id member)
    {
        return _guildGetMemberLevel(guildId, getLongWithNull(member));
    }

    /**
     * Get the permissions of a guild member.
     *
     * @param guildId the id of the guild to check
     * @param member the id of the member to check
     * @return the permissions of the guild member
     */
    private static native int _guildGetMemberPermissions(int guildId, long member);
    public static int guildGetMemberPermissions(int guildId, obj_id member)
    {
        return _guildGetMemberPermissions(guildId, getLongWithNull(member));
    }
    /**
     * Get the title of a guild member.
     *
     * @param guildId the id of the guild to check
     * @param member the id of the member to check
     * @return the title of the guild member
     */
    private static native String _guildGetMemberTitle(int guildId, long member);
    public static String guildGetMemberTitle(int guildId, obj_id member)
    {
        return _guildGetMemberTitle(guildId, getLongWithNull(member));
    }
    /**
     * Get the allegiance of a guild member.
     *
     * @param guildId the id of the guild to check
     * @param member the id of the member to check
     * @return the id of the person the member's allegiance is set to
     */
    private static native long _guildGetMemberAllegiance(int guildId, long member);
    public static obj_id guildGetMemberAllegiance(int guildId, obj_id member)
    {
        return getObjIdWithNull(_guildGetMemberAllegiance(guildId, getLongWithNull(member)));
    }
    /**
     * Get the ids of guilds the specified guild has declared war on.
     *
     * @param guildId the id of the guild to check
     * @return the array of ids for guilds the specified guild has declared war on
     */
    public static native int[] guildGetEnemies(int guildId);
    /**
     * Remove a member from a guild.
     *
     * @param guildId the id of the guild to remove from
     * @param member the id of the member to remove
     */
    private static native void _guildRemoveMember(int guildId, long member);
    public static void guildRemoveMember(int guildId, obj_id member)
    {
        _guildRemoveMember(guildId, getLongWithNull(member));
    }

    /**
     * Add the first guild member (i.e. the guild creator) to a newly created guild
     *
     */
    private static native void _guildAddCreatorMember(int guildId, long member);
    public static void guildAddCreatorMember(int guildId, obj_id member)
    {
        _guildAddCreatorMember(guildId, getLongWithNull(member));
    }

    /**
     * Add a sponsored member to a guild.  Sponsoring is the only way to add additional members to a guild
     *
     */
    private static native void _guildAddSponsorMember(int guildId, long member);
    public static void guildAddSponsorMember(int guildId, obj_id member)
    {
        _guildAddSponsorMember(guildId, getLongWithNull(member));
    }

    /**
     * Set/change a guild member's permission, which is also the way to make a sponsored guild member a full guild member
     *
     */
    private static native void _guildSetMemberPermission(int guildId, long member, int permissions);
    public static void guildSetMemberPermission(int guildId, obj_id member, int permissions)
    {
        _guildSetMemberPermission(guildId, getLongWithNull(member), permissions);
    }

    /**
     * Set/change a guild member's title
     *
     */
    private static native void _guildSetMemberTitle(int guildId, long member, String title);
    public static void guildSetMemberTitle(int guildId, obj_id member, String title)
    {
        _guildSetMemberTitle(guildId, getLongWithNull(member), title);
    }

    /**
     * Set/change a guild member's allegiance
     *
     */
    private static native void _guildSetMemberAllegiance(int guildId, long member, long allegiance);
    public static void guildSetMemberAllegiance(int guildId, obj_id member, obj_id allegiance)
    {
        _guildSetMemberAllegiance(guildId, getLongWithNull(member), getLongWithNull(allegiance));
    }

    /**
     * Set/change a guild member's permission and allegiance
     * only use this function if you need to set/change BOTH
     * information at the same time, otherwise, use the functions
     * taht sets/changes the individual information
     *
     */
    private static native void _guildSetMemberPermissionAndAllegiance(int guildId, long member, int permissions, long allegiance);
    public static void guildSetMemberPermissionAndAllegiance(int guildId, obj_id member, int permissions, obj_id allegiance)
    {
        _guildSetMemberPermissionAndAllegiance(guildId, getLongWithNull(member), permissions, getLongWithNull(allegiance));
    }

    /**
     * Get all the possible guild ranks
     */
    public static native String[] guildGetAllRanks();
    /**
     * Get all the possible title(s) available for a given guild rank
     */
    public static native String[] guildGetTitleForRank(String rank);
    /**
     * Get the guild rank(s) for a member of a guild
     *
     * @param guildId the id of the guild
     * @param member the id of the member to get rank(s) for
     */
    private static native String[] _guildGetMemberRank(int guildId, long member);
    public static String[] guildGetMemberRank(int guildId, obj_id member)
    {
        return _guildGetMemberRank(guildId, getLongWithNull(member));
    }
    /**
     * Checks to see if a guild member has the specified guild rank
     *
     * @param guildId the id of the guild
     * @param member the id of the member to check rank for
     * @param rank the guild rank to check for
     */
    private static native boolean _guildHasMemberRank(int guildId, long member, String rank);
    public static boolean guildHasMemberRank(int guildId, obj_id member, String rank)
    {
        return _guildHasMemberRank(guildId, getLongWithNull(member), rank);
    }
    /**
     * Add a guild rank for a member of a guild
     *
     * @param guildId the id of the guild
     * @param member the id of the member to add rank for
     * @param rank the guild rank to add for the member
     */
    private static native void _guildAddMemberRank(int guildId, long member, String rank);
    public static void guildAddMemberRank(int guildId, obj_id member, String rank)
    {
        _guildAddMemberRank(guildId, getLongWithNull(member), rank);
    }
    /**
     * Remove a guild rank from a member of a guild
     *
     * @param guildId the id of the guild
     * @param member the id of the member to remove rank from
     * @param rank the guild rank to remove from the member
     */
    private static native void _guildRemoveMemberRank(int guildId, long member, String rank);
    public static void guildRemoveMemberRank(int guildId, obj_id member, String rank)
    {
        _guildRemoveMemberRank(guildId, getLongWithNull(member), rank);
    }
    /**
     * Set who the leader of a guild is.
     *
     * @param guildId the id of the guild
     * @param leader the id of the new leader
     */
    private static native void _guildSetLeader(int guildId, long leader);
    public static void guildSetLeader(int guildId, obj_id leader)
    {
        _guildSetLeader(guildId, getLongWithNull(leader));
    }
    /**
     * Set the guild's election previous end time and next end time in calendar time
     *
     * @param guildId the id of the guild to check
     */
    public static native void guildSetElectionEndTime(int guildId, int electionPreviousEndTime, int electionNextEndTime);
    /**
     * Set the guild's factional alignment
     *
     * @param guildId the id of the guild to set
     */
    public static native void guildSetFaction(int guildId, int factionId);
    /**
     * Set the guild's GCW defender region
     *
     * @param guildId the id of the guild to set
     */
    public static native void guildSetGcwDefenderRegion(int guildId, String gcwDefenderRegion);
    /**
     * Cancel a declaration of war on a guild.
     *
     * @param guildId the id of the guild removing the declaration
     * @param enemyId the id of the guild to no longer be at war with
     */
    public static native void guildRemoveEnemy(int guildId, int enemyId);
    /**
     * Declare war on another guild.
     *
     * @param guildId the id of the guild declaring war
     * @param enemyId the id of the guild war is being declared on
     */
    public static native void guildSetEnemy(int guildId, int enemyId);
    /**
     * If necessary, update the guild war kill
     * tracking for the specified PvP kill
     */
    private static native void _guildUpdateGuildWarKillTracking(long killer, long victim);
    public static void guildUpdateGuildWarKillTracking(obj_id killer, obj_id victim)
    {
        _guildUpdateGuildWarKillTracking(getLongWithNull(killer), getLongWithNull(victim));
    }
    /**
     * If guild A and guild B are currently at war, return the number of kills that guild
     * A has made on guild B and the calendar time when the information was last updated
     */
    public static native int guildGetGuildWarKillCount(int guildIdA, int guildIdB);
    public static native int guildGetGuildWarKillCountUpdateTime(int guildIdA, int guildIdB);
    /**
     * Set the name of a guild.
     *
     * @param guildId the id of the guild
     * @param name the new name for the guild
     */
    public static native void guildSetName(int guildId, String name);
    /**
     * Set the abbreviation of a guild.
     *
     * @param guildId the id of the guild
     * @param abbrev the new abbreviation for the guild
     */
    public static native void guildSetAbbrev(int guildId, String abbrev);
    /*@}*/

    /**
     * @defgroup city player city methods
     */
    /*@{*/
    private static native int _getCitizenOfCityId(long target);
    public static int getCitizenOfCityId(obj_id target)
    {
        return _getCitizenOfCityId(getLongWithNull(target));
    }
    private static native int _getLocatedInCityId(long target);
    public static int getLocatedInCityId(obj_id target)
    {
        return _getLocatedInCityId(getLongWithNull(target));
    }
    private static native int _getMilitiaOfCityId(long target);
    public static int getMilitiaOfCityId(obj_id target)
    {
        return _getMilitiaOfCityId(getLongWithNull(target));
    }
    public static native int[] getAllCityIds();
    private static native long _getMasterCityObject();
    public static obj_id getMasterCityObject()
    {
        return getObjIdWithNull(_getMasterCityObject());
    }
    public static native int findCityByName(String cityName);
    private static native int _findCityByCityHall(long cityHallId);
    public static int findCityByCityHall(obj_id cityHallId)
    {
        return _findCityByCityHall(getLongWithNull(cityHallId));
    }
    public static native int getCityAtLocation(location cityLocation, int radius);
    private static native int _createCity(String cityName, long cityHallId, location cityLocation, int radius, long leaderId, int incomeTax, int propertyTax, int salesTax, location travelLocation, int travelCost, boolean travelInterplanetary, location cloneLoc, location cloneRespawn, long cloneId);
    public static int createCity(String cityName, obj_id cityHallId, location cityLocation, int radius, obj_id leaderId, int incomeTax, int propertyTax, int salesTax, location travelLocation, int travelCost, boolean travelInterplanetary, location cloneLoc, location cloneRespawn, obj_id cloneId)
    {
        return _createCity(cityName, getLongWithNull(cityHallId), cityLocation, radius, getLongWithNull(leaderId), incomeTax, propertyTax, salesTax, travelLocation, travelCost, travelInterplanetary, cloneLoc, cloneRespawn, getLongWithNull(cloneId));
    }
    public static native void removeCity(int cityId);
    public static native boolean cityExists(int cityId);
    public static native String cityGetName(int cityId);
    private static native long _cityGetCityHall(int cityId);
    public static obj_id cityGetCityHall(int cityId)
    {
        return getObjIdWithNull(_cityGetCityHall(cityId));
    }
    public static native location cityGetLocation(int cityId);
    public static native int cityGetRadius(int cityId);
    public static native int cityGetFaction(int cityId);
    public static native String cityGetGcwDefenderRegion(int cityId);
    public static native int cityGetTimeJoinedGcwDefenderRegion(int cityId);
    public static native int cityGetCreationTime(int cityId);
    private static native long _cityGetLeader(int cityId);
    public static obj_id cityGetLeader(int cityId)
    {
        return getObjIdWithNull(_cityGetLeader(cityId));
    }
    public static native int cityGetIncomeTax(int cityId);
    public static native int cityGetPropertyTax(int cityId);
    public static native int cityGetSalesTax(int cityId);
    public static native location cityGetTravelLocation(int cityId);
    public static native int cityGetTravelCost(int cityId);
    public static native boolean cityGetTravelInterplanetary(int cityId);
    public static native location cityGetCloneLoc(int cityId);
    public static native location cityGetCloneRespawn(int cityId);
    private static native long _cityGetCloneId(int cityId);
    public static obj_id cityGetCloneId(int cityId)
    {
        return getObjIdWithNull(_cityGetCloneId(cityId));
    }
    private static native long[] _cityGetCitizenIds(int cityId);
    public static obj_id[] cityGetCitizenIds(int cityId)
    {
        long[] _ret_long = _cityGetCitizenIds(cityId);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    public static native int cityGetCitizenCount(int cityId);
    private static native String _cityGetCitizenName(int cityId, long citizenId);
    public static String cityGetCitizenName(int cityId, obj_id citizenId)
    {
        return _cityGetCitizenName(cityId, getLongWithNull(citizenId));
    }
    /**
     * Get the profession of a citizen.
     *
     * @param cityId the id of the city to check
     * @param citizenId the id of the citizen to check
     * @return the profession of the citizen, which has a very likely chance of
     *         being null or empty, as this information requires that the citizen
     *         logs in at least once after this functionality is enabled in order
     *         to populate the information, and some citizens have long been
     *         deleted and purged from the DB, so they will never populate this
     *         information
     */
    private static native String _cityGetCitizenProfession(int cityId, long citizenId);
    public static String cityGetCitizenProfession(int cityId, obj_id citizenId)
    {
        return _cityGetCitizenProfession(cityId, getLongWithNull(citizenId));
    }
    /**
     * Get the level of a citizen.
     *
     * @param cityId the id of the city to check
     * @param citizenId the id of the citizen to check
     * @return the level of the citizen, which will be 0 if the information
     *         is not available, which has a very likely chance of happening,
     *         as this information requires that the citizen logs in at
     *         least once after this functionality is enabled in order to
     *         populate the information, and some citizens have long been
     *         deleted and purged from the DB, so they will never populate this
     *         information
     */
    private static native int _cityGetCitizenLevel(int cityId, long citizenId);
    public static int cityGetCitizenLevel(int cityId, obj_id citizenId)
    {
        return _cityGetCitizenLevel(cityId, getLongWithNull(citizenId));
    }
    private static native String _cityGetCitizenTitle(int cityId, long citizenId);
    public static String cityGetCitizenTitle(int cityId, obj_id citizenId)
    {
        return _cityGetCitizenTitle(cityId, getLongWithNull(citizenId));
    }
    private static native long _cityGetCitizenAllegiance(int cityId, long citizenId);
    public static obj_id cityGetCitizenAllegiance(int cityId, obj_id citizenId)
    {
        return getObjIdWithNull(_cityGetCitizenAllegiance(cityId, getLongWithNull(citizenId)));
    }
    private static native int _cityGetCitizenPermissions(int cityId, long citizenId);
    public static int cityGetCitizenPermissions(int cityId, obj_id citizenId)
    {
        return _cityGetCitizenPermissions(cityId, getLongWithNull(citizenId));
    }
    private static native long[] _cityGetStructureIds(int cityId);
    public static obj_id[] cityGetStructureIds(int cityId)
    {
        long[] _ret_long = _cityGetStructureIds(cityId);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    private static native int _cityGetStructureType(int cityId, long structureId);
    public static int cityGetStructureType(int cityId, obj_id structureId)
    {
        return _cityGetStructureType(cityId, getLongWithNull(structureId));
    }
    private static native boolean _cityGetStructureValid(int cityId, long structureId);
    public static boolean cityGetStructureValid(int cityId, obj_id structureId)
    {
        return _cityGetStructureValid(cityId, getLongWithNull(structureId));
    }
    public static native void citySetName(int cityId, String cityName);
    private static native void _citySetCityHall(int cityId, long cityHallId);
    public static void citySetCityHall(int cityId, obj_id cityHallId)
    {
        _citySetCityHall(cityId, getLongWithNull(cityHallId));
    }
    public static native void citySetLocation(int cityId, location cityLocation);
    public static native void citySetRadius(int cityId, int radius);
    public static native void citySetFaction(int cityId, int factionId, boolean notifyCitizens);
    public static native void citySetGcwDefenderRegion(int cityId, String gcwDefenderRegion, int timeJoined, boolean notifyCitizens);
    private static native void _citySetLeader(int cityId, long leaderId);
    public static void citySetLeader(int cityId, obj_id leaderId)
    {
        _citySetLeader(cityId, getLongWithNull(leaderId));
    }
    public static native void citySetIncomeTax(int cityId, int incomeTax);
    public static native void citySetPropertyTax(int cityId, int incomeTax);
    public static native void citySetSalesTax(int cityId, int incomeTax);
    public static native void citySetTravelInfo(int cityId, location travelLocation, int travelCost, boolean travelInterplanetary);
    private static native void _citySetCloneInfo(int cityId, location cloneLoc, location cloneRespawn, long cloneId);
    public static void citySetCloneInfo(int cityId, location cloneLoc, location cloneRespawn, obj_id cloneId)
    {
        _citySetCloneInfo(cityId, cloneLoc, cloneRespawn, getLongWithNull(cloneId));
    }
    private static native void _citySetCitizenInfo(int cityId, long citizenId, String citizenName, long allegiance, int permissions);
    public static void citySetCitizenInfo(int cityId, obj_id citizenId, String citizenName, obj_id allegiance, int permissions)
    {
        _citySetCitizenInfo(cityId, getLongWithNull(citizenId), citizenName, getLongWithNull(allegiance), permissions);
    }
    private static native void _citySetCitizenTitle(int cityId, long citizenId, String title);
    public static void citySetCitizenTitle(int cityId, obj_id citizenId, String title)
    {
        _citySetCitizenTitle(cityId, getLongWithNull(citizenId), title);
    }
    /**
     * Get all the possible citizen ranks
     */
    public static native String[] cityGetAllCitizenRanks();
    /**
     * Get all the possible title(s) available for a given citizen rank
     */
    public static native String[] cityGetTitleForCitizenRank(String rank);
    /**
     * Get the citizen rank(s) for a citizen
     *
     * @param cityId the id of the city
     * @param citizenId the id of the citizen to get rank(s) for
     */
    private static native String[] _cityGetCitizenRank(int cityId, long citizenId);
    public static String[] cityGetCitizenRank(int cityId, obj_id citizenId)
    {
        return _cityGetCitizenRank(cityId, getLongWithNull(citizenId));
    }
    /**
     * Checks to see if a citizen has the specified citizen rank
     *
     * @param cityId the id of the city
     * @param citizenId the id of the citizen to check rank for
     * @param rank the citizen rank to check for
     */
    private static native boolean _cityHasCitizenRank(int cityId, long citizenId, String rank);
    public static boolean cityHasCitizenRank(int cityId, obj_id citizenId, String rank)
    {
        return _cityHasCitizenRank(cityId, getLongWithNull(citizenId), rank);
    }
    /**
     * Add a citizen rank for a citizen
     *
     * @param cityId the id of the city
     * @param citizenId the id of the citizen to add rank for
     * @param rank the citizen rank to add for the citizen
     */
    private static native void _cityAddCitizenRank(int cityId, long citizenId, String rank);
    public static void cityAddCitizenRank(int cityId, obj_id citizenId, String rank)
    {
        _cityAddCitizenRank(cityId, getLongWithNull(citizenId), rank);
    }
    /**
     * Remove a citizen rank from a citizen
     *
     * @param cityId the id of the city
     * @param citizenId the id of the citizen to remove rank from
     * @param rank the citizen rank to remove from the citizen
     */
    private static native void _cityRemoveCitizenRank(int cityId, long citizenId, String rank);
    public static void cityRemoveCitizenRank(int cityId, obj_id citizenId, String rank)
    {
        _cityRemoveCitizenRank(cityId, getLongWithNull(citizenId), rank);
    }
    private static native void _citySetStructureInfo(int cityId, long structureId, int structureType, boolean structureValid);
    public static void citySetStructureInfo(int cityId, obj_id structureId, int structureType, boolean structureValid)
    {
        _citySetStructureInfo(cityId, getLongWithNull(structureId), structureType, structureValid);
    }
    private static native void _cityRemoveCitizen(int cityId, long citizenId);
    public static void cityRemoveCitizen(int cityId, obj_id citizenId)
    {
        _cityRemoveCitizen(cityId, getLongWithNull(citizenId));
    }
    private static native void _cityRemoveStructure(int cityId, long structureId);
    public static void cityRemoveStructure(int cityId, obj_id structureId)
    {
        _cityRemoveStructure(cityId, getLongWithNull(structureId));
    }
    public static native boolean cityIsInactivePackupActive();
    public static native int cityGetInactivePackupInactiveTimeSeconds();
    /*@}*/

    /**
     * @defgroup account PlayerObject/account methods
     */
    /*@{*/
    /**
     * Find the PlayerObject given the player's avatar
     * @param avatar        the object the player controls (usually a CreatureObject)
     * @return              the obj_id of the PlayerObject representing the player & account data
     */
    private static native long _getPlayerObject(long avatar);
    public static obj_id getPlayerObject(obj_id avatar)
    {
        return getObjIdWithNull(_getPlayerObject(getLongWithNull(avatar)));
    }
    /**
     * Check if a player is ignoring someone
     * @param player  the player object to check ignores on
     * @param who     name of the person to look for
     * @return        whether the person is being ignored
     */
    private static native boolean _isIgnoring(long player, String who);
    public static boolean isIgnoring(obj_id player, String who)
    {
        return _isIgnoring(getLongWithNull(player), who);
    }

    /**
     * Adjust the count of the number of lots used by an account
     * @param player The PlayerObject (not the creature representing the character, use getPlayerObject() to get the PlayerObject from the creature)
     * @param amount Amount to adjust the count by.  Can be positive or negative
     * @return       true if the adjustment went through, false if it would have put the player over the lot limit
     */
    private static native boolean _adjustLotCount(long player, int amount);
    public static boolean adjustLotCount(obj_id player, int amount)
    {
        return _adjustLotCount(getLongWithNull(player), amount);
    }

    /**
     * Find out how many lots an account is currently using
     * @param player The PlayerObject (not the creature representing the character, use getPlayerObject() to get the PlayerObject from the creature)
     * @return       The number of lots in use.
     */
    private static native int _getAccountNumLots(long player);
    public static int getAccountNumLots(obj_id player)
    {
        return _getAccountNumLots(getLongWithNull(player));
    }
    /**
     * Find out what game features this player has purchased
     * @param player The player (creature object)
     * @return       A 32bit bit-vector indicating the game features this player has purchased.
     */
    private static native int _getGameFeatureBits(long player);
    public static int getGameFeatureBits(obj_id player)
    {
        return _getGameFeatureBits(getLongWithNull(player));
    }
    /**
         * Find out what subscription features this player has purchased
         * @param player The player (creature object)
         * @return       A 32bit bit-vector indicating the subscription features this player has purchased.
     */
    private static native int _getSubscriptionFeatureBits(long player);
    public static int getSubscriptionFeatureBits(obj_id player)
    {
        return _getSubscriptionFeatureBits(getLongWithNull(player));
    }
    /**
         * Find out if this player is from a free trial account
         * @param player The player (creature object)
         * @return       boolean, yes if it is a free trial, false otherwise
     */
    private static native boolean _isFreeTrialAccount(long player);
    public static boolean isFreeTrialAccount(obj_id player)
    {
        return _isFreeTrialAccount(getLongWithNull(player));
    }
    /**
         * Set this player's station id with the desired completed tutorial boolean
         * @param player The player (creature object)
         * @param value the desired value to set the bit to
     */
    private static native boolean _setCompletedTutorial(long player, boolean value);
    public static boolean setCompletedTutorial(obj_id player, boolean value)
    {
        return _setCompletedTutorial(getLongWithNull(player), value);
    }
    /**
     * Test whether a player is actually a CSR using the Admin Login feature to access the account
     */
    private static native boolean _isUsingAdminLogin(long player);
    public static boolean isUsingAdminLogin(obj_id player)
    {
        return _isUsingAdminLogin(getLongWithNull(player));
    }
    /**
     * Test whether a player a Warden
     */
    private static native boolean _isWarden(long player);
    public static boolean isWarden(obj_id player)
    {
        return _isWarden(getLongWithNull(player));
    }
    /**
     */
    private static native void __logActivity(long player, int activityType);
    public static void _logActivity(obj_id player, int activityType)
    {
        __logActivity(getLongWithNull(player), activityType);
    }
    /**
     * Check if character belongs to an account that qualifies for the current stage of structure packup
     * @param target The player (creature object)
     * @return       true if the player qualifies
     */
    private static native boolean _isAccountQualifiedForHousePackup(long target);
    public static boolean isAccountQualifiedForHousePackup(obj_id target)
    {
        return _isAccountQualifiedForHousePackup(getLongWithNull(target));
    }

    /**
     * Gets the CTS history of the specified character
     *
     * @returns a dictionary that contains the following data in paralled arrays
     * with the oldest CTS transaction first and the newest CTS transaction last
     *
     * @returns null if the character doesn't have any CTS history
     *
     * string[] character_name        full name of the source character
     * string[] cluster_name          name of the source cluster
     * int[]    transfer_time         calendar time of the transfer
    */
    private static native dictionary _getCharacterCtsHistory(long player);
    public static dictionary getCharacterCtsHistory(obj_id player)
    {
        return _getCharacterCtsHistory(getLongWithNull(player));
    }

    /**
     * Gets the retroactive CTS objvars history of the specified character
     *
     * @returns an array of dictionaries each of which contains the retroactive CTS objvars
     * for the particular CTS source character that this character at one time transferred from
     * with the oldest CTS transaction first and the newest CTS transaction last
     *
     * @returns null if the character doesn't have any retroactive CTS objvars history
    */
    private static native dictionary[] _getCharacterRetroactiveCtsObjvars(long player);
    public static dictionary[] getCharacterRetroactiveCtsObjvars(obj_id player)
    {
        return _getCharacterRetroactiveCtsObjvars(getLongWithNull(player));
    }

    /**
     * Checks to see if the specified character qualifies for free CTS
     *
     * @returns an array of strings containing the galaxies to which this character can transfer for free
    */
    private static native String[] _qualifyForFreeCts(long player);
    public static String[] qualifyForFreeCts(obj_id player)
    {
        return _qualifyForFreeCts(getLongWithNull(player));
    }

    /**
     * Validate the free CTS information and messageTo back to the object to indicate status of the validation
    */
    private static native void _validateFreeCts(long player, String destinationGalaxy, String destinationCharacterName);
    public static void validateFreeCts(obj_id player, String destinationGalaxy, String destinationCharacterName)
    {
        _validateFreeCts(getLongWithNull(player), destinationGalaxy, destinationCharacterName);
    }

    /**
     * Validate the free CTS information and initiate the transfer process if the validation passes, or
     * messageTo back to the object to indicate status of the validation if the validation fails
    */
    private static native void _performFreeCts(long player, String destinationGalaxy, String destinationCharacterName);
    public static void performFreeCts(obj_id player, String destinationGalaxy, String destinationCharacterName)
    {
        _performFreeCts(getLongWithNull(player), destinationGalaxy, destinationCharacterName);
    }

    /**
     * Validate the CTS information and messageTo back to the object to indicate status of the validation
    */
    private static native void _validateCts(long player, String destinationGalaxy, String destinationCharacterName);
    public static void validateCts(obj_id player, String destinationGalaxy, String destinationCharacterName)
    {
        _validateCts(getLongWithNull(player), destinationGalaxy, destinationCharacterName);
    }

    /**
     * Validate the CTS information and initiate the transfer process if the validation passes, or
     * messageTo back to the object to indicate status of the validation if the validation fails
    */
    private static native void _performCts(long player, String destinationGalaxy, String destinationCharacterName);
    public static void performCts(obj_id player, String destinationGalaxy, String destinationCharacterName)
    {
        _performCts(getLongWithNull(player), destinationGalaxy, destinationCharacterName);
    }

    /**
     * Validate the new character name for the rename operation and messageTo back to the object to indicate status of the validation
    */
    private static native void _validateRenameCharacter(long player, String newName);
    public static void validateRenameCharacter(obj_id player, String newName)
    {
        _validateRenameCharacter(getLongWithNull(player), newName);
    }

    /**
     * Release the character name that had been reserved for renaming the specified character; the character
     * name is reserved during the character rename process, even if the name doesn't end up being used,
     * so we want to return the name back to the pool; just make sure you don't call this function during
     * the character rename process, or before the character rename process has completed
    */
    private static native void _renameCharacterReleaseNameReservation(long player);
    public static void renameCharacterReleaseNameReservation(obj_id player)
    {
        _renameCharacterReleaseNameReservation(getLongWithNull(player));
    }

    /**
     * submit request to rename characer; the name is assumed to have already been validated with validateRenameCharacter()
    */
    private static native void _renameCharacter(long player, String newName);
    public static void renameCharacter(obj_id player, String newName)
    {
        _renameCharacter(getLongWithNull(player), newName);
    }

    /**
     * Get the station id of the player
     * @param player the player
     * @return       the station id
     */
    private static native int _getPlayerStationId(long player);
    public static int getPlayerStationId(obj_id player)
    {
        return _getPlayerStationId(getLongWithNull(player));
    }

    /**
    * Returns info on how long a player has been playing the game.
    *
    * @param env        Java environment
    * @param self       class calling this function
    * @param player     the id of the player
    *
    * @return a dictionary with the player's account time info:
    *       "total_subscription_time"     the total amount of time since the player first subscribed
    *       "total_entitled_time"         the total amount of time the player has been billed
    *       "last_login_time"             the amount of time passed since the player last logged in
    *       "entitled_login_time"         the amount of billing time since the player last logged in
    */
    private static native dictionary _getAccountTimeData(long player);
    public static dictionary getAccountTimeData(obj_id player)
    {
        return _getAccountTimeData(getLongWithNull(player));
    }

    /*@}*/

    /**
     * @defgroup query Global query methods
     */
    /*@{*/
    /**
     * Get a player's id given their lowercase first name
     * @param lowerFirstName  the lowercase first name of the player
     * @return the obj_id of the player
     */
    private static native long _getPlayerIdFromFirstName(String lowerFirstName);
    public static obj_id getPlayerIdFromFirstName(String lowerFirstName)
    {
        return getObjIdWithNull(_getPlayerIdFromFirstName(lowerFirstName));
    }
    /**
     * Check whether a player exists (whether loaded or not)
     * @param playerId the obj_id of the player
     * @return whether the player exists
     */
    private static native boolean _playerExists(long playerId);
    public static boolean playerExists(obj_id playerId)
    {
        return _playerExists(getLongWithNull(playerId));
    }
    /**
     * Get the localized string version of a string_id
     * @param id   the string_id to look up
     * @return     the localized string
     */
    public static native String localize(string_id id);
    /*@}*/

    /**
     * Adds a PERMANENT auction to the given auctionContainer.  Copies of this
     * item will be sold at the given price and will not go away once purchased.
     * @param ownerName the name to put in the owner field.  This does not
     *                  have to be a real player name
     * @param item      the item to copy.  This item itself won't be put up
     *                  for auction, but copies of it will.
     * @param auctionContainer the auction container to put it in
     * @param cost the amount needed to purchase the item
     * @param userDescription description of the item
     */
    private static native void _auctionCreatePermanent(String ownerName, long item, long auctionContainer, int cost, String userDescription);
    public static void auctionCreatePermanent(String ownerName, obj_id item, obj_id auctionContainer, int cost, String userDescription)
    {
        _auctionCreatePermanent(ownerName, getLongWithNull(item), getLongWithNull(auctionContainer), cost, userDescription);
    }

	private static native void _removeAllAuctions(long vendor);
	public static void removeAllAuctions(obj_id vendor)
	{
		_removeAllAuctions(getLongWithNull(vendor));
	}

	private static native void _reinitializeVendor(long vendor, long player);
	public static void reinitializeVendor(obj_id vendor, obj_id player)
	{
		_reinitializeVendor(getLongWithNull(vendor), getLongWithNull(player));
	}

    public static final int VENDOR_STATUS_FLAG_NONE   = 0x00000000;
    public static final int VENDOR_STATUS_FLAG_PACKED = 0x01000000;

	private static native void _updateVendorStatus(long vendor, int status);
	public static void updateVendorStatus(obj_id vendor, int status)
    {
        _updateVendorStatus(getLongWithNull(vendor), status);
    }

    private static native void _sendScriptVarsToProxies(long obj, byte[] deltaBuffer);
    public static void sendScriptVarsToProxies(obj_id obj, byte[] deltaBuffer)
    {
        _sendScriptVarsToProxies(getLongWithNull(obj), deltaBuffer);
    }

    /** Get the scriptVars deltadictionary from an obj_id
    */
    public static deltadictionary getScriptVars()
    {
        obj_id self = getSelf();
        if(self != null)
            return self.getScriptVars();
        return null;
    }
    /**
     * @defgroup Spawn System support methods
     */
    /*@{*/
    public static native int getServerSpawnLimit();
    /*@}*/

    /**
     * @defgroup Text output support methods.
     */
    /*@{*/
    /**
     * Generate fly text over the head of a specified object, displaying
     * on all clients that are in range of the emitter object.
     *
     * Fly text is text that appears over the top of an object and moves
     * upward while fading away.  The damage numbers that fly over a
     * combatant's head is an example of fly text.
     *
     * @param emitterId     The object_id for the object that will emit the
     *                      text.
     * @param outputTextId  The string_id for the text to be displayed over the
     *                      top of the emitter object.
     * @param scale         The scale of the text that is output.  1.0 is normal
     *                      text size for each client.  1.5 is the value used for
     *                      the large damage text as of the writing of this
     *                      writing.
     * @param color         A color object specifying the color of the text.  The alpha
     *                      component of the color is ignored.
     */
    public static void showFlyText(obj_id emitterId, string_id outputTextId, float scale, color textColor)
        {
            //-- Expand the color values in Java since it is easier to do here than on the C side.
            showFlyText(emitterId, outputTextId, scale, textColor.getR(), textColor.getG(), textColor.getB());
        }


    /**
     * Generate fly text over the head of a specified object, displaying
     * on all clients that are in range of the emitter object.
     *
     * Fly text is text that appears over the top of an object and moves
     * upward while fading away.  The damage numbers that fly over a
     * combatant's head is an example of fly text.
     *
     * @param emitterId     The obj_id for the object that will emit the
     *                      text.
     * @param outputTextId  The string_id for the text to be displayed over the
     *                      top of the emitter object.
     * @param scale         The scale of the text that is output.  1.0 is normal
     *                      text size for each client.  1.5 is the value used for
     *                      the large damage text as of the writing of this
     *                      writing.
     * @param r             The red color component specifying the color of the text.
     * @param g             The green color component specifying the color of the text.
     * @param b             The blue color component specifying the color of the text.
     */
    private static native void _showFlyText(long emitterId, string_id outputTextId, float scale, int r, int g, int b);
    public static void showFlyText(obj_id emitterId, string_id outputTextId, float scale, int r, int g, int b)
    {
        _showFlyText(getLongWithNull(emitterId), outputTextId, scale, r, g, b);
    }

    /**
     * Generate fly text over the head of a specified object visible only on
     * a specified player's client.
     *
     * Fly text is text that appears over the top of an object and moves
     * upward while fading away.  The damage numbers that fly over a
     * combatant's head is an example of fly text.
     *
     * @param emitterId     The obj_id for the object that will emit the
     *                      text.
     * @param recipientId   The obj_id of the one and only player that will
     *                      receive this message.
     * @param outputTextId  The string_id for the text to be displayed over the
     *                      top of the emitter object.
     * @param scale         The scale of the text that is output.  1.0 is normal
     *                      text size for each client.  1.5 is the value used for
     *                      the large damage text as of the writing of this
     *                      writing.
     * @param color         A color object specifying the color of the text.  The alpha
     *                      component of the color is ignored.
     */
    public static void showFlyTextPrivate(obj_id emitterId, obj_id recipientId, string_id outputTextId, float scale, color textColor)
    {
        //-- Expand the color values in Java since it is easier to do here than on the C side.
        showFlyTextPrivate(emitterId, recipientId, outputTextId, scale, textColor.getR(), textColor.getG(), textColor.getB());
    }


    /**
     * Generate fly text over the head of a specified object only on a specified
     * player's client.
     *
     * Fly text is text that appears over the top of an object and moves
     * upward while fading away.  The damage numbers that fly over a
     * combatant's head is an example of fly text.
     *
     * @param emitterId     The obj_id for the object that will emit the
     *                      text.
     * @param recipientId   The obj_id of the one and only player that will
     *                      receive this message.
     * @param outputTextId  The string_id for the text to be displayed over the
     *                      top of the emitter object.
     * @param scale         The scale of the text that is output.  1.0 is normal
     *                      text size for each client.  1.5 is the value used for
     *                      the large damage text as of the writing of this
     *                      writing.
     * @param r             The red color component specifying the color of the text.
     * @param g             The green color component specifying the color of the text.
     * @param b             The blue color component specifying the color of the text.
     */
    public static void showFlyTextPrivate(obj_id emitterId, obj_id recipientId, string_id outputTextId, float scale, int r, int g, int b)
    {
        showFlyTextPrivate (emitterId, recipientId, outputTextId, scale, r, g, b, false);
    }

    private static native void _showFlyTextPrivate(long emitterId, long defenderId, string_id outputTextId, float scale, int r, int g, int b, boolean showInChatBox);
    public static void showFlyTextPrivate(obj_id emitterId, obj_id defenderId, string_id outputTextId, float scale, int r, int g, int b, boolean showInChatBox)
    {
        _showFlyTextPrivate(getLongWithNull(emitterId), getLongWithNull(defenderId), outputTextId, scale, r, g, b, showInChatBox);
    }

    /**
     * Generate combat fly text over the head of a specified object, displaying
     * on all clients that are in range of the emitter object, waits for combat action to complete before showing the text.
     *
     * Fly text is text that appears over the top of an object and moves
     * upward while fading away.  The damage numbers that fly over a
     * combatant's head is an example of fly text.
     *
     * @param emitterId     The object_id for the object that will emit the
     *                      text.
     * @param outputTextId  The string_id for the text to be displayed over the
     *                      top of the emitter object.
     * @param scale         The scale of the text that is output.  1.0 is normal
     *                      text size for each client.  1.5 is the value used for
     *                      the large damage text as of the writing of this
     *                      writing.
     * @param color         A color object specifying the color of the text.  The alpha
     *                      component of the color is ignored.
     */
    public static void showCombatText(obj_id defenderId, obj_id attackerId, string_id outputTextId, float scale, color textColor)
    {
        //-- Expand the color values in Java since it is easier to do here than on the C side.
        showCombatText(defenderId, attackerId, outputTextId, scale, textColor.getR(), textColor.getG(), textColor.getB());
    }

    private static native void _showCombatText(long defenderId, long attackerId, string_id outputTextId, float scale, int r, int g, int b);
    public static void showCombatText(obj_id defenderId, obj_id attackerId, string_id outputTextId, float scale, int r, int g, int b)
    {
        _showCombatText(getLongWithNull(defenderId), getLongWithNull(attackerId), outputTextId, scale, r, g, b);
    }

    /**
     * Generate combat fly text over the head of a specified object, displaying
     * only on a specified player's client, waits for combat action to complete before showing the text.
     *
     * Fly text is text that appears over the top of an object and moves
     * upward while fading away.  The damage numbers that fly over a
     * combatant's head is an example of fly text.
     *
     * @param emitterId     The object_id for the object that will emit the
     *                      text.
     * @param outputTextId  The string_id for the text to be displayed over the
     *                      top of the emitter object.
     * @param scale         The scale of the text that is output.  1.0 is normal
     *                      text size for each client.  1.5 is the value used for
     *                      the large damage text as of the writing of this
     *                      writing.
     * @param color         A color object specifying the color of the text.  The alpha
     *                      component of the color is ignored.
     */
    public static void showCombatTextPrivate(obj_id defenderId, obj_id attackerId, obj_id emitterId, string_id outputTextId, float scale, color textColor)
    {
        //-- Expand the color values in Java since it is easier to do here than on the C side.
        showCombatTextPrivate(defenderId, attackerId, emitterId, outputTextId, scale, textColor.getR(), textColor.getG(), textColor.getB());
    }

    private static native void _showCombatTextPrivate(long defenderId, long attackerId, long emitterId, string_id outputTextId, float scale, int r, int g, int b);
    public static void showCombatTextPrivate(obj_id defenderId, obj_id attackerId, obj_id emitterId, string_id outputTextId, float scale, int r, int g, int b)
    {
        _showCombatTextPrivate(getLongWithNull(defenderId), getLongWithNull(attackerId), getLongWithNull(emitterId), outputTextId, scale, r, g, b);
    }

    public static void showFlyText(obj_id emitterId, prose_package outputTextProse, float scale, color textColor)
    {
        //-- Expand the color values in Java since it is easier to do here than on the C side.
        showFlyText(emitterId, outputTextProse, scale, textColor.getR(), textColor.getG(), textColor.getB());
    }

    public static void showFlyText(obj_id emitterId, prose_package outputTextProse, float scale, int r, int g, int b)
    {
        String oob = packOutOfBandProsePackage (null, outputTextProse);
        showFlyTextProse(emitterId, oob, scale, r, g, b);
    }

    public static void showFlyTextPrivate(obj_id emitterId, obj_id recipientId, prose_package outputTextProse, float scale, color textColor)
    {
        //-- Expand the color values in Java since it is easier to do here than on the C side.
        showFlyTextPrivate(emitterId, recipientId, outputTextProse, scale, textColor.getR(), textColor.getG(), textColor.getB());
    }

    public static void showFlyTextPrivate(obj_id emitterId, obj_id recipientId, prose_package outputTextProse, float scale, int r, int g, int b)
    {
        showFlyTextPrivate (emitterId, recipientId, outputTextProse, scale, r, g, b, false);
    }

    public static void showFlyTextPrivate(obj_id emitterId, obj_id defenderId, prose_package outputTextProse, float scale, int r, int g, int b, boolean showInChatBox)
    {
        String oob = packOutOfBandProsePackage (null, outputTextProse);
        showFlyTextPrivateProse(emitterId, defenderId, oob, scale, r, g, b, showInChatBox);
    }

    public static void showCombatText(obj_id defenderId, obj_id attackerId, prose_package outputTextProse, float scale, color textColor)
    {
        //-- Expand the color values in Java since it is easier to do here than on the C side.
        showCombatText(defenderId, attackerId, outputTextProse, scale, textColor.getR(), textColor.getG(), textColor.getB());
    }

    public static void showCombatText(obj_id defenderId, obj_id attackerId, prose_package outputTextProse, float scale, int r, int g, int b)
    {
        String oob = packOutOfBandProsePackage (null, outputTextProse);
        showCombatTextProse(defenderId, attackerId, oob, scale, r, g, b);
    }

    public static void showCombatTextPrivate(obj_id defenderId, obj_id attackerId, obj_id emitterId, prose_package outputTextProse, float scale, color textColor)
    {
        //-- Expand the color values in Java since it is easier to do here than on the C side.
        showCombatTextPrivate(defenderId, attackerId, emitterId, outputTextProse, scale, textColor.getR(), textColor.getG(), textColor.getB());
    }

    public static void showCombatTextPrivate(obj_id defenderId, obj_id attackerId, obj_id emitterId, prose_package outputTextProse, float scale, int r, int g, int b)
    {
        String oob = packOutOfBandProsePackage (null, outputTextProse);
        showCombatTextPrivateProse(defenderId, attackerId, emitterId, oob, scale, r, g, b);
    }

    private static native void _showFlyTextProse(long emitterId, String oob, float scale, int r, int g, int b);
    public static void showFlyTextProse(obj_id emitterId, String oob, float scale, int r, int g, int b)
    {
        _showFlyTextProse(getLongWithNull(emitterId), oob, scale, r, g, b);
    }

    private static native void _showFlyTextPrivateProse(long emitterId, long defenderId, String oob, float scale, int r, int g, int b, boolean showInChatBox);
    public static void showFlyTextPrivateProse(obj_id emitterId, obj_id defenderId, String oob, float scale, int r, int g, int b, boolean showInChatBox)
    {
        _showFlyTextPrivateProse(getLongWithNull(emitterId), getLongWithNull(defenderId), oob, scale, r, g, b, showInChatBox);
    }

    private static native void _showCombatTextProse(long defenderId, long attackerId, String oob, float scale, int r, int g, int b);
    public static void showCombatTextProse(obj_id defenderId, obj_id attackerId, String oob, float scale, int r, int g, int b)
    {
        _showCombatTextProse(getLongWithNull(defenderId), getLongWithNull(attackerId), oob, scale, r, g, b);
    }

    private static native void _showCombatTextPrivateProse(long defenderId, long attackerId, long emitterId, String oob, float scale, int r, int g, int b);
    public static void showCombatTextPrivateProse(obj_id defenderId, obj_id attackerId, obj_id emitterId, String oob, float scale, int r, int g, int b)
    {
        _showCombatTextPrivateProse(getLongWithNull(defenderId), getLongWithNull(attackerId), getLongWithNull(emitterId), oob, scale, r, g, b);
    }

    public static void showFlyTextPrivateProseWithFlags(obj_id emitterId, obj_id defenderId, prose_package outputTextProse, float scale, color textColor, int flags)
	{
        String oob = packOutOfBandProsePackage (null, outputTextProse);
        _showFlyTextPrivateProseWithFlags(getLongWithNull(emitterId), getLongWithNull(defenderId), oob, scale, textColor.getR(), textColor.getG(), textColor.getB(), flags);
    }
    public static void showFlyTextPrivateProseWithFlags(obj_id emitterId, obj_id defenderId, String oob, float scale, color textColor, int flags)
	{
        _showFlyTextPrivateProseWithFlags(getLongWithNull(emitterId), getLongWithNull(defenderId), oob, scale, textColor.getR(), textColor.getG(), textColor.getB(), flags);
    }
	private static native void _showFlyTextPrivateProseWithFlags(long emitterId, long defenderId, String oob, float scale, int r, int g, int b, int flags);
	public static void showFlyTextPrivateProseWithFlags(obj_id emitterId, obj_id defenderId, String oob, float scale, int r, int g, int b, int flags)
	{
        _showFlyTextPrivateProseWithFlags(getLongWithNull(emitterId), getLongWithNull(defenderId), oob, scale, r, g, b, flags);
    }

    /*@}*/

    /**
     * @defgroup Mountability status codes.
     *
     * Returned by Mountable creature support methods that indicate whether an
     * instance of a particular species is mountable at its current scale and
     * seating capacity.
     *
     * Note: these values must be kept in sync with the definitive values that
     * are in the MountValidScaleRangeTable.h file.
     */

    public final static int MSC_CREATURE_MOUNTABLE                             = 0;
    public final static int MSC_SPECIES_UNMOUNTABLE                            = 1;
    public final static int MSC_SPECIES_MOUNTABLE_SEATING_CAPACITY_UNSUPPORTED = 2;
    public final static int MSC_SPECIES_MOUNTABLE_SCALE_OUT_OF_RANGE           = 3;
    public final static int MSC_SPECIES_MOUNTABLE_MISSING_RIDER_SLOT           = 4;
    /*@}*/

    /**
     * @defgroup Mountable creature support methods.
     *
     * @{
     */

    /**
     * Return whether the server has support for mounts enabled.
     *
     * @return  true if the server will support mount system commands.
     *          false if the server will fail all mount-related commands.
     */
    public static native boolean getMountsEnabled();

    /**
     * Return whether the server has support for multiple riders per mount enabled.
     *
     * It is valid for getMountsEnabled() to return true but getMountsMultiSeaterEnabled()
     * to return false.  In this case, mounts should only be run as one rider (the driver)
     * per mount.
     *
     * @return  true if the server will support mount system commands with multiple
     *          riders per mount.  false if the server will fail all mount-related
     *          commands that work on multiple riders per mount.
     */
    public static native boolean getMountsMultiSeaterEnabled();

    /**
     * Mark the specified pet as being mountable.
     *
     * Under the hood, this function ensures that the specified
     * CreatureObject has a VirtualSlottedContainerProperty added to it
     * that points to the pet control device.  This means that all
     * standard game equipment handling for the non-persisted pet
     * will actually reference the persisted equipment on the pet
     * control device.
   *
     * This function assumes that the objvar pet.controlDevice is set
     * properly on the pet.
     *
     * @param petId the obj_id for the pet that will be converted to a
     *              mountable pet.
     *
     * @return  true if the function succeeded; false otherwise.  Most
     *          likely reason for failure if petId is a valid pet would
     *          be because the pet and pet control device are not on the
     *          same server.  Calling the function again on a new game
     *          frame may succeed in this case: I will try to move the
     *          pet control device and pet onto the same server if this
     *          fails for that reason.
     */
    private static native boolean _makePetMountable(long petId);
    public static boolean makePetMountable(obj_id petId)
    {
        return _makePetMountable(getLongWithNull(petId));
    }

    /**
     * Return the name of the buildout area for the given
     * (x,z) position.
     */
    public static native String getBuildoutAreaName( float x, float z, String sceneId );
    public static String getBuildoutAreaName( float x, float z )
    {
	return getBuildoutAreaName ( x, z, getCurrentSceneName() );
    }

    /**
     * Return the size and center point of the buildout area for the given
     * (x,z) position.
     *
     * returns: float array or null
     * float[0] -> width
     * float[1] -> height
     * float[2] -> centerX
     * float[3] -> centerZ
     */
    public static native float[] getBuildoutAreaSizeAndCenter( float x, float z, String sceneId, boolean ignoreInternal, boolean allowComposite );

    /**
     * Notify the mount that its wearable-related visuals must be updated.
     *
     * Call this function after the equipment for the mount changes.
     *
     * Under the hood, this function gets a list of the wearables
     * information from the pet control device slotted container.  The
     * visuals information on the creature is then rebuilt, adding the
     * pet control device wearables info to the mix.
     *
     * @param mountId  the obj_id for the pet that just experienced an
     *                 equipment change.
     */
    private static native void _updateMountWearableVisuals(long mountId);
    public static void updateMountWearableVisuals(obj_id mountId)
    {
        _updateMountWearableVisuals(getLongWithNull(mountId));
    }

    /**
     * Cause the specified rider to mount the specified mount.
     *
     * @param riderId  the obj_id of the player/NPC that will ride the
     *                 specified mount.
     * @param mountId  the obj_id of the creature that will be ridden
     *                 by the rider.
     *
     * @return  true if the rider mounted the creature; false otherwise.
     *          Most likely cause for failure if rider and mount are valid
     *          is because the rider and mount are not on the same server.
     *          I will try to move them to the same server if this is the
     *          case.  Call the function again on a new game frame.
     */
    private static native boolean _mountCreature(long riderId, long mountId);
    public static boolean mountCreature(obj_id riderId, obj_id mountId)
    {
        return _mountCreature(getLongWithNull(riderId), getLongWithNull(mountId));
    }

    /**
     * Cause the specified rider to dismount whatever creature it is
     * currently riding.
     *
     * @param riderId  the obj_id of the rider that is currently riding
     *                 a mount.
     */
    private static native void _dismountCreature(long riderId);
    public static void dismountCreature(obj_id riderId)
    {
        _dismountCreature(getLongWithNull(riderId));
    }

    /**
     * Retrieve the obj_id for the creature mount that is currently
     * being ridden by the specified rider player/NPC.
     *
     * @param riderId  the obj_id for the player doing the riding.
     *
     * @return  the obj_id of the rider's mount if the rider is actually
     *          mounted; NULL if the rider is not riding anything.
     */
    private static native long _getMountId(long riderId);
    public static obj_id getMountId(obj_id riderId)
    {
        return getObjIdWithNull(_getMountId(getLongWithNull(riderId)));
    }

    /**
     * Retrieve the obj_id for the creature mount that is currently
     * being ridden by the specified rider player/NPC.
     *
     * @param mountId  the obj_id for the mounted creature.
     *
     * @return  the obj_id of the mount's rider if the mount is actually
     *          being mounted by a rider; NULL if the mount is not mounted
     *          by a rider.
     */
    private static native long _getRiderId(long mountId);
    public static obj_id getRiderId(obj_id mountId)
    {
        return getObjIdWithNull(_getRiderId(getLongWithNull(mountId)));
    }

    /**
     * Check if a given pet could be made mountable at its current scale.
     *
     * This function verifies that the specified CreatureObject's
     * appearance can be mounted and that the current scale of the
     * creature is within the mountable range.
     *
     * @param petId  the obj_id of the pet to check.
     *
     * @return  mountability status code (see return codes documented in their own group).
     */
    private static native int _couldPetBeMadeMountable(long petId);
    public static int couldPetBeMadeMountable(obj_id petId)
    {
        return _couldPetBeMadeMountable(getLongWithNull(petId));
    }

    /**
     * Check if a given server object template could be made mountable at a given scale.
     *
     * This function verifies that the CreatureObject specified by a
     * given server object template pathname can be mounted and that the
     * current scale of the creature is within the mountable range.
     *
     * It is essential that you use the __server__ object template name.  If you use
     * the shared object template name, this function is guaranteed to return an error.
     * Internally it grabs the shared object template name from the server object template,
     * then grabs the appearance name from the shared object template.
     *
     * @param serverObjectTemplateName  the name of the server object template that will
     *                                  be checked.
     * @param objectScale               the scaled size of the creature.  Should never be
     *                                  less than or equal to zero; all larger values that
     *                                  fit in a float are acceptable, although values larger
     *                                  than about 100 are probably quite suspect.  A value of
     *                                  1.0 is equivalent to the default size as modeled by
     *                                  the artists.
     *
     * @return  mountability status code (see return codes documented in their own group).
     */
    public static native int couldObjectTemplateBeMadeMountable(String serverObjectTemplateName, float objectScale);

    /**
     * Check if a mount has room for accepting another user.
     *
     * @param mountId  the obj_id for the mounted creature.
     *
     */

    private static native boolean _doesMountHaveRoom(long mountId);
    public static boolean doesMountHaveRoom(obj_id mountId)
    {
        return _doesMountHaveRoom(getLongWithNull(mountId));
    }

    /**
     * Do not call this function unless you are purposefully setting up
     * a buggy condition.
     *
     * This function will put the object in a state where the object
     * believes it is contained by something but its container does not
     * believe the object is in the container.  The function assumes
     * that the containedObjectId is already in the container and that
     * this call is made on the authoritative object.
     *
     * @param containedObjectId the object that is contained by another
     * object.
     */
    private static native void _makeContainerStateInconsistentTestOnly(long containedObjectId);
    public static void makeContainerStateInconsistentTestOnly(obj_id containedObjectId)
    {
        _makeContainerStateInconsistentTestOnly(getLongWithNull(containedObjectId));
    }

    /*@}*/ // end of mounts/vehicles-related functions

    /**
     * Returns the distance a player must be from a target to use a menu item.
     * @param menuType      the id of the menu item (from menu_info_types.java)
     * @return the distance, or -1 on unknown menu type
     */
    public static native float getRangeForMenuType(int menuType);

    /**
    * Use this function to signal to observing clients that the target object's radial menu
    * has been substantially changed (e.g. a menu item added or removed).
    *
    * If you find yourself using this function, first ask yourself if the radial menu
    * should be changed at all.  It may be more appropriate to have the radial menu options
    * be more constant, but sometimes disallow the action.
    *
    * There are 2 competing ideals of UI design at play here:
    *
    * 1. menus should be consistent and unchanging
    * 2. unusable options should not be presented to the user in the first place.
    *
    * The first rule is a stronger ideal and should often pre-empt application of the second rule.
    *
    * @param target the object who's radial menu is changing
    */
    private static native void _sendDirtyObjectMenuNotification(long target);
    public static void sendDirtyObjectMenuNotification(obj_id target)
    {
        _sendDirtyObjectMenuNotification(getLongWithNull(target));
    }

    /**
    * Use this function to signal to observing clients that the target attributes have changed.
    * This should only be used you when change a server-only attribute.  This includes attributes
    * that are populated from script only, or attributes that are not synchronized down to the client.
    *
    * @param target the object who's attributes are changing
    */

    private static native void _sendDirtyAttributesNotification(long target);
    public static void sendDirtyAttributesNotification(obj_id target)
    {
        _sendDirtyAttributesNotification(getLongWithNull(target));
    }

    /**
     * Utility function to fix a bug with houses.
     * @param target        the house to fix
     * @return true on success, false if target isn't a building
     */
    private static native boolean _fixHouseItemLimit(long target);
    public static boolean fixHouseItemLimit(obj_id target)
    {
        return _fixHouseItemLimit(getLongWithNull(target));
    }

    /**
     *
     * Save a text file on a god mode client's machine.
     * @param client  the target object which has a god mode client
     * @param filename  the filename to save
     * @param filetext  the text of the file to save
     */
    private static native void _saveTextOnClient(long client, String filename, String filetext);
    public static void saveTextOnClient(obj_id client, String filename, String filetext)
    {
        _saveTextOnClient(getLongWithNull(client), filename, filetext);
    }

    private static native void _saveBytesOnClient(long client, String filename, byte[] bytes);
    public static void saveBytesOnClient(obj_id client, String filename, byte[] bytes)
    {
        _saveBytesOnClient(getLongWithNull(client), filename, bytes);
    }

    /**
     * Request data from the cluster wide data manager
     * @param managerName       name of the particular data manager (like "dungeon" for dungeon data)
     * @param elementNameRegex  regular expression specifying what elements to retrieve
     *                          (the only wildcard support for now is a single * at the
     *                          end of string - like "*" or "Corellian Corvette*"
     * @param lockElements      indicates if returned elements should be locked by the cluster wide data manager
     * @param callbackObject    obj_id of the callback object whose OnClusterWideDataResponse trigger will be called with the result
     * @return                  the int representing the particular request Id, when the OnClusterWideDataResponse trigger is
     *                          called with the result of this particular request, it will contain the matching request Id
     */
    private static native int _getClusterWideData(String managerName, String elementNameRegex, boolean lockElements, long callbackObject);
    public static int getClusterWideData(String managerName, String elementNameRegex, boolean lockElements, obj_id callbackObject)
    {
        return _getClusterWideData(managerName, elementNameRegex, lockElements, getLongWithNull(callbackObject));
    }

    /**
     * Unlock locked elements in the cluster wide data manager
     * @param managerName       name of the particular data manager (like "dungeon" for dungeon data)
     * @param lockKey           the lock key that was returned in the OnClusterWideDataResponse trigger
     */
    public static native void releaseClusterWideDataLock(String managerName, int lockKey);

    /**
     * Remove data from the cluster wide data manager
     * @param managerName       name of the particular data manager (like "dungeon" for dungeon data)
     * @param elementNameRegex  regular expression specifying what elements to remove
     *                          (the only wildcard support for now is a single * at the
     *                          end of string - like "*" or "Corellian Corvette*"
     * @param lockKey           lock key for the data to remove; only locked elements
     *                          can be removed and can only be removed by the lock owner
     */
    public static native void removeClusterWideData(String managerName, String elementNameRegex, int lockKey);

    /**
     * Update the data in the cluster wide data manager with new data by merging
     * the new data with the existing data in the cluster wide data manager;
     * @param managerName       name of the particular data manager (like "dungeon" for dungeon data)
     * @param elementNameRegex  regular expression specifying what elements to replace
     *                          or update the data (the only wildcard support for now
     *                          is a single * at the end of string - like "*" or
     *                          "Corellian Corvette*"
     * @param data              dictionary containing the new data
     * @param lockKey           lock key for the data to update; only locked elements
     *                          can be updated and can only be updated by the lock owner;
     */
    public static native void updateClusterWideData(String managerName, String elementNameRegex, dictionary data, int lockKey);

    /**
     * Replace the data in the cluster wide data manager with new data; if elementNameRegex
     * specifies a single item and it does not yet exist, it will be added
     * @param managerName       name of the particular data manager (like "dungeon" for dungeon data)
     * @param elementNameRegex  regular expression specifying what elements to replace
     *                          or update the data (the only wildcard support for now
     *                          is a single * at the end of string - like "*" or
     *                          "Corellian Corvette*"
     * @param data              dictionary containing the new data
     * @param autoRemove        specifies that the data should be automatically removed
     *                          if the game server from which this request originated is terminated
     * @param lockKey           lock key for the data to replace; only locked elements
     *                          can be replaced and can only be replaced by the lock owner;
     *                          if the item does not yet exist, it will be added and no
     *                          lock key is required in this case
     */
    public static native void replaceClusterWideData(String managerName, String elementNameRegex, dictionary data, boolean autoRemove, int lockKey);

    /**
     * Get the crc for an ascii string
     * @param s  the string
     * @return the crc
     */
    public static int getStringCrc(String s)
    {
        return string_crc.getStringCrc(s);
    }

    // ----------------------------------------------------------------------
    //-- New quest system

    /**
        Determine if the active quests bitvector contains the questId.

        @param questId  datatable column corresponding to the quest
        @param player   player to check

        @return  true of the player is currently on the requested quest
    */
    private static native boolean _isQuestActive(long player, int questId);
    public static boolean isQuestActive(obj_id player, int questId)
    {
        return _isQuestActive(getLongWithNull(player), questId);
    }
    private static native boolean _isQuestComplete(long player, int questId);
    public static boolean isQuestComplete(obj_id player, int questId)
    {
        return _isQuestComplete(getLongWithNull(player), questId);
    }
    private static native void    _activateQuest(long player, int questId);
    public static void    activateQuest(obj_id player, int questId)
    {
        _activateQuest(getLongWithNull(player), questId);
    }
    private static native void    _deactivateQuest(long player, int questId);
    public static void    deactivateQuest(obj_id player, int questId)
    {
        _deactivateQuest(getLongWithNull(player), questId);
    }
    private static native void    _completeQuest(long player, int questId);
    public static void    completeQuest(obj_id player, int questId)
    {
        _completeQuest(getLongWithNull(player), questId);
    }
    private static native void    _clearCompletedQuest(long player, int questId);
    public static void    clearCompletedQuest(obj_id player, int questId)
    {
        _clearCompletedQuest(getLongWithNull(player), questId);
    }
    private static native void    _requestActivateQuest(int questId, long player, long questGiver);
    public static void    requestActivateQuest(int questId, obj_id player, obj_id questGiver)
    {
        _requestActivateQuest(questId, getLongWithNull(player), getLongWithNull(questGiver));
    }
    private static native void    _requestCompleteQuest(int questId, long player);
    public static void    requestCompleteQuest(int questId, obj_id player)
    {
        _requestCompleteQuest(questId, getLongWithNull(player));
    }

    // ----------------------------------------------------------------------

    public static native int     questGetQuestId(String questName);
    public static native String  questGetQuestName(int questId);
    private static native boolean _questIsQuestComplete(int questId, long playerId);
    public static boolean questIsQuestComplete(int questId, obj_id playerId)
    {
        return _questIsQuestComplete(questId, getLongWithNull(playerId));
    }
    private static native int     _questCanActivateQuest(int questId, long playerId);
    public static int     questCanActivateQuest(int questId, obj_id playerId)
    {
        return _questCanActivateQuest(questId, getLongWithNull(playerId));
    }
    private static native boolean _questIsQuestActive(int questId, long playerId);
    public static boolean questIsQuestActive(int questId, obj_id playerId)
    {
        return _questIsQuestActive(questId, getLongWithNull(playerId));
    }
    private static native int     _questActivateQuest(int questId, long playerId, long questGiver);
    public static int     questActivateQuest(int questId, obj_id playerId, obj_id questGiver)
    {
        return _questActivateQuest(questId, getLongWithNull(playerId), getLongWithNull(questGiver));
    }
    private static native int     _questCompleteQuest(int questId, long playerId);
    public static int     questCompleteQuest(int questId, obj_id playerId)
    {
        return _questCompleteQuest(questId, getLongWithNull(playerId));
    }
    private static native void    _questClearQuest(int questId, long playerId);
    public static void    questClearQuest(int questId, obj_id playerId)
    {
        _questClearQuest(questId, getLongWithNull(playerId));
    }
    private static native boolean _questIsTaskComplete(int questId, int taskId, long playerId);
    public static boolean questIsTaskComplete(int questId, int taskId, obj_id playerId)
    {
        return _questIsTaskComplete(questId, taskId, getLongWithNull(playerId));
    }
    private static native int     _questCanActivateTask(int questId, int taskId, long playerId);
    public static int     questCanActivateTask(int questId, int taskId, obj_id playerId)
    {
        return _questCanActivateTask(questId, taskId, getLongWithNull(playerId));
    }
    private static native boolean _questIsTaskActive(int questId, int taskId, long playerId);
    public static boolean questIsTaskActive(int questId, int taskId, obj_id playerId)
    {
        return _questIsTaskActive(questId, taskId, getLongWithNull(playerId));
    }
    private static native int     _questActivateTask(int questId, int taskId, long playerId);
    public static int     questActivateTask(int questId, int taskId, obj_id playerId)
    {
        return _questActivateTask(questId, taskId, getLongWithNull(playerId));
    }
    private static native int     _questCompleteTask(int questId, int taskId, long playerId);
    public static int     questCompleteTask(int questId, int taskId, obj_id playerId)
    {
        return _questCompleteTask(questId, taskId, getLongWithNull(playerId));
    }
    private static native int     _questFailTask(int questId, int taskId, long playerId);
    public static int     questFailTask(int questId, int taskId, obj_id playerId)
    {
        return _questFailTask(questId, taskId, getLongWithNull(playerId));
    }
    private static native void    _questClearQuestTask(int questId, int taskId, long playerId);
    public static void    questClearQuestTask(int questId, int taskId, obj_id playerId)
    {
        _questClearQuestTask(questId, taskId, getLongWithNull(playerId));
    }

    public static native void    questSetDebugging(boolean debugging);
    public static native boolean questGetDebugging();

    private static native void    _questSetQuestTaskCounter(long playerId, String questName, int taskId, String sourceName, int counter, int counterMax);
    public static void    questSetQuestTaskCounter(obj_id playerId, String questName, int taskId, String sourceName, int counter, int counterMax)
    {
        _questSetQuestTaskCounter(getLongWithNull(playerId), questName, taskId, sourceName, counter, counterMax);
    }

    private static native void _questSetQuestTaskLocation(long playerId, String questName, int taskId, location taskLocation);
    public static void questSetQuestTaskLocation(obj_id playerId, String questName, int taskId, location taskLocation)
    {
        _questSetQuestTaskLocation(getLongWithNull(playerId), questName, taskId, taskLocation);
    }

    private static native void    _questSetQuestTaskTimer(long playerId, String questName, int taskId, String sourceName, int timerLength);
    public static void    questSetQuestTaskTimer(obj_id playerId, String questName, int taskId, String sourceName, int timerLength)
    {
        _questSetQuestTaskTimer(getLongWithNull(playerId), questName, taskId, sourceName, timerLength);
    }

    private static native int[] _questGetAllActiveQuestIds(long object);
    public static int[] questGetAllActiveQuestIds(obj_id object)
    {
        return _questGetAllActiveQuestIds(getLongWithNull(object));
    }

    private static native int[] _questGetAllCompletedQuestIds(long object);
    public static int[] questGetAllCompletedQuestIds(obj_id object)
    {
        return _questGetAllCompletedQuestIds(getLongWithNull(object));
    }

    private static native boolean _questIsQuestAbandonable(int questId);
    public static boolean questIsQuestAbandonable(int questId)
    {
        return _questIsQuestAbandonable(questId);
    }

    private static native boolean _questIsQuestForceAccept(int questId);
    public static boolean questIsQuestForceAccept(int questId)
    {
        return _questIsQuestForceAccept(questId);
    }

    private static native boolean _questDoesUseAcceptanceUI(int questId);
    public static boolean questDoesUseAcceptanceUI(int questId)
    {
        return _questDoesUseAcceptanceUI(questId);
    }

    // ----------------------------------------------------------------------

    private static native void _sendStaticItemDataToPlayer(long player, String[] keys, String[] values);
    public static void sendStaticItemDataToPlayer(obj_id player, String[] keys, String[] values)
    {
        _sendStaticItemDataToPlayer(getLongWithNull(player), keys, values);
    }

    // ----------------------------------------------------------------------

    private static native void _showLootBox(long player, long[] objectIds);
    public static void showLootBox(obj_id player, obj_id[] objectIds)
    {
        long[] _objectIds = null;
        if (objectIds != null)
        {
            _objectIds = new long[objectIds.length];
            for (int _i = 0; _i < objectIds.length; ++_i)
                _objectIds[_i] = getLongWithNull(objectIds[_i]);
        }
        _showLootBox(getLongWithNull(player), _objectIds);
    }

    // ----------------------------------------------------------------------

    /**
     * Cause the specified pilot to mount the specified ship.
     *
     * @param pilotId  the obj_id of the player/NPC that will pilot the
     *                 specified ship.
     * @param shipId   the obj_id of the ship that will be piloted
     *                 by the pilot.
     *
     * @return  true if the pilot mounted the ship; false otherwise.
     *          Most likely cause for failure if pilot and ship are valid
     *          is because the pilot and ship are not on the same server.
     */
    private static native boolean _pilotShip(long pilotId, long shipId);
    public static boolean pilotShip(obj_id pilotId, obj_id shipId)
    {
        return _pilotShip(getLongWithNull(pilotId), getLongWithNull(shipId));
    }

    /**
     * Cause the specified pilot to dismount whatever ship it is
     * currently flying.
     *
     * @param pilotId  the obj_id of the pilot that is currently flying
     *                 a ship.
     */
    private static native boolean _unpilotShip(long pilotId);
    public static boolean unpilotShip(obj_id pilotId)
    {
        return _unpilotShip(getLongWithNull(pilotId));
    }

    /**
     * Retrieve the obj_id for the pilot that is currently
     * flying the specified ship.
     *
     * @param shipId  the obj_id for the ship being piloted.
     *
     * @return  the obj_id of the ship's pilot if the ship is actually
     *          being flown by a pilot; NULL if the ship is not being piloted.
     */
    private static native long _getPilotId(long shipId);
    public static obj_id getPilotId(obj_id shipId)
    {
        return getObjIdWithNull(_getPilotId(getLongWithNull(shipId)));
    }

    /**
     * Retrieve the obj_id for the pilot that is currently
     * flying the specified ship.
     *
     * @param shipId  the obj_id for the ship being piloted.
     *
     * @return  the obj_id of the ship's pilot if the ship is actually
     *          being flown by a pilot; NULL if the ship is not being piloted.
     */
    private static native long _getShipPilot(long shipId);
    public static obj_id getShipPilot(obj_id shipId)
    {
        return getObjIdWithNull(_getShipPilot(getLongWithNull(shipId)));
    }

    /**
     * Retrieve the obj_id for the ship that is currently being piloted by the specified pilot
     *
     * @param pilotId the obj_id for the pilot
     *
     * @return  the obj_id of the ship if the ship is actually
     *          being flown by a pilot; NULL if the ship is not being piloted.
     */
    private static native long _getPilotedShip(long pilotId);
    public static obj_id getPilotedShip(obj_id pilotId)
    {
        return getObjIdWithNull(_getPilotedShip(getLongWithNull(pilotId)));
    }

    /**
     * Launch a missile at the specified target.  The C code will keep track of the missile and
     * call resolveMissile at the appropriate time.
     *
     * @param player The player who is launching the missile (normally the pilot of the ship)
     * @param ship   The ship that is launching the missile
     * @param target The object targeted by the missile
     * @param missileInfo TBD.  Pass 0 for now.  This is a placeholder for information
     *                    about the missile, such as lock time, etc.
     * @param targetedComponent The component slot to hit
     * @return true if the missile is succesfully launched.
     */
    private static native boolean _launchMissile(long player, long ship, long target, int missileInfo, int targetedComponent);
    public static boolean launchMissile(obj_id player, obj_id ship, obj_id target, int missileInfo, int targetedComponent)
    {
        return _launchMissile(getLongWithNull(player), getLongWithNull(ship), getLongWithNull(target), missileInfo, targetedComponent);
    }

    /**
     * Launch a countermeasure
     *
     * @param ship The ship that is launching the countermeasure (0 is legal if "success" is true)
     * @param missileId The id of the missile targetted by the countermeasure (0 is legal if "success" is false)
     * @param success True if the countermeasure should succeed in destroying the missile, false if it should fail
     * @param countermeasureType Numerical identifier for the visual appearance of the countermeasure.  (Refers to the countermeasures data table.)
     * @return true if the countermeasure is succesfully launched.
     */
    private static native boolean _launchCountermeasure(long ship, int missileId, boolean success, int countermeasureType);
    public static boolean launchCountermeasure(obj_id ship, int missileId, boolean success, int countermeasureType)
    {
        return _launchCountermeasure(getLongWithNull(ship), missileId, success, countermeasureType);
    }

    /**
     * Find the nearest unlocked missile aimed at the specifed target.  After a missile is launched, it is unlocked
     * for a certain amount of time.  During this time it can be countermeasured.
     *
     * @param target The target for the missile
     *
     * @return an id that can be used in other missile system calls, or 0 if there is no missile.
     */
    private static native int _getNearestUnlockedMissileForTarget(long target);
    public static int getNearestUnlockedMissileForTarget(obj_id target)
    {
        return _getNearestUnlockedMissileForTarget(getLongWithNull(target));
    }

    /**
     * Find a list of all unlocked missiles aimed at the specifed target.
     *
     * @param target The target for the missile
     *
     * @return an array of ids that can be used in other missile system calls
     */
    private static native int[] _getAllUnlockedMissilesForTarget(long target);
    public static int[] getAllUnlockedMissilesForTarget(obj_id target)
    {
        return _getAllUnlockedMissilesForTarget(getLongWithNull(target));
    }

    /**
     * Destroy a missile in flight.  The missile may animate as blowing up, missing the target, etc. (TBD)
     *
     * @param missileId The id for the missile
     * @return true if the missile id was valid, false otherwise.
     */
    public static native boolean destroyMissile(int missileId);

    /**
     * Get a missile's type identifier.
     *
     * @param missileId The id for the missile
     * @return The type id for the missile, for use with the "missiles" data table.
     */
    public static native int getTypeByMissile(int missileId);

    /**
     * Get the weapon index a missile was launched from
     *
     * @param missileId The id for the missile
     * @return The weapon index.
     */
    public static native int getWeaponIndexByMissile(int missileId);

    /**
     * Get the time since a missile was fired.
     *
     * @param missileId The id for the missile
     * @return The time in seconds
     */
    public static native int getTimeSinceFiredByMissile(int missileId);

    /**
     * Get the total time a missile will take in flight
     *
     * @param missileId The id for the missile
     * @return The time in seconds (some of this time may already be past)
     */
    public static native int getTotalTimeByMissile(int missileId);

    /**
     * Get the ship (or launcher) that fired a missile
     *
     * @param missileId The id for the missile
     * @return The object id of the ship
     */
    private static native long _getWhoFiredByMissile(int missileId);
    public static obj_id getWhoFiredByMissile(int missileId)
    {
        return getObjIdWithNull(_getWhoFiredByMissile(missileId));
    }

    /**
     * Set a specific chassis slot as the target for a given ship
     *
     * @param ship The ship on which to update the chassis slot target
     * @param the chassis_slot (a value from ship_chassis_slot_type)
     */
    private static native boolean _setLookAtTargetShipComponent(long ship, int targetedComponentChassisSlot);
    public static boolean setLookAtTargetShipComponent(obj_id ship, int targetedComponentChassisSlot)
    {
        return _setLookAtTargetShipComponent(getLongWithNull(ship), targetedComponentChassisSlot);
    }

    /**
     * Get the targeted chassis slot for a given ship
     *
     * @param ship The ship on which to get the chassis slot target
     * @return the chassis_slot (a value from ship_chassis_slot_type)
     */
    private static native int     _getLookAtTargetShipComponent(long ship);
    public static int     getLookAtTargetShipComponent(obj_id ship)
    {
        return _getLookAtTargetShipComponent(getLongWithNull(ship));
    }

    /**
     * Get all ships which would be observed from a particular object
     *
     * @param source  The object which would be doing the observation
     * @param excludeSource  whether to exclude the source object from the results
     * @return  all ships visible from the object's location
     */
    private static native long[] _getObservedShips(long source, boolean excludeSource);
    public static obj_id[] getObservedShips(obj_id source, boolean excludeSource)
    {
        long[] _ret_long = _getObservedShips(getLongWithNull(source), excludeSource);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get all player ships which would be observed from a particular object
     *
     * @param source  The object which would be doing the observation
     * @param excludeSource  whether to exclude the source object from the results
     * @return  all player ships visible from the object's location
     */
    private static native long[] _getObservedPlayerShips(long source, boolean excludeSource);
    public static obj_id[] getObservedPlayerShips(obj_id source, boolean excludeSource)
    {
        long[] _ret_long = _getObservedPlayerShips(getLongWithNull(source), excludeSource);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get all enemy ships which would be observed from a particular object
     *
     * @param source  The object which would be doing the observation
     * @return  all enemy ships visible from the object's location
     */
    private static native long[] _getObservedEnemyShips(long source);
    public static obj_id[] getObservedEnemyShips(obj_id source)
    {
        long[] _ret_long = _getObservedEnemyShips(getLongWithNull(source));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    /**
     * Get all enemy player ships which would be observed from a particular object
     *
     * @param source  The object which would be doing the observation
     * @return  all enemy player ships visible from the object's location
     */
    private static native long[] _getObservedEnemyPlayerShips(long source);
    public static obj_id[] getObservedEnemyPlayerShips(obj_id source)
    {
        long[] _ret_long = _getObservedEnemyPlayerShips(getLongWithNull(source));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }

    private static native boolean _getShipHasWings(long shipId);
    public static boolean getShipHasWings(obj_id shipId)
    {
        return _getShipHasWings(getLongWithNull(shipId));
    }
    private static native float _getShipCurrentSpeed(long shipId);
    public static float getShipCurrentSpeed(obj_id shipId)
    {
        return _getShipCurrentSpeed(getLongWithNull(shipId));
    }
    private static native boolean _setShipSlideDampener(long shipId, float slideDampener);
    public static boolean setShipSlideDampener(obj_id shipId, float slideDampener)
    {
        return _setShipSlideDampener(getLongWithNull(shipId), slideDampener);
    }
    private static native float _getShipSlideDampener(long shipId);
    public static float getShipSlideDampener(obj_id shipId)
    {
        return _getShipSlideDampener(getLongWithNull(shipId));
    }
    private static native boolean _setShipCurrentYaw(long shipId, float currentYaw);
    public static boolean setShipCurrentYaw(obj_id shipId, float currentYaw)
    {
        return _setShipCurrentYaw(getLongWithNull(shipId), currentYaw);
    }
    private static native float _getShipCurrentYaw(long shipId);
    public static float getShipCurrentYaw(obj_id shipId)
    {
        return _getShipCurrentYaw(getLongWithNull(shipId));
    }
    private static native boolean _setShipCurrentPitch(long shipId, float currentPitch);
    public static boolean setShipCurrentPitch(obj_id shipId, float currentPitch)
    {
        return _setShipCurrentPitch(getLongWithNull(shipId), currentPitch);
    }
    private static native float _getShipCurrentPitch(long shipId);
    public static float getShipCurrentPitch(obj_id shipId)
    {
        return _getShipCurrentPitch(getLongWithNull(shipId));
    }
    private static native boolean _setShipCurrentRoll(long shipId, float currentRoll);
    public static boolean setShipCurrentRoll(obj_id shipId, float currentRoll)
    {
        return _setShipCurrentRoll(getLongWithNull(shipId), currentRoll);
    }
    private static native float _getShipCurrentRoll(long shipId);
    public static float getShipCurrentRoll(obj_id shipId)
    {
        return _getShipCurrentRoll(getLongWithNull(shipId));
    }
    private static native boolean _setShipCurrentChassisHitPoints(long shipId, float currentChassisHitPoints);
    public static boolean setShipCurrentChassisHitPoints(obj_id shipId, float currentChassisHitPoints)
    {
        return _setShipCurrentChassisHitPoints(getLongWithNull(shipId), currentChassisHitPoints);
    }
    private static native float _getShipCurrentChassisHitPoints(long shipId);
    public static float getShipCurrentChassisHitPoints(obj_id shipId)
    {
        return _getShipCurrentChassisHitPoints(getLongWithNull(shipId));
    }
    private static native boolean _setShipMaximumChassisHitPoints(long shipId, float maximumChassisHitPoints);
    public static boolean setShipMaximumChassisHitPoints(obj_id shipId, float maximumChassisHitPoints)
    {
        return _setShipMaximumChassisHitPoints(getLongWithNull(shipId), maximumChassisHitPoints);
    }
    private static native float _getShipMaximumChassisHitPoints(long shipId);
    public static float getShipMaximumChassisHitPoints(obj_id shipId)
    {
        return _getShipMaximumChassisHitPoints(getLongWithNull(shipId));
    }

    private static native void _setAggroImmuneDuration(long player, int duration);
    public static void setAggroImmuneDuration(obj_id player, int duration)
    {
        _setAggroImmuneDuration(getLongWithNull(player), duration);
    }
    private static native boolean _isAggroImmune(long player);
    public static boolean isAggroImmune(obj_id player)
    {
        return _isAggroImmune(getLongWithNull(player));
    }

    private static native int _getCombatDuration(long object);
    public static int getCombatDuration(obj_id object)
    {
        return _getCombatDuration(getLongWithNull(object));
    }

    // Hate List management

    private static native void _addHate(long object, long hateTarget, float hate);
    public static void addHate(obj_id object, obj_id hateTarget, float hate)
    {
        _addHate(getLongWithNull(object), getLongWithNull(hateTarget), hate);
    }
    private static native void _addHateDot(long object, long hateTarget, float hateAmount, int seconds);
    public static void addHateDot(obj_id object, obj_id hateTarget, float hateAmount, int seconds)
    {
        _addHateDot(getLongWithNull(object), getLongWithNull(hateTarget), hateAmount, seconds);
    }
    private static native void _setHate(long object, long hateTarget, float hate);
    public static void setHate(obj_id object, obj_id hateTarget, float hate)
    {
        _setHate(getLongWithNull(object), getLongWithNull(hateTarget), hate);
    }
    private static native void _removeHateTarget(long object, long hateTarget);
    public static void removeHateTarget(obj_id object, obj_id hateTarget)
    {
        _removeHateTarget(getLongWithNull(object), getLongWithNull(hateTarget));
    }
    private static native float _getHate(long object, long hateTarget);
    public static float getHate(obj_id object, obj_id hateTarget)
    {
        return _getHate(getLongWithNull(object), getLongWithNull(hateTarget));
    }
    private static native float _getMaxHate(long object);
    public static float getMaxHate(obj_id object)
    {
        return _getMaxHate(getLongWithNull(object));
    }
    private static native void _clearHateList(long object);
    public static void clearHateList(obj_id object)
    {
        _clearHateList(getLongWithNull(object));
    }
    private static native long _getHateTarget(long object);
    public static obj_id getHateTarget(obj_id object)
    {
        return getObjIdWithNull(_getHateTarget(getLongWithNull(object)));
    }
    private static native long[] _getHateList(long object);
    public static obj_id[] getHateList(obj_id object)
    {
        long[] _ret_long = _getHateList(getLongWithNull(object));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    private static native boolean _isOnHateList(long object, long target);
    public static boolean isOnHateList(obj_id object, obj_id target)
    {
        return _isOnHateList(getLongWithNull(object), getLongWithNull(target));
    }

    /**
     * Do not call this function unless you know what you are doing!
     * Explicitly keeps an AI in combat by resetting its hate timer.
     */
    private static native void _resetHateTimer(long object);
    public static void resetHateTimer(obj_id object)
    {
        _resetHateTimer(getLongWithNull(object));
    }


    private static native void _setAILeashTime(long object, float time);
    public static void setAILeashTime(obj_id object, float time)
    {
        _setAILeashTime(getLongWithNull(object), time);
    }

    private static native float _getAILeashTime(long object);
    public static float getAILeashTime(obj_id object)
    {
        return _getAILeashTime(getLongWithNull(object));
    }





    // General AI

    private static native boolean _aiLoggingEnabled(long ai);
    public static boolean aiLoggingEnabled(obj_id ai)
    {
        return _aiLoggingEnabled(getLongWithNull(ai));
    }

    // Ground AI only

    private static native boolean _aiIsFrozen(long ai);
    public static boolean aiIsFrozen(obj_id ai)
    {
        return _aiIsFrozen(getLongWithNull(ai));
    }
    private static native boolean _aiIsAggressive(long ai);
    public static boolean aiIsAggressive(obj_id ai)
    {
        return _aiIsAggressive(getLongWithNull(ai));
    }
    private static native boolean _aiIsStalker(long ai);
    public static boolean aiIsStalker(obj_id ai)
    {
        return _aiIsStalker(getLongWithNull(ai));
    }
    private static native boolean _aiIsKiller(long ai);
    public static boolean aiIsKiller(obj_id ai)
    {
        return _aiIsKiller(getLongWithNull(ai));
    }
    private static native void _aiTether(long ai);
    public static void aiTether(obj_id ai)
    {
        _aiTether(getLongWithNull(ai));
    }
    private static native boolean _aiIsTethered(long ai);
    public static boolean aiIsTethered(obj_id ai)
    {
        return _aiIsTethered(getLongWithNull(ai));
    }
    private static native boolean _aiIsAssist(long ai);
    public static boolean aiIsAssist(obj_id ai)
    {
        return _aiIsAssist(getLongWithNull(ai));
    }
    public static boolean aiIsGuard(obj_id ai)
    {
        return hasScript(ai, "ai.soldier");
    }
    private static native void _aiSetHomeLocation(long ai, location homeLocation);
    public static void aiSetHomeLocation(obj_id ai, location homeLocation)
    {
        _aiSetHomeLocation(getLongWithNull(ai), homeLocation);
    }
    private static native location _aiGetHomeLocation(long ai);
    public static location aiGetHomeLocation(obj_id ai)
    {
        return _aiGetHomeLocation(getLongWithNull(ai));
    }
    private static native location _aiGetLeashAnchorLocation(long ai);
    public static location aiGetLeashAnchorLocation(obj_id ai)
    {
        return _aiGetLeashAnchorLocation(getLongWithNull(ai));
    }
    public static native float aiGetLeashRadius();
    private static native float _aiGetRespectRadius(long ai, long target);
    public static float aiGetRespectRadius(obj_id ai, obj_id target)
    {
        return _aiGetRespectRadius(getLongWithNull(ai), getLongWithNull(target));
    }
    private static native float _aiGetAggroRadius(long ai);
    public static float aiGetAggroRadius(obj_id ai)
    {
        return _aiGetAggroRadius(getLongWithNull(ai));
    }
    private static native void _aiEquipPrimaryWeapon(long ai);
    public static void aiEquipPrimaryWeapon(obj_id ai)
    {
        _aiEquipPrimaryWeapon(getLongWithNull(ai));
    }
    private static native void _aiEquipSecondaryWeapon(long ai);
    public static void aiEquipSecondaryWeapon(obj_id ai)
    {
        _aiEquipSecondaryWeapon(getLongWithNull(ai));
    }
    private static native void _aiUnEquipWeapons(long ai);
    public static void aiUnEquipWeapons(obj_id ai)
    {
        _aiUnEquipWeapons(getLongWithNull(ai));
    }
    private static native boolean _aiHasPrimaryWeapon(long ai);
    public static boolean aiHasPrimaryWeapon(obj_id ai)
    {
        return _aiHasPrimaryWeapon(getLongWithNull(ai));
    }
    private static native boolean _aiHasSecondaryWeapon(long ai);
    public static boolean aiHasSecondaryWeapon(obj_id ai)
    {
        return _aiHasSecondaryWeapon(getLongWithNull(ai));
    }
    private static native boolean _aiUsingPrimaryWeapon(long ai);
    public static boolean aiUsingPrimaryWeapon(obj_id ai)
    {
        return _aiUsingPrimaryWeapon(getLongWithNull(ai));
    }
    private static native boolean _aiUsingSecondaryWeapon(long ai);
    public static boolean aiUsingSecondaryWeapon(obj_id ai)
    {
        return _aiUsingSecondaryWeapon(getLongWithNull(ai));
    }
    private static native long _aiGetPrimaryWeapon(long ai);
    public static obj_id aiGetPrimaryWeapon(obj_id ai)
    {
        return getObjIdWithNull(_aiGetPrimaryWeapon(getLongWithNull(ai)));
    }
    private static native long _aiGetSecondaryWeapon(long ai);
    public static obj_id aiGetSecondaryWeapon(obj_id ai)
    {
        return getObjIdWithNull(_aiGetSecondaryWeapon(getLongWithNull(ai)));
    }
    private static native float _aiGetMovementSpeedPercent(long ai);
    public static float aiGetMovementSpeedPercent(obj_id ai)
    {
        return _aiGetMovementSpeedPercent(getLongWithNull(ai));
    }

    /**
    * Gets the AI's movement state
    * @param mob    the object to query
    * @return       the current movement state
    */
    private static native int _aiGetMovementState(long ai);
    public static int aiGetMovementState(obj_id ai)
    {
        return _aiGetMovementState(getLongWithNull(ai));
    }

    public static range_info aiGetWeaponRangeInfo(obj_id weapon)
    {
        range_info weaponRangeInfo = getWeaponRangeInfo(weapon);

        if (weaponRangeInfo == null)
        {
            final obj_id self = getSelf();
            System.err.println("base_class::aiGetWeaponRangeInfo() NULL range_info for ai(" + self + ":" + getName(self) + ":" + getCreatureName(self) + ") weapon(" + weapon + ")");
            Thread.dumpStack();

            weaponRangeInfo = new range_info();
        }

        return weaponRangeInfo;
    }

    private static native String _aiGetCombatAction(long ai);
    public static String aiGetCombatAction(obj_id ai)
    {
        return _aiGetCombatAction(getLongWithNull(ai));
    }
    private static native int _aiGetKnockDownRecoveryTime(long ai);
    public static int aiGetKnockDownRecoveryTime(obj_id ai)
    {
        return _aiGetKnockDownRecoveryTime(getLongWithNull(ai));
    }

    // Space AI only
    // Use the wrapper methods in ship_ai

    private static native int __spaceUnitGetBehavior(long unit);
    public static int _spaceUnitGetBehavior(obj_id unit)
    {
        return __spaceUnitGetBehavior(getLongWithNull(unit));
    }
    private static native void __spaceUnitIdle(long unit);
    public static void _spaceUnitIdle(obj_id unit)
    {
        __spaceUnitIdle(getLongWithNull(unit));
    }
    private static native void __spaceUnitTrack(long unit, long target);
    public static void _spaceUnitTrack(obj_id unit, obj_id target)
    {
        __spaceUnitTrack(getLongWithNull(unit), getLongWithNull(target));
    }
    private static native void __spaceUnitMoveTo(long unit, transform[] path);
    public static void _spaceUnitMoveTo(obj_id unit, transform[] path)
    {
        __spaceUnitMoveTo(getLongWithNull(unit), path);
    }
    private static native void __spaceUnitAddPatrolPath(long unit, transform[] path);
    public static void _spaceUnitAddPatrolPath(obj_id unit, transform[] path)
    {
        __spaceUnitAddPatrolPath(getLongWithNull(unit), path);
    }
    private static native void __spaceUnitClearPatrolPath(long unit);
    public static void _spaceUnitClearPatrolPath(obj_id unit)
    {
        __spaceUnitClearPatrolPath(getLongWithNull(unit));
    }
    private static native void __spaceUnitFollow(long unit, long followedUnit, vector direction_o, float distance);
    public static void _spaceUnitFollow(obj_id unit, obj_id followedUnit, vector direction_o, float distance)
    {
        __spaceUnitFollow(getLongWithNull(unit), getLongWithNull(followedUnit), direction_o, distance);
    }
    private static native void __spaceUnitAddDamageTaken(long unit, long targetUnit, float damage);
    public static void _spaceUnitAddDamageTaken(obj_id unit, obj_id targetUnit, float damage)
    {
        __spaceUnitAddDamageTaken(getLongWithNull(unit), getLongWithNull(targetUnit), damage);
    }
    private static native void __spaceUnitSetAttackOrders(long unit, int attackOrders);
    public static void _spaceUnitSetAttackOrders(obj_id unit, int attackOrders)
    {
        __spaceUnitSetAttackOrders(getLongWithNull(unit), attackOrders);
    }
    private static native void __spaceUnitSetPilotType(long unit, String pilotType);
    public static void _spaceUnitSetPilotType(obj_id unit, String pilotType)
    {
        __spaceUnitSetPilotType(getLongWithNull(unit), pilotType);
    }
    private static native String __spaceUnitGetPilotType(long unit);
    public static String _spaceUnitGetPilotType(obj_id unit)
    {
        return __spaceUnitGetPilotType(getLongWithNull(unit));
    }
    private static native long __spaceUnitGetPrimaryAttackTarget(long unit);
    public static obj_id _spaceUnitGetPrimaryAttackTarget(obj_id unit)
    {
        return getObjIdWithNull(__spaceUnitGetPrimaryAttackTarget(getLongWithNull(unit)));
    }
    private static native long[] __spaceUnitGetAttackTargetList(long unit);
    public static obj_id[] _spaceUnitGetAttackTargetList(obj_id unit)
    {
        long[] _ret_long = __spaceUnitGetAttackTargetList(getLongWithNull(unit));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    private static native long[] __spaceUnitGetWhoIsTargetingMe(long unit);
    public static obj_id[] _spaceUnitGetWhoIsTargetingMe(obj_id unit)
    {
        long[] _ret_long = __spaceUnitGetWhoIsTargetingMe(getLongWithNull(unit));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    private static native boolean __spaceUnitIsAttacking(long unit);
    public static boolean _spaceUnitIsAttacking(obj_id unit)
    {
        return __spaceUnitIsAttacking(getLongWithNull(unit));
    }
    private static native void __spaceUnitRemoveAttackTarget(long unit, long targetUnit);
    public static void _spaceUnitRemoveAttackTarget(obj_id unit, obj_id targetUnit)
    {
        __spaceUnitRemoveAttackTarget(getLongWithNull(unit), getLongWithNull(targetUnit));
    }
    private static native void __spaceUnitSetLeashDistance(long unit, float distance);
    public static void _spaceUnitSetLeashDistance(obj_id unit, float distance)
    {
        __spaceUnitSetLeashDistance(getLongWithNull(unit), distance);
    }
    private static native void __spaceUnitSetSquadId(long unit, int squadId);
    public static void _spaceUnitSetSquadId(obj_id unit, int squadId)
    {
        __spaceUnitSetSquadId(getLongWithNull(unit), squadId);
    }
    private static native int __spaceUnitGetSquadId(long unit);
    public static int _spaceUnitGetSquadId(obj_id unit)
    {
        return __spaceUnitGetSquadId(getLongWithNull(unit));
    }
    private static native void __spaceUnitDock(long unit, long dockTarget, float timeAtDock);
    public static void _spaceUnitDock(obj_id unit, obj_id dockTarget, float timeAtDock)
    {
        __spaceUnitDock(getLongWithNull(unit), getLongWithNull(dockTarget), timeAtDock);
    }
    private static native void __spaceUnitUnDock(long unit);
    public static void _spaceUnitUnDock(obj_id unit)
    {
        __spaceUnitUnDock(getLongWithNull(unit));
    }
    private static native boolean __spaceUnitIsDocked(long unit);
    public static boolean _spaceUnitIsDocked(obj_id unit)
    {
        return __spaceUnitIsDocked(getLongWithNull(unit));
    }
    private static native boolean __spaceUnitIsDocking(long unit);
    public static boolean _spaceUnitIsDocking(obj_id unit)
    {
        return __spaceUnitIsDocking(getLongWithNull(unit));
    }
    private static native void __spaceUnitSetAutoAggroImmuneTime(long unit, float time);
    public static void _spaceUnitSetAutoAggroImmuneTime(obj_id unit, float time)
    {
        __spaceUnitSetAutoAggroImmuneTime(getLongWithNull(unit), time);
    }
    private static native boolean __spaceUnitIsAutoAggroImmune(long unit);
    public static boolean _spaceUnitIsAutoAggroImmune(obj_id unit)
    {
        return __spaceUnitIsAutoAggroImmune(getLongWithNull(unit));
    }
    private static native void __spaceUnitSetDamageAggroImmune(long unit, boolean enabled);
    public static void _spaceUnitSetDamageAggroImmune(obj_id unit, boolean enabled)
    {
        __spaceUnitSetDamageAggroImmune(getLongWithNull(unit), enabled);
    }
    private static native transform __spaceUnitGetDockTransform(long dockTarget, long dockingUnit);
    public static transform _spaceUnitGetDockTransform(obj_id dockTarget, obj_id dockingUnit)
    {
        return __spaceUnitGetDockTransform(getLongWithNull(dockTarget), getLongWithNull(dockingUnit));
    }
    private static native void __spaceUnitAddExclusiveAggro(long unit, long pilot);
    public static void _spaceUnitAddExclusiveAggro(obj_id unit, obj_id pilot)
    {
        __spaceUnitAddExclusiveAggro(getLongWithNull(unit), getLongWithNull(pilot));
    }
    private static native void __spaceUnitRemoveExclusiveAggro(long unit, long pilot);
    public static void _spaceUnitRemoveExclusiveAggro(obj_id unit, obj_id pilot)
    {
        __spaceUnitRemoveExclusiveAggro(getLongWithNull(unit), getLongWithNull(pilot));
    }

    public static native int _spaceSquadCreateSquadId();
    private static native int __spaceSquadRemoveUnit(long unit);
    public static int _spaceSquadRemoveUnit(obj_id unit)
    {
        return __spaceSquadRemoveUnit(getLongWithNull(unit));
    }
    public static native int _spaceSquadCombine(int squadId1, int squadId2);
    public static native int _spaceSquadGetSize(int squadId);
    private static native long[] __spaceSquadGetUnitList(int squadId);
    public static obj_id[] _spaceSquadGetUnitList(int squadId)
    {
        long[] _ret_long = __spaceSquadGetUnitList(squadId);
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    public static native void _spaceSquadSetFormation(int squadId, int formation);
    public static native void _spaceSquadSetFormationSpacing(int squadId, float scale);
    public static native int _spaceSquadGetFormation(int squadId);
    private static native void __spaceSquadSetLeader(int squadId, long unit);
    public static void _spaceSquadSetLeader(int squadId, obj_id unit)
    {
        __spaceSquadSetLeader(squadId, getLongWithNull(unit));
    }
    private static native long __spaceSquadGetLeader(int squadId);
    public static obj_id _spaceSquadGetLeader(int squadId)
    {
        return getObjIdWithNull(__spaceSquadGetLeader(squadId));
    }
    public static native void _spaceSquadIdle(int squadId);
    private static native void __spaceSquadTrack(int squadId, long target);
    public static void _spaceSquadTrack(int squadId, obj_id target)
    {
        __spaceSquadTrack(squadId, getLongWithNull(target));
    }
    public static native void _spaceSquadMoveTo(int squadId, transform[] path);
    public static native void _spaceSquadAddPatrolPath(int squadId, transform[] path);
    public static native void _spaceSquadClearPatrolPath(int squadId);
    private static native void __spaceSquadFollow(int squadId, long followedUnit, vector direction_o, float distance);
    public static void _spaceSquadFollow(int squadId, obj_id followedUnit, vector direction_o, float distance)
    {
        __spaceSquadFollow(squadId, getLongWithNull(followedUnit), direction_o, distance);
    }
    public static native void _spaceSquadSetGuardTarget(int squad, int targetSquad);
    public static native int _spaceSquadGetGuardTarget(int squad);
    public static native void _spaceSquadRemoveGuardTarget(int squad);
    public static native boolean _spaceSquadIsSquadIdValid(int squad);

    //-- component physics system

    private static native float     _getShipChassisSpeedMaximumModifier(long shipId);
    public static float     getShipChassisSpeedMaximumModifier(obj_id shipId)
    {
        return _getShipChassisSpeedMaximumModifier(getLongWithNull(shipId));
    }
    private static native void      _setShipChassisSpeedMaximumModifier(long shipId, float value);
    public static void      setShipChassisSpeedMaximumModifier(obj_id shipId, float value)
    {
        _setShipChassisSpeedMaximumModifier(getLongWithNull(shipId), value);
    }

    private static native float     _getShipActualAccelerationRate(long shipId);
    public static float     getShipActualAccelerationRate                   (obj_id shipId)
    {
        return _getShipActualAccelerationRate(getLongWithNull(shipId));
    }
    private static native float     _getShipActualDecelerationRate(long shipId);
    public static float     getShipActualDecelerationRate                   (obj_id shipId)
    {
        return _getShipActualDecelerationRate(getLongWithNull(shipId));
    }
    private static native float     _getShipActualPitchAccelerationRateDegrees(long shipId);
    public static float     getShipActualPitchAccelerationRateDegrees       (obj_id shipId)
    {
        return _getShipActualPitchAccelerationRateDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipActualYawAccelerationRateDegrees(long shipId);
    public static float     getShipActualYawAccelerationRateDegrees         (obj_id shipId)
    {
        return _getShipActualYawAccelerationRateDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipActualRollAccelerationRateDegrees(long shipId);
    public static float     getShipActualRollAccelerationRateDegrees        (obj_id shipId)
    {
        return _getShipActualRollAccelerationRateDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipActualPitchRateMaximumDegrees(long shipId);
    public static float     getShipActualPitchRateMaximumDegrees            (obj_id shipId)
    {
        return _getShipActualPitchRateMaximumDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipActualYawRateMaximumDegrees(long shipId);
    public static float     getShipActualYawRateMaximumDegrees              (obj_id shipId)
    {
        return _getShipActualYawRateMaximumDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipActualRollRateMaximumDegrees(long shipId);
    public static float     getShipActualRollRateMaximumDegrees             (obj_id shipId)
    {
        return _getShipActualRollRateMaximumDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipActualSpeedMaximum(long shipId);
    public static float     getShipActualSpeedMaximum                       (obj_id shipId)
    {
        return _getShipActualSpeedMaximum(getLongWithNull(shipId));
    }

    //--
    //-- new component system
    //-- jww

    public static class ship_chassis_slot_type
    {
        // The following must be kept in sync:
        // scst_short_n.stf
        // ShipChassisSlotType::Type (ShipChassisSlotType.h)
        // ShipChassisSlotTypeNamespace::s_slotTypeNames  (ShipChassisSlotType.cpp)
        // ShipChassisSlotTypeNamespace::s_slotTypeComponentTypeMapping (ShipChassisSlotType.cpp)
        // ship_chassis_slot_type (base_class.java)
        // ship_chassis_slot_type::names (base_class.java)
        private static int private_counter = 0;

        public static final int SCST_reactor          = private_counter++;
        public static final int SCST_engine           = private_counter++;
        public static final int SCST_shield_0         = private_counter++;
        public static final int SCST_shield_1         = private_counter++;
        public static final int SCST_armor_0          = private_counter++;
        public static final int SCST_armor_1          = private_counter++;
        public static final int SCST_capacitor        = private_counter++;
        public static final int SCST_booster          = private_counter++;
        public static final int SCST_droid_interface  = private_counter++;
        public static final int SCST_bridge           = private_counter++;
        public static final int SCST_hangar           = private_counter++;
        public static final int SCST_targeting_station = private_counter++;
        public static final int SCST_cargo_hold       = private_counter++;
        public static final int SCST_modification_0   = private_counter++;
        public static final int SCST_modification_1   = private_counter++;
        public static final int SCST_weapon_first     = private_counter++; // the first weapon index, inclusive
        public static final int SCST_weapon_0         = SCST_weapon_first;
        public static final int SCST_weapon_1         = private_counter++;
        public static final int SCST_weapon_2         = private_counter++;
        public static final int SCST_weapon_3         = private_counter++;
        public static final int SCST_weapon_4         = private_counter++;
        public static final int SCST_weapon_5         = private_counter++;
        public static final int SCST_weapon_6         = private_counter++;
        public static final int SCST_weapon_7         = private_counter++;
        public static final int SCST_weapon_8         = private_counter++;
        public static final int SCST_weapon_9         = private_counter++;
        public static final int SCST_weapon_10        = private_counter++;
        public static final int SCST_weapon_11        = private_counter++;
        public static final int SCST_weapon_12        = private_counter++;
        public static final int SCST_weapon_13        = private_counter++;
        public static final int SCST_weapon_14        = private_counter++;
        public static final int SCST_weapon_15        = private_counter++;
        public static final int SCST_weapon_16        = private_counter++;
        public static final int SCST_weapon_17        = private_counter++;
        public static final int SCST_weapon_18        = private_counter++;
        public static final int SCST_weapon_19        = private_counter++;
        public static final int SCST_weapon_20        = private_counter++;
        public static final int SCST_weapon_21        = private_counter++;
        public static final int SCST_weapon_22        = private_counter++;
        public static final int SCST_weapon_23        = private_counter++;
        public static final int SCST_weapon_24        = private_counter++;
        public static final int SCST_weapon_25        = private_counter++;
        public static final int SCST_weapon_26        = private_counter++;
        public static final int SCST_weapon_27        = private_counter++;
        public static final int SCST_weapon_28        = private_counter++;
        public static final int SCST_weapon_29        = private_counter++;
        public static final int SCST_weapon_30        = private_counter++;
        public static final int SCST_weapon_31        = private_counter++;
        public static final int SCST_weapon_32        = private_counter++;
        public static final int SCST_weapon_33        = private_counter++;
        public static final int SCST_weapon_34        = private_counter++;
        public static final int SCST_weapon_35        = private_counter++;
        public static final int SCST_weapon_36        = private_counter++;
        public static final int SCST_weapon_37        = private_counter++;
        public static final int SCST_weapon_38        = private_counter++;
        public static final int SCST_weapon_39        = private_counter++;
        public static final int SCST_weapon_40        = private_counter++;
        public static final int SCST_weapon_41        = private_counter++;
        public static final int SCST_weapon_42        = private_counter++;
        public static final int SCST_weapon_43        = private_counter++;
        public static final int SCST_weapon_44        = private_counter++;
        public static final int SCST_weapon_45        = private_counter++;
        public static final int SCST_weapon_46        = private_counter++;
        public static final int SCST_weapon_47        = private_counter++;
        public static final int SCST_weapon_48        = private_counter++;
        public static final int SCST_weapon_49        = private_counter++;
        public static final int SCST_weapon_50        = private_counter++;
        public static final int SCST_weapon_51        = private_counter++;
        public static final int SCST_weapon_52        = private_counter++;
        public static final int SCST_weapon_53        = private_counter++;
        public static final int SCST_weapon_54        = private_counter++;
        public static final int SCST_weapon_55        = private_counter++;
        public static final int SCST_weapon_56        = private_counter++;
        public static final int SCST_weapon_57        = private_counter++;
        public static final int SCST_weapon_58        = private_counter++;
        public static final int SCST_weapon_59        = private_counter++;
        public static final int SCST_weapon_60        = private_counter++;
        public static final int SCST_weapon_61        = private_counter++;
        public static final int SCST_weapon_62        = private_counter++;
        public static final int SCST_weapon_63        = private_counter++;
        public static final int SCST_weapon_64        = private_counter++;
        public static final int SCST_weapon_65        = private_counter++;
        public static final int SCST_weapon_66        = private_counter++;
        public static final int SCST_weapon_67        = private_counter++;
        public static final int SCST_weapon_68        = private_counter++;
        public static final int SCST_weapon_69        = private_counter++;
        public static final int SCST_weapon_70        = private_counter++;
        public static final int SCST_weapon_71        = private_counter++;
        public static final int SCST_weapon_72        = private_counter++;
        public static final int SCST_weapon_73        = private_counter++;
        public static final int SCST_weapon_74        = private_counter++;
        public static final int SCST_weapon_75        = private_counter++;
        public static final int SCST_weapon_76        = private_counter++;
        public static final int SCST_weapon_77        = private_counter++;
        public static final int SCST_weapon_78        = private_counter++;
        public static final int SCST_weapon_79        = private_counter++;
        public static final int SCST_weapon_80        = private_counter++;
        public static final int SCST_weapon_81        = private_counter++;
        public static final int SCST_weapon_82        = private_counter++;
        public static final int SCST_weapon_83        = private_counter++;
        public static final int SCST_weapon_84        = private_counter++;
        public static final int SCST_weapon_85        = private_counter++;
        public static final int SCST_weapon_86        = private_counter++;
        public static final int SCST_weapon_87        = private_counter++;
        public static final int SCST_weapon_88        = private_counter++;
        public static final int SCST_weapon_89        = private_counter++;
        public static final int SCST_weapon_90        = private_counter++;
        public static final int SCST_weapon_91        = private_counter++;
        public static final int SCST_weapon_92        = private_counter++;
        public static final int SCST_weapon_93        = private_counter++;
        public static final int SCST_weapon_94        = private_counter++;
        public static final int SCST_weapon_95        = private_counter++;
        public static final int SCST_weapon_96        = private_counter++;
        public static final int SCST_weapon_97        = private_counter++;
        public static final int SCST_weapon_98        = private_counter++;
        public static final int SCST_weapon_99        = private_counter++;
        public static final int SCST_weapon_last      = SCST_weapon_99;     // the last weapon index, inclusive
        public static final int SCST_num_types        = private_counter++;

        private static final int[] TYPE_ARRAY = new int []
        {
            ship_component_type.SCT_reactor,
            ship_component_type.SCT_engine,
            ship_component_type.SCT_shield,
            ship_component_type.SCT_shield,
            ship_component_type.SCT_armor,
            ship_component_type.SCT_armor,
            ship_component_type.SCT_capacitor,
            ship_component_type.SCT_booster,
            ship_component_type.SCT_droid_interface,
            ship_component_type.SCT_bridge,
            ship_component_type.SCT_hangar,
            ship_component_type.SCT_targeting_station,
            ship_component_type.SCT_cargo_hold,
            ship_component_type.SCT_modification,
        };

        // The following must be kept in sync:
        // scst_short_n.stf
        // ShipChassisSlotType::Type (ShipChassisSlotType.h)
        // ShipChassisSlotTypeNamespace::s_slotTypeNames  (ShipChassisSlotType.cpp)
        // ShipChassisSlotTypeNamespace::s_slotTypeComponentTypeMapping (ShipChassisSlotType.cpp)
        // ship_chassis_slot_type (base_class.java)
        // ship_chassis_slot_type::names (base_class.java)
        public static final String [] names = new String []
        {
            "reactor",
            "engine",
            "shield_0",
            "shield_1",
            "armor_0",
            "armor_1",
            "capacitor",
            "booster",
            "droid_interface",
            "bridge",
            "hangar",
            "targeting_station",
            "cargo_hold",
            "modification_0",
            "modification_1",
            "weapon_0",
            "weapon_1",
            "weapon_2",
            "weapon_3",
            "weapon_4",
            "weapon_5",
            "weapon_6",
            "weapon_7",
            "weapon_8",
            "weapon_9",
            "weapon_10",
            "weapon_11",
            "weapon_12",
            "weapon_13",
            "weapon_14",
            "weapon_15",
            "weapon_16",
            "weapon_17",
            "weapon_18",
            "weapon_19",
            "weapon_20",
            "weapon_21",
            "weapon_22",
            "weapon_23",
            "weapon_24",
            "weapon_25",
            "weapon_26",
            "weapon_27",
            "weapon_28",
            "weapon_29",
            "weapon_30",
            "weapon_31",
            "weapon_32",
            "weapon_33",
            "weapon_34",
            "weapon_35",
            "weapon_36",
            "weapon_37",
            "weapon_38",
            "weapon_39",
            "weapon_40",
            "weapon_41",
            "weapon_42",
            "weapon_43",
            "weapon_44",
            "weapon_45",
            "weapon_46",
            "weapon_47",
            "weapon_48",
            "weapon_49",
            "weapon_50",
            "weapon_51",
            "weapon_52",
            "weapon_53",
            "weapon_54",
            "weapon_55",
            "weapon_56",
            "weapon_57",
            "weapon_58",
            "weapon_59",
            "weapon_60",
            "weapon_61",
            "weapon_62",
            "weapon_63",
            "weapon_64",
            "weapon_65",
            "weapon_66",
            "weapon_67",
            "weapon_68",
            "weapon_69",
            "weapon_70",
            "weapon_71",
            "weapon_72",
            "weapon_73",
            "weapon_74",
            "weapon_75",
            "weapon_76",
            "weapon_77",
            "weapon_78",
            "weapon_79",
            "weapon_80",
            "weapon_81",
            "weapon_82",
            "weapon_83",
            "weapon_84",
            "weapon_85",
            "weapon_86",
            "weapon_87",
            "weapon_88",
            "weapon_89",
            "weapon_90",
            "weapon_91",
            "weapon_92",
            "weapon_93",
            "weapon_94",
            "weapon_95",
            "weapon_96",
            "weapon_97",
            "weapon_98",
            "weapon_99",
            "none"
        };

        public static int getComponentTypeForSlot(int slotType)
        {

            if((slotType<SCST_reactor)||(slotType>SCST_num_types))
            {
                return SCST_num_types;
            }
            if((slotType>=SCST_weapon_first)&&(slotType<=SCST_weapon_last))
            {
                return ship_component_type.SCT_weapon;
            }
            else
            {
                return TYPE_ARRAY[slotType];
            }
        }
        public static int getTypeByName (String name)
        {
            for (int i = 0; i < names.length; ++i)
            {
                if (names [i].equals (name))
                    return i;
            }

            return SCST_num_types;
        }

        public static String getNameByType (int slot)
        {
            if(slot < SCST_reactor || slot > SCST_num_types)
                return "none";

            return names[slot];
        }
    };

    public static class ship_component_type
    {
        private static int private_counter = 0;

        public static final int SCT_reactor          = private_counter++;
        public static final int SCT_engine           = private_counter++;
        public static final int SCT_shield           = private_counter++;
        public static final int SCT_armor            = private_counter++;
        public static final int SCT_weapon           = private_counter++;
        public static final int SCT_capacitor        = private_counter++;
        public static final int SCT_booster          = private_counter++;
        public static final int SCT_droid_interface  = private_counter++;
        public static final int SCT_bridge           = private_counter++;
        public static final int SCT_hangar           = private_counter++;
        public static final int SCT_targeting_station = private_counter++;
        public static final int SCT_cargo_hold       = private_counter++;
        public static final int SCT_modification     = private_counter++;
        public static final int SCT_num_types        = private_counter++;

        public static final String [] names = new String []
        {
            "reactor",
            "engine",
            "shield",
            "armor",
            "weapon",
            "capacitor",
            "booster",
            "droid_interface",
            "bridge",
            "hangar",
            "targeting_station",
            "cargo_hold",
            "modification"
        };

        public static int getTypeByName (String name)
        {
            for (int i = 0; i < names.length; ++i)
            {
                if (names [i].equals (name))
                    return i;
            }

            return SCT_num_types;
        }
    };

    public static class ship_component_flags
    {
        public static final int SCF_disabled       = 0x0001;
        public static final int SCF_lowPower       = 0x0002;
        public static final int SCF_active         = 0x0004;
        public static final int SCF_demolished     = 0x0008;
        public static final int SCF_reverse_engineered    = 0x0010;
        public static final int SCF_shieldsFront = 0x0020; //this flag should never be set via script
        public static final int SCF_shieldsBack  = 0x0040; //this flag should never be set via script
        public static final int SCF_disabledNeedsPower = 0x0080;

    };

    private static native String    _getShipChassisType(long shipId);
    public static String    getShipChassisType                            (obj_id shipId)
    {
        return _getShipChassisType(getLongWithNull(shipId));
    }
    private static native float     _getChassisComponentMassCurrent(long shipId);
    public static float     getChassisComponentMassCurrent                (obj_id shipId)
    {
        return _getChassisComponentMassCurrent(getLongWithNull(shipId));
    }
    private static native float     _getChassisComponentMassMaximum(long shipId);
    public static float     getChassisComponentMassMaximum                (obj_id shipId)
    {
        return _getChassisComponentMassMaximum(getLongWithNull(shipId));
    }
    private static native boolean   _setChassisComponentMassMaximum(long shipId, float chassisComponentMassMaximum);
    public static boolean   setChassisComponentMassMaximum                (obj_id shipId, float chassisComponentMassMaximum)
    {
        return _setChassisComponentMassMaximum(getLongWithNull(shipId), chassisComponentMassMaximum);
    }

    private static native boolean   _isShipSlotInstalled(long shipId, int chassisSlot);
    public static boolean   isShipSlotInstalled                           (obj_id shipId, int chassisSlot)
    {
        return _isShipSlotInstalled(getLongWithNull(shipId), chassisSlot);
    }
    private static native boolean   _isShipComponentDisabled(long shipId, int chassisSlot);
    public static boolean   isShipComponentDisabled                       (obj_id shipId, int chassisSlot)
    {
        return _isShipComponentDisabled(getLongWithNull(shipId), chassisSlot);
    }
    private static native boolean   _isShipComponentLowPower(long shipId, int chassisSlot);
    public static boolean   isShipComponentLowPower                       (obj_id shipId, int chassisSlot)
    {
        return _isShipComponentLowPower(getLongWithNull(shipId), chassisSlot);
    }
    private static native boolean   _isShipComponentDisabledNeedsPower(long shipId, int chassisSlot);
    public static boolean   isShipComponentDisabledNeedsPower             (obj_id shipId, int chassisSlot)
    {
        return _isShipComponentDisabledNeedsPower(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentArmorHitpointsMaximum(long shipId, int chassisSlot);
    public static float     getShipComponentArmorHitpointsMaximum         (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentArmorHitpointsMaximum(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentArmorHitpointsCurrent(long shipId, int chassisSlot);
    public static float     getShipComponentArmorHitpointsCurrent         (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentArmorHitpointsCurrent(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentEfficiencyGeneral(long shipId, int chassisSlot);
    public static float     getShipComponentEfficiencyGeneral             (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentEfficiencyGeneral(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentEfficiencyEnergy(long shipId, int chassisSlot);
    public static float     getShipComponentEfficiencyEnergy              (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentEfficiencyEnergy(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentEnergyMaintenanceRequirement(long shipId, int chassisSlot);
    public static float     getShipComponentEnergyMaintenanceRequirement  (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentEnergyMaintenanceRequirement(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentMass(long shipId, int chassisSlot);
    public static float     getShipComponentMass                          (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentMass(getLongWithNull(shipId), chassisSlot);
    }
    private static native int       _getShipComponentCrc(long shipId, int chassisSlot);
    public static int       getShipComponentCrc                           (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentCrc(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentHitpointsCurrent(long shipId, int chassisSlot);
    public static float     getShipComponentHitpointsCurrent              (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentHitpointsCurrent(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipComponentHitpointsMaximum(long shipId, int chassisSlot);
    public static float     getShipComponentHitpointsMaximum              (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentHitpointsMaximum(getLongWithNull(shipId), chassisSlot);
    }
    private static native int       _getShipComponentFlags(long shipId, int chassisSlot);
    public static int       getShipComponentFlags                         (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentFlags(getLongWithNull(shipId), chassisSlot);
    }
    private static native String    _getShipComponentName(long shipId, int chassisSlot);
    public static String    getShipComponentName                          (obj_id shipId, int chassisSlot)
    {
        return _getShipComponentName(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponDamageMaximum(long shipId, int chassisSlot);
    public static float     getShipWeaponDamageMaximum                    (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponDamageMaximum(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponDamageMinimum(long shipId, int chassisSlot);
    public static float     getShipWeaponDamageMinimum                    (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponDamageMinimum(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponEffectivenessShields(long shipId, int chassisSlot);
    public static float     getShipWeaponEffectivenessShields             (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponEffectivenessShields(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponEffectivenessArmor(long shipId, int chassisSlot);
    public static float     getShipWeaponEffectivenessArmor               (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponEffectivenessArmor(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponEnergyPerShot(long shipId, int chassisSlot);
    public static float     getShipWeaponEnergyPerShot                    (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponEnergyPerShot(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponRefireRate(long shipId, int chassisSlot);
    public static float     getShipWeaponRefireRate                       (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponRefireRate(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponActualRefireRate(long shipId, int chassisSlot);
    public static float     getShipWeaponActualRefireRate                 (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponActualRefireRate(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipWeaponEfficiencyRefireRate(long shipId, int chassisSlot);
    public static float     getShipWeaponEfficiencyRefireRate             (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponEfficiencyRefireRate(getLongWithNull(shipId), chassisSlot);
    }
    private static native int       _getShipWeaponAmmoCurrent(long shipId, int chassisSlot);
    public static int       getShipWeaponAmmoCurrent                      (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponAmmoCurrent(getLongWithNull(shipId), chassisSlot);
    }
    private static native int       _getShipWeaponAmmoMaximum(long shipId, int chassisSlot);
    public static int       getShipWeaponAmmoMaximum                      (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponAmmoMaximum(getLongWithNull(shipId), chassisSlot);
    }
    private static native int       _getShipWeaponAmmoType(long shipId, int chassisSlot);
    public static int       getShipWeaponAmmoType                         (obj_id shipId, int chassisSlot)
    {
        return _getShipWeaponAmmoType(getLongWithNull(shipId), chassisSlot);
    }
    private static native float     _getShipShieldHitpointsFrontCurrent(long shipId);
    public static float     getShipShieldHitpointsFrontCurrent            (obj_id shipId)
    {
        return _getShipShieldHitpointsFrontCurrent(getLongWithNull(shipId));
    }
    private static native float     _getShipShieldHitpointsFrontMaximum(long shipId);
    public static float     getShipShieldHitpointsFrontMaximum            (obj_id shipId)
    {
        return _getShipShieldHitpointsFrontMaximum(getLongWithNull(shipId));
    }
    private static native float     _getShipShieldHitpointsBackCurrent(long shipId);
    public static float     getShipShieldHitpointsBackCurrent             (obj_id shipId)
    {
        return _getShipShieldHitpointsBackCurrent(getLongWithNull(shipId));
    }
    private static native float     _getShipShieldHitpointsBackMaximum(long shipId);
    public static float     getShipShieldHitpointsBackMaximum             (obj_id shipId)
    {
        return _getShipShieldHitpointsBackMaximum(getLongWithNull(shipId));
    }
    private static native float     _getShipShieldRechargeRate(long shipId);
    public static float     getShipShieldRechargeRate                     (obj_id shipId)
    {
        return _getShipShieldRechargeRate(getLongWithNull(shipId));
    }
    private static native float     _getShipCapacitorEnergyCurrent(long shipId);
    public static float     getShipCapacitorEnergyCurrent                 (obj_id shipId)
    {
        return _getShipCapacitorEnergyCurrent(getLongWithNull(shipId));
    }
    private static native float     _getShipCapacitorEnergyMaximum(long shipId);
    public static float     getShipCapacitorEnergyMaximum                 (obj_id shipId)
    {
        return _getShipCapacitorEnergyMaximum(getLongWithNull(shipId));
    }
    private static native float     _getShipCapacitorEnergyRechargeRate(long shipId);
    public static float     getShipCapacitorEnergyRechargeRate            (obj_id shipId)
    {
        return _getShipCapacitorEnergyRechargeRate(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineAccelerationRate(long shipId);
    public static float     getShipEngineAccelerationRate                 (obj_id shipId)
    {
        return _getShipEngineAccelerationRate(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineDecelerationRate(long shipId);
    public static float     getShipEngineDecelerationRate                 (obj_id shipId)
    {
        return _getShipEngineDecelerationRate(getLongWithNull(shipId));
    }
    private static native float     _getShipEnginePitchAccelerationRateDegrees(long shipId);
    public static float     getShipEnginePitchAccelerationRateDegrees     (obj_id shipId)
    {
        return _getShipEnginePitchAccelerationRateDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineYawAccelerationRateDegrees(long shipId);
    public static float     getShipEngineYawAccelerationRateDegrees       (obj_id shipId)
    {
        return _getShipEngineYawAccelerationRateDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineRollAccelerationRateDegrees(long shipId);
    public static float     getShipEngineRollAccelerationRateDegrees      (obj_id shipId)
    {
        return _getShipEngineRollAccelerationRateDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipEnginePitchRateMaximumDegrees(long shipId);
    public static float     getShipEnginePitchRateMaximumDegrees          (obj_id shipId)
    {
        return _getShipEnginePitchRateMaximumDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineYawRateMaximumDegrees(long shipId);
    public static float     getShipEngineYawRateMaximumDegrees            (obj_id shipId)
    {
        return _getShipEngineYawRateMaximumDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineRollRateMaximumDegrees(long shipId);
    public static float     getShipEngineRollRateMaximumDegrees           (obj_id shipId)
    {
        return _getShipEngineRollRateMaximumDegrees(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineSpeedMaximum(long shipId);
    public static float     getShipEngineSpeedMaximum                     (obj_id shipId)
    {
        return _getShipEngineSpeedMaximum(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineSpeedRotationFactorMaximum(long shipId);
    public static float     getShipEngineSpeedRotationFactorMaximum       (obj_id shipId)
    {
        return _getShipEngineSpeedRotationFactorMaximum(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineSpeedRotationFactorMinimum(long shipId);
    public static float     getShipEngineSpeedRotationFactorMinimum       (obj_id shipId)
    {
        return _getShipEngineSpeedRotationFactorMinimum(getLongWithNull(shipId));
    }
    private static native float     _getShipEngineSpeedRotationFactorOptimal(long shipId);
    public static float     getShipEngineSpeedRotationFactorOptimal       (obj_id shipId)
    {
        return _getShipEngineSpeedRotationFactorOptimal(getLongWithNull(shipId));
    }
    private static native float     _getShipReactorEnergyGenerationRate(long shipId);
    public static float     getShipReactorEnergyGenerationRate            (obj_id shipId)
    {
        return _getShipReactorEnergyGenerationRate(getLongWithNull(shipId));
    }
    private static native float     _getShipBoosterEnergyCurrent(long shipId);
    public static float     getShipBoosterEnergyCurrent                   (obj_id shipId)
    {
        return _getShipBoosterEnergyCurrent(getLongWithNull(shipId));
    }
    private static native float     _getShipBoosterEnergyMaximum(long shipId);
    public static float     getShipBoosterEnergyMaximum                   (obj_id shipId)
    {
        return _getShipBoosterEnergyMaximum(getLongWithNull(shipId));
    }
    private static native float     _getShipBoosterEnergyRechargeRate(long shipId);
    public static float     getShipBoosterEnergyRechargeRate              (obj_id shipId)
    {
        return _getShipBoosterEnergyRechargeRate(getLongWithNull(shipId));
    }
    private static native float     _getShipBoosterEnergyConsumptionRate(long shipId);
    public static float     getShipBoosterEnergyConsumptionRate           (obj_id shipId)
    {
        return _getShipBoosterEnergyConsumptionRate(getLongWithNull(shipId));
    }
    private static native float     _getShipBoosterAcceleration(long shipId);
    public static float     getShipBoosterAcceleration                    (obj_id shipId)
    {
        return _getShipBoosterAcceleration(getLongWithNull(shipId));
    }
    private static native float     _getShipBoosterSpeedMaximum(long shipId);
    public static float     getShipBoosterSpeedMaximum                    (obj_id shipId)
    {
        return _getShipBoosterSpeedMaximum(getLongWithNull(shipId));
    }
    private static native boolean   _isShipBoosterActive(long shipId);
    public static boolean   isShipBoosterActive                           (obj_id shipId)
    {
        return _isShipBoosterActive(getLongWithNull(shipId));
    }
    private static native float     _getShipDroidInterfaceCommandSpeed(long shipId);
    public static float     getShipDroidInterfaceCommandSpeed             (obj_id shipId)
    {
        return _getShipDroidInterfaceCommandSpeed(getLongWithNull(shipId));
    }
    private static native int       _getShipCargoHoldContentsMaximum(long shipId);
    public static int       getShipCargoHoldContentsMaximum               (obj_id shipId)
    {
        return _getShipCargoHoldContentsMaximum(getLongWithNull(shipId));
    }
    private static native int       _getShipCargoHoldContentsCurrent(long shipId);
    public static int       getShipCargoHoldContentsCurrent               (obj_id shipId)
    {
        return _getShipCargoHoldContentsCurrent(getLongWithNull(shipId));
    }
    private static native int       _getShipCargoHoldContent(long shipId, long resourceTypeId);
    public static int       getShipCargoHoldContent                       (obj_id shipId, obj_id resourceTypeId)
    {
        return _getShipCargoHoldContent(getLongWithNull(shipId), getLongWithNull(resourceTypeId));
    }
    private static native long[]  _getShipCargoHoldContentsResourceTypes(long shipId);
    public static obj_id[]  getShipCargoHoldContentsResourceTypes         (obj_id shipId)
    {
        long[] _ret_long = _getShipCargoHoldContentsResourceTypes(getLongWithNull(shipId));
        obj_id[] _ret_obj_id = null;
        if (_ret_long != null)
        {
            _ret_obj_id = new obj_id[_ret_long.length];
            for (int _i = 0; _i < _ret_long.length; ++_i)
                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
        }
        return _ret_obj_id;
    }
    private static native int[]     _getShipCargoHoldContentsAmounts(long shipId);
    public static int[]     getShipCargoHoldContentsAmounts               (obj_id shipId)
    {
        return _getShipCargoHoldContentsAmounts(getLongWithNull(shipId));
    }

    /**
    * returns the content amount in a hold for the specified resource class.  This function picks the first resource type of this class
    */
    public static int        getShipCargoHoldContent(obj_id shipId, String resourceClassName)
    {
        obj_id[] resourceTypes = getResourceTypes(resourceClassName);
        if (resourceTypes.length <= 0)
            return 0;

        return getShipCargoHoldContent(shipId, resourceTypes[0]);
    }


    //-- setters for all components

    private static native void       _setShipComponentArmorHitpointsMaximum(long shipId, int chassisSlot, float componentArmorHitpointsMaximum);
    public static void       setShipComponentArmorHitpointsMaximum        (obj_id shipId, int chassisSlot, float componentArmorHitpointsMaximum)
    {
        _setShipComponentArmorHitpointsMaximum(getLongWithNull(shipId), chassisSlot, componentArmorHitpointsMaximum);
    }
    private static native void       _setShipComponentArmorHitpointsCurrent(long shipId, int chassisSlot, float componentArmorHitpointsCurrent);
    public static void       setShipComponentArmorHitpointsCurrent        (obj_id shipId, int chassisSlot, float componentArmorHitpointsCurrent)
    {
        _setShipComponentArmorHitpointsCurrent(getLongWithNull(shipId), chassisSlot, componentArmorHitpointsCurrent);
    }
    private static native void       _setShipComponentEfficiencyGeneral(long shipId, int chassisSlot, float componentEfficiencyGeneral);
    public static void       setShipComponentEfficiencyGeneral            (obj_id shipId, int chassisSlot, float componentEfficiencyGeneral)
    {
        _setShipComponentEfficiencyGeneral(getLongWithNull(shipId), chassisSlot, componentEfficiencyGeneral);
    }
    private static native void       _setShipComponentEfficiencyEnergy(long shipId, int chassisSlot, float componentEfficiencyEnergy);
    public static void       setShipComponentEfficiencyEnergy             (obj_id shipId, int chassisSlot, float componentEfficiencyEnergy)
    {
        _setShipComponentEfficiencyEnergy(getLongWithNull(shipId), chassisSlot, componentEfficiencyEnergy);
    }
    private static native void       _setShipComponentEnergyMaintenanceRequirement(long shipId, int chassisSlot, float componentEnergyMaintenanceRequirement);
    public static void       setShipComponentEnergyMaintenanceRequirement (obj_id shipId, int chassisSlot, float componentEnergyMaintenanceRequirement)
    {
        _setShipComponentEnergyMaintenanceRequirement(getLongWithNull(shipId), chassisSlot, componentEnergyMaintenanceRequirement);
    }
    private static native void       _setShipComponentMass(long shipId, int chassisSlot, float componentMass);
    public static void       setShipComponentMass                         (obj_id shipId, int chassisSlot, float componentMass)
    {
        _setShipComponentMass(getLongWithNull(shipId), chassisSlot, componentMass);
    }
    private static native void       _setShipComponentHitpointsCurrent(long shipId, int chassisSlot, float componentHitpointsCurrent);
    public static void       setShipComponentHitpointsCurrent             (obj_id shipId, int chassisSlot, float componentHitpointsCurrent)
    {
        _setShipComponentHitpointsCurrent(getLongWithNull(shipId), chassisSlot, componentHitpointsCurrent);
    }
    private static native void       _setShipComponentHitpointsMaximum(long shipId, int chassisSlot, float componentHitpointsMaximum);
    public static void       setShipComponentHitpointsMaximum             (obj_id shipId, int chassisSlot, float componentHitpointsMaximum)
    {
        _setShipComponentHitpointsMaximum(getLongWithNull(shipId), chassisSlot, componentHitpointsMaximum);
    }
    private static native void       _setShipComponentFlags(long shipId, int chassisSlot, int componentFlags);
    public static void       setShipComponentFlags                        (obj_id shipId, int chassisSlot, int componentFlags)
    {
        _setShipComponentFlags(getLongWithNull(shipId), chassisSlot, componentFlags);
    }
    private static native void       _setShipComponentName(long shipId, int chassisSlot, String componentName);
    public static void       setShipComponentName                         (obj_id shipId, int chassisSlot, String componentName)
    {
        _setShipComponentName(getLongWithNull(shipId), chassisSlot, componentName);
    }
    private static native void       _setShipComponentDisabled(long shipId, int chassisSlot, boolean disabled);
    public static void       setShipComponentDisabled                     (obj_id shipId, int chassisSlot, boolean disabled)
    {
        _setShipComponentDisabled(getLongWithNull(shipId), chassisSlot, disabled);
    }
    private static native void       _setShipComponentLowPower(long shipId, int chassisSlot, boolean lowPower);
    public static void       setShipComponentLowPower                     (obj_id shipId, int chassisSlot, boolean lowPower)
    {
        _setShipComponentLowPower(getLongWithNull(shipId), chassisSlot, lowPower);
    }
    private static native void       _setShipComponentDisabledNeedsPower(long shipId, int chassisSlot, boolean disabled);
    public static void       setShipComponentDisabledNeedsPower           (obj_id shipId, int chassisSlot, boolean disabled)
    {
        _setShipComponentDisabledNeedsPower(getLongWithNull(shipId), chassisSlot, disabled);
    }
    private static native void       _setShipWeaponDamageMaximum(long shipId, int chassisSlot, float weaponDamageMaximum);
    public static void       setShipWeaponDamageMaximum                   (obj_id shipId, int chassisSlot, float weaponDamageMaximum)
    {
        _setShipWeaponDamageMaximum(getLongWithNull(shipId), chassisSlot, weaponDamageMaximum);
    }
    private static native void       _setShipWeaponDamageMinimum(long shipId, int chassisSlot, float weaponDamageMinimum);
    public static void       setShipWeaponDamageMinimum                   (obj_id shipId, int chassisSlot, float weaponDamageMinimum)
    {
        _setShipWeaponDamageMinimum(getLongWithNull(shipId), chassisSlot, weaponDamageMinimum);
    }
    private static native void       _setShipWeaponEffectivenessShields(long shipId, int chassisSlot, float weaponEffectivenessShields);
    public static void       setShipWeaponEffectivenessShields            (obj_id shipId, int chassisSlot, float weaponEffectivenessShields)
    {
        _setShipWeaponEffectivenessShields(getLongWithNull(shipId), chassisSlot, weaponEffectivenessShields);
    }
    private static native void       _setShipWeaponEffectivenessArmor(long shipId, int chassisSlot, float weaponEffectivenessArmor);
    public static void       setShipWeaponEffectivenessArmor              (obj_id shipId, int chassisSlot, float weaponEffectivenessArmor)
    {
        _setShipWeaponEffectivenessArmor(getLongWithNull(shipId), chassisSlot, weaponEffectivenessArmor);
    }
    private static native void       _setShipWeaponEnergyPerShot(long shipId, int chassisSlot, float weaponEnergyPerShot);
    public static void       setShipWeaponEnergyPerShot                   (obj_id shipId, int chassisSlot, float weaponEnergyPerShot)
    {
        _setShipWeaponEnergyPerShot(getLongWithNull(shipId), chassisSlot, weaponEnergyPerShot);
    }
    private static native void       _setShipWeaponRefireRate(long shipId, int chassisSlot, float weaponRefireRate);
    public static void       setShipWeaponRefireRate                      (obj_id shipId, int chassisSlot, float weaponRefireRate)
    {
        _setShipWeaponRefireRate(getLongWithNull(shipId), chassisSlot, weaponRefireRate);
    }
    private static native void       _setShipWeaponEfficiencyRefireRate(long shipId, int chassisSlot, float weaponEfficiencyRefireRate);
    public static void       setShipWeaponEfficiencyRefireRate            (obj_id shipId, int chassisSlot, float weaponEfficiencyRefireRate)
    {
        _setShipWeaponEfficiencyRefireRate(getLongWithNull(shipId), chassisSlot, weaponEfficiencyRefireRate);
    }
    private static native void       _setShipWeaponAmmoCurrent(long shipId, int chassisSlot, int ammoCurrent);
    public static void       setShipWeaponAmmoCurrent                     (obj_id shipId, int chassisSlot, int ammoCurrent)
    {
        _setShipWeaponAmmoCurrent(getLongWithNull(shipId), chassisSlot, ammoCurrent);
    }
    private static native void       _setShipWeaponAmmoMaximum(long shipId, int chassisSlot, int ammoMaximum);
    public static void       setShipWeaponAmmoMaximum                     (obj_id shipId, int chassisSlot, int ammoMaximum)
    {
        _setShipWeaponAmmoMaximum(getLongWithNull(shipId), chassisSlot, ammoMaximum);
    }
    private static native void       _setShipWeaponAmmoType(long shipId, int chassisSlot, int ammoType);
    public static void       setShipWeaponAmmoType                        (obj_id shipId, int chassisSlot, int ammoType)
    {
        _setShipWeaponAmmoType(getLongWithNull(shipId), chassisSlot, ammoType);
    }
    private static native void       _setShipShieldHitpointsFrontCurrent(long shipId, float shieldHitpointsCurrent);
    public static void       setShipShieldHitpointsFrontCurrent           (obj_id shipId, float shieldHitpointsCurrent)
    {
        _setShipShieldHitpointsFrontCurrent(getLongWithNull(shipId), shieldHitpointsCurrent);
    }
    private static native void       _setShipShieldHitpointsFrontMaximum(long shipId, float shieldHitpointsMaximum);
    public static void       setShipShieldHitpointsFrontMaximum           (obj_id shipId, float shieldHitpointsMaximum)
    {
        _setShipShieldHitpointsFrontMaximum(getLongWithNull(shipId), shieldHitpointsMaximum);
    }
    private static native void       _setShipShieldHitpointsBackCurrent(long shipId, float shieldHitpointsCurrent);
    public static void       setShipShieldHitpointsBackCurrent            (obj_id shipId, float shieldHitpointsCurrent)
    {
        _setShipShieldHitpointsBackCurrent(getLongWithNull(shipId), shieldHitpointsCurrent);
    }
    private static native void       _setShipShieldHitpointsBackMaximum(long shipId, float shieldHitpointsMaximum);
    public static void       setShipShieldHitpointsBackMaximum            (obj_id shipId, float shieldHitpointsMaximum)
    {
        _setShipShieldHitpointsBackMaximum(getLongWithNull(shipId), shieldHitpointsMaximum);
    }
    private static native void       _setShipShieldRechargeRate(long shipId, float shieldRechargeRate);
    public static void       setShipShieldRechargeRate                    (obj_id shipId, float shieldRechargeRate)
    {
        _setShipShieldRechargeRate(getLongWithNull(shipId), shieldRechargeRate);
    }
    private static native void       _setShipCapacitorEnergyCurrent(long shipId, float capacitorEnergyCurrent);
    public static void       setShipCapacitorEnergyCurrent                (obj_id shipId, float capacitorEnergyCurrent)
    {
        _setShipCapacitorEnergyCurrent(getLongWithNull(shipId), capacitorEnergyCurrent);
    }
    private static native void       _setShipCapacitorEnergyMaximum(long shipId, float capacitorEnergyMaximum);
    public static void       setShipCapacitorEnergyMaximum                (obj_id shipId, float capacitorEnergyMaximum)
    {
        _setShipCapacitorEnergyMaximum(getLongWithNull(shipId), capacitorEnergyMaximum);
    }
    private static native void       _setShipCapacitorEnergyRechargeRate(long shipId, float capacitorEnergyRechargeRate);
    public static void       setShipCapacitorEnergyRechargeRate           (obj_id shipId, float capacitorEnergyRechargeRate)
    {
        _setShipCapacitorEnergyRechargeRate(getLongWithNull(shipId), capacitorEnergyRechargeRate);
    }
    private static native void       _setShipEngineAccelerationRate(long shipId, float engineAccelerationRate);
    public static void       setShipEngineAccelerationRate                (obj_id shipId, float engineAccelerationRate)
    {
        _setShipEngineAccelerationRate(getLongWithNull(shipId), engineAccelerationRate);
    }
    private static native void       _setShipEngineDecelerationRate(long shipId, float engineDecelerationRate);
    public static void       setShipEngineDecelerationRate                (obj_id shipId, float engineDecelerationRate)
    {
        _setShipEngineDecelerationRate(getLongWithNull(shipId), engineDecelerationRate);
    }
    private static native void       _setShipEnginePitchAccelerationRateDegrees(long shipId, float enginePitchAccelerationRateDegrees);
    public static void       setShipEnginePitchAccelerationRateDegrees    (obj_id shipId, float enginePitchAccelerationRateDegrees)
    {
        _setShipEnginePitchAccelerationRateDegrees(getLongWithNull(shipId), enginePitchAccelerationRateDegrees);
    }
    private static native void       _setShipEngineYawAccelerationRateDegrees(long shipId, float engineYawAccelerationRateDegrees);
    public static void       setShipEngineYawAccelerationRateDegrees      (obj_id shipId, float engineYawAccelerationRateDegrees)
    {
        _setShipEngineYawAccelerationRateDegrees(getLongWithNull(shipId), engineYawAccelerationRateDegrees);
    }
    private static native void       _setShipEngineRollAccelerationRateDegrees(long shipId, float engineRollAccelerationRateDegrees);
    public static void       setShipEngineRollAccelerationRateDegrees     (obj_id shipId, float engineRollAccelerationRateDegrees)
    {
        _setShipEngineRollAccelerationRateDegrees(getLongWithNull(shipId), engineRollAccelerationRateDegrees);
    }
    private static native void       _setShipEnginePitchRateMaximumDegrees(long shipId, float enginePitchRateMaximumDegrees);
    public static void       setShipEnginePitchRateMaximumDegrees         (obj_id shipId, float enginePitchRateMaximumDegrees)
    {
        _setShipEnginePitchRateMaximumDegrees(getLongWithNull(shipId), enginePitchRateMaximumDegrees);
    }
    private static native void       _setShipEngineYawRateMaximumDegrees(long shipId, float engineYawRateMaximumDegrees);
    public static void       setShipEngineYawRateMaximumDegrees           (obj_id shipId, float engineYawRateMaximumDegrees)
    {
        _setShipEngineYawRateMaximumDegrees(getLongWithNull(shipId), engineYawRateMaximumDegrees);
    }
    private static native void       _setShipEngineRollRateMaximumDegrees(long shipId, float engineRollRateMaximumDegrees);
    public static void       setShipEngineRollRateMaximumDegrees          (obj_id shipId, float engineRollRateMaximumDegrees)
    {
        _setShipEngineRollRateMaximumDegrees(getLongWithNull(shipId), engineRollRateMaximumDegrees);
    }
    private static native void       _setShipEngineSpeedMaximum(long shipId, float engineSpeedMaximum);
    public static void       setShipEngineSpeedMaximum                    (obj_id shipId, float engineSpeedMaximum)
    {
        _setShipEngineSpeedMaximum(getLongWithNull(shipId), engineSpeedMaximum);
    }
    private static native void       _setShipEngineSpeedRotationFactorMaximum(long shipId, float engineSpeedSpeedRotationFactor);
    public static void       setShipEngineSpeedRotationFactorMaximum      (obj_id shipId, float engineSpeedSpeedRotationFactor)
    {
        _setShipEngineSpeedRotationFactorMaximum(getLongWithNull(shipId), engineSpeedSpeedRotationFactor);
    }
    private static native void       _setShipEngineSpeedRotationFactorMinimum(long shipId, float engineSpeedSpeedRotationFactor);
    public static void       setShipEngineSpeedRotationFactorMinimum      (obj_id shipId, float engineSpeedSpeedRotationFactor)
    {
        _setShipEngineSpeedRotationFactorMinimum(getLongWithNull(shipId), engineSpeedSpeedRotationFactor);
    }
    private static native void       _setShipEngineSpeedRotationFactorOptimal(long shipId, float engineSpeedSpeedRotationFactor);
    public static void       setShipEngineSpeedRotationFactorOptimal      (obj_id shipId, float engineSpeedSpeedRotationFactor)
    {
        _setShipEngineSpeedRotationFactorOptimal(getLongWithNull(shipId), engineSpeedSpeedRotationFactor);
    }
    private static native void       _setShipReactorEnergyGenerationRate(long shipId, float reactorEnergyGenerationRate);
    public static void       setShipReactorEnergyGenerationRate           (obj_id shipId, float reactorEnergyGenerationRate)
    {
        _setShipReactorEnergyGenerationRate(getLongWithNull(shipId), reactorEnergyGenerationRate);
    }
    private static native void       _setShipBoosterEnergyCurrent(long shipId, float boosterEnergyCurrent);
    public static void       setShipBoosterEnergyCurrent                  (obj_id shipId, float boosterEnergyCurrent)
    {
        _setShipBoosterEnergyCurrent(getLongWithNull(shipId), boosterEnergyCurrent);
    }
    private static native void       _setShipBoosterEnergyMaximum(long shipId, float boosterEnergyMaximum);
    public static void       setShipBoosterEnergyMaximum                  (obj_id shipId, float boosterEnergyMaximum)
    {
        _setShipBoosterEnergyMaximum(getLongWithNull(shipId), boosterEnergyMaximum);
    }
    private static native void       _setShipBoosterEnergyRechargeRate(long shipId, float boosterEnergyRechargeRate);
    public static void       setShipBoosterEnergyRechargeRate             (obj_id shipId, float boosterEnergyRechargeRate)
    {
        _setShipBoosterEnergyRechargeRate(getLongWithNull(shipId), boosterEnergyRechargeRate);
    }
    private static native void       _setShipBoosterEnergyConsumptionRate(long shipId, float boosterEnergyConsumptionRate);
    public static void       setShipBoosterEnergyConsumptionRate          (obj_id shipId, float boosterEnergyConsumptionRate)
    {
        _setShipBoosterEnergyConsumptionRate(getLongWithNull(shipId), boosterEnergyConsumptionRate);
    }
    private static native void       _setShipBoosterAcceleration(long shipId, float boosterAcceleration);
    public static void       setShipBoosterAcceleration                   (obj_id shipId, float boosterAcceleration)
    {
        _setShipBoosterAcceleration(getLongWithNull(shipId), boosterAcceleration);
    }
    private static native void       _setShipBoosterSpeedMaximum(long shipId, float boosterSpeedMaximum);
    public static void       setShipBoosterSpeedMaximum                   (obj_id shipId, float boosterSpeedMaximum)
    {
        _setShipBoosterSpeedMaximum(getLongWithNull(shipId), boosterSpeedMaximum);
    }
    private static native void       _setShipDroidInterfaceCommandSpeed(long shipId, float droidInterfaceCommandSpeed);
    public static void       setShipDroidInterfaceCommandSpeed            (obj_id shipId, float droidInterfaceCommandSpeed)
    {
        _setShipDroidInterfaceCommandSpeed(getLongWithNull(shipId), droidInterfaceCommandSpeed);
    }
    private static native void       _setShipCargoHoldContentsMaximum(long shipId, int contentsMaximum);
    public static void       setShipCargoHoldContentsMaximum              (obj_id shipId, int contentsMaximum)
    {
        _setShipCargoHoldContentsMaximum(getLongWithNull(shipId), contentsMaximum);
    }
    private static native void       _setShipCargoHoldContent(long shipId, long resourceTypeId, int amount);
    public static void       setShipCargoHoldContent                      (obj_id shipId, obj_id resourceTypeId, int amount)
    {
        _setShipCargoHoldContent(getLongWithNull(shipId), getLongWithNull(resourceTypeId), amount);
    }
    /**
    * Set the contents based on a resource class name.  This function picks the first type for this resource class
    */
    public static boolean setShipCargoHoldContent(obj_id shipId, String resourceClassName, int amount)
    {
        obj_id[] resourceTypes = getResourceTypes(resourceClassName);
        if (resourceTypes.length <= 0)
            return false;

        setShipCargoHoldContent(shipId, resourceTypes[0], amount);
        return true;
    }

    /**
    * Add or subtract resources from a cargo hold
    * @return the delta amount actually applied, which may be smaller in magnitude than the requested amount
    */
    public static int modifyShipCargoHoldContent(obj_id shipId, obj_id resourceTypeId, int deltaAmount)
    {
        int contentsCurrent = getShipCargoHoldContentsCurrent(shipId);
        int contentsMaximum = getShipCargoHoldContentsMaximum(shipId);

        if (deltaAmount > 0)
            deltaAmount = Math.min(deltaAmount, contentsMaximum - contentsCurrent);
        else
            deltaAmount = Math.max(deltaAmount, -contentsCurrent);

        if (deltaAmount != 0)
        {
            int currentContentForResource = getShipCargoHoldContent(shipId, resourceTypeId);
            setShipCargoHoldContent(shipId, resourceTypeId, currentContentForResource + deltaAmount);
        }

        return deltaAmount;
    }

    /**
    * Add or subtract resources from a cargo hold.  This function picks the first type for this resource class
    * @return the delta amount actually applied, which may be smaller in magnitude than the requested amount
    */
    public static int modifyShipCargoHoldContent(obj_id shipId, String resourceClassName, int deltaAmount)
    {
        obj_id[] resourceTypes = getResourceTypes(resourceClassName);
        if (resourceTypes.length <= 0)
            return 0;

        return modifyShipCargoHoldContent(shipId, resourceTypes[0], deltaAmount);
    }

    //-- component support

    /** this function does not check to see if the slot is already occupied */
    private static native boolean    _shipCanInstallComponent(long shipId, int chassisSlot, long component);
    public static boolean    shipCanInstallComponent                  (obj_id shipId, int chassisSlot, obj_id component)
    {
        return _shipCanInstallComponent(getLongWithNull(shipId), chassisSlot, getLongWithNull(component));
    }

    private static native boolean    _shipPseudoInstallComponent(long shipId, int chassisSlot, int componentCrc);
    public static boolean    shipPseudoInstallComponent               (obj_id shipId, int chassisSlot, int componentCrc)
    {
        return _shipPseudoInstallComponent(getLongWithNull(shipId), chassisSlot, componentCrc);
    }

    /** this function destroys the component */
    private static native boolean    _shipInstallComponent(long installerId, long shipId, int chassisSlot, long component);
    public static boolean    shipInstallComponent                     (obj_id installerId, obj_id shipId, int chassisSlot, obj_id component)
    {
        return _shipInstallComponent(getLongWithNull(installerId), getLongWithNull(shipId), chassisSlot, getLongWithNull(component));
    }

    /** this function creates a new component in containerTarget */
    private static native long     _shipUninstallComponent(long uninstallerId, long shipId, int chassisSlot, long containerTarget);
    public static obj_id     shipUninstallComponent                   (obj_id uninstallerId, obj_id shipId, int chassisSlot, obj_id containerTarget)
    {
        return getObjIdWithNull(_shipUninstallComponent(getLongWithNull(uninstallerId), getLongWithNull(shipId), chassisSlot, getLongWithNull(containerTarget)));
    }

    /** this function creates a new component in containerTarget, ignoring containerTarget's space limitations */
    private static native long     _shipUninstallComponentAllowOverload(long uninstallerId, long shipId, int chassisSlot, long containerTarget);
    public static obj_id     shipUninstallComponentAllowOverload                   (obj_id uninstallerId, obj_id shipId, int chassisSlot, obj_id containerTarget)
    {
        return getObjIdWithNull(_shipUninstallComponentAllowOverload(getLongWithNull(uninstallerId), getLongWithNull(shipId), chassisSlot, getLongWithNull(containerTarget)));
    }

    private static native int []     _getShipChassisSlots(long shipId);
    public static int []     getShipChassisSlots                      (obj_id shipId)
    {
        return _getShipChassisSlots(getLongWithNull(shipId));
    }

    private static native void      _setShipSlotTargetable(long shipId, int chassisSlot, boolean targetable);
    public static void      setShipSlotTargetable                       (obj_id shipId, int chassisSlot, boolean targetable)
    {
        _setShipSlotTargetable(getLongWithNull(shipId), chassisSlot, targetable);
    }

    private static native boolean   _isShipSlotTargetable(long shipId, int chassisSlot);
    public static boolean   isShipSlotTargetable                       (obj_id shipId, int chassisSlot)
    {
        return _isShipSlotTargetable(getLongWithNull(shipId), chassisSlot);
    }

    private static native int       _getShipComponentDescriptorType(long component);
    public static int       getShipComponentDescriptorType                   (obj_id component)
    {
        return _getShipComponentDescriptorType(getLongWithNull(component));
    }
    public static native int       getShipComponentDescriptorTypeByName             (String typeName);
    public static native String    getShipComponentDescriptorTypeName               (int componentType);
    private static native int       _getShipComponentDescriptorCrc(long component);
    public static int       getShipComponentDescriptorCrc                    (obj_id component)
    {
        return _getShipComponentDescriptorCrc(getLongWithNull(component));
    }
    public static native String    getShipComponentDescriptorCrcName                (int componentCrc);
    public static native String    getShipComponentDescriptorCompatibility          (int componentCrc);
    public static native boolean   getShipComponentDescriptorWeaponIsAmmoConsuming  (int componentCrc);
    public static native boolean   getShipComponentDescriptorWeaponIsMissile        (int componentCrc);
    public static native boolean   getShipComponentDescriptorWeaponIsCountermeasure (int componentCrc);
    public static native boolean   getShipComponentDescriptorWeaponIsMining         (int componentCrc);
    public static native boolean   getShipComponentDescriptorWeaponIsTractor        (int componentCrc);
    public static native float     getShipComponentDescriptorWeaponRange            (int componentCrc);
    public static native float     getShipComponentDescriptorWeaponProjectileSpeed  (int componentCrc);


    private static native long     _getDroidControlDeviceForShip(long ship);
    public static obj_id     getDroidControlDeviceForShip             (obj_id ship)
    {
        return getObjIdWithNull(_getDroidControlDeviceForShip(getLongWithNull(ship)));
    }
    private static native boolean    _associateDroidControlDeviceWithShip(long ship, long droidControlDevice);
    public static boolean    associateDroidControlDeviceWithShip      (obj_id ship, obj_id droidControlDevice)
    {
        return _associateDroidControlDeviceWithShip(getLongWithNull(ship), getLongWithNull(droidControlDevice));
    }
    private static native boolean    _removeDroidControlDeviceFromShip(long ship);
    public static boolean    removeDroidControlDeviceFromShip         (obj_id ship)
    {
        return _removeDroidControlDeviceFromShip(getLongWithNull(ship));
    }
    private static native long     _launchShipFromHangar(long ship, String templateToSpawn, transform deltaFromHangarHardpoint);
    public static obj_id     launchShipFromHangar                     (obj_id ship, String templateToSpawn, transform deltaFromHangarHardpoint)
    {
        return getObjIdWithNull(_launchShipFromHangar(getLongWithNull(ship), templateToSpawn, deltaFromHangarHardpoint));
    }

    /*
        __commPlayers(obj_id source, String appearanceOverrideServerTemplate, String soundEffect, float displayTime, obj_id [] targets, String oob);
        source               = object id of the thing sending the message - this can't be null.
        soundEffect          = a sound effect file to play.
        displayTime          = duration in seconds of the message.
                             Definition in priority order
                             > 0 -- Timed message has the highest priority.
                             < 0 -- Untimed message
                             0   -- Player taunt with the display time calculated on the client by the length of the string (default behavior).
        targets              = An array of object ids to receive the message
        oob                  = Out of band data (prose package or string id).
    */
    private static native void __commPlayers(long source, String appearanceOverrideServerTemplate, String soundEffect, float displayTime, long[] targets, String oob, boolean chronicles);

    public static void _commPlayers(obj_id source, String appearanceOverrideServerTemplate, obj_id[] targets, String oob, boolean chronicles)
    {
        long[] _targets = null;
        if (targets != null)
        {
            _targets = new long[targets.length];
            for (int _i = 0; _i < targets.length; ++_i)
                _targets[_i] = getLongWithNull(targets[_i]);
        }
        __commPlayers(getLongWithNull(source), appearanceOverrideServerTemplate, null, 0.0f, _targets, oob, chronicles);
    }

    public static void commPlayers(obj_id source, String appearanceOverrideServerTemplate, String soundEffect, float duration, obj_id[] targets, prose_package prose)
    {
        if (targets != null && targets.length > 0 && isIdValid(source) && prose != null)
        {
            String oob = null;
            oob = packOutOfBandProsePackage(oob, -1, prose);

            long[] _targets = new long[targets.length];
            for (int _i = 0; _i < targets.length; ++_i)
                _targets[_i] = getLongWithNull(targets[_i]);

            if (oob != null)
                __commPlayers(getLongWithNull(source), appearanceOverrideServerTemplate, soundEffect, duration, _targets, oob, false);
        }
    }

    public static void commPlayers(obj_id source, String appearanceOverrideServerTemplate, String soundEffect, float duration, obj_id target, prose_package prose)
    {
        if (isIdValid(target) && isIdValid(source) && prose != null)
        {
            long[] targets = new long[1];
            targets[0] = getLongWithNull(target);

            String oob = null;
            oob = packOutOfBandProsePackage(oob, -1, prose);

            if (oob != null)
                __commPlayers(getLongWithNull(source), appearanceOverrideServerTemplate, soundEffect, duration, targets, oob, false);
        }
    }

    public static void commPlayers(obj_id source, obj_id[] targets, prose_package prose, String appearanceOverrideServerTemplate)
    {
        if (targets != null && targets.length > 0 && prose != null)
        {
            String oob = null;
            oob = packOutOfBandProsePackage(oob, -1, prose);
            if (oob != null)
                _commPlayers(source, appearanceOverrideServerTemplate, targets, oob, false);
        }
    }

    public static void commPlayers(obj_id source, obj_id[] targets, prose_package prose)
    {
        commPlayers(source, targets, prose, null);
    }

    public static void commPlayer(obj_id source, obj_id target, prose_package prose, String appearanceOverrideServerTemplate)
    {
        if (isIdValid(target) && prose != null)
        {
            obj_id[] targets = new obj_id[1];
            targets[0] = target;
            String oob = null;
            oob = packOutOfBandProsePackage(oob, -1, prose);
            if (oob != null)
                _commPlayers(source, appearanceOverrideServerTemplate, targets, oob, false);
        }
    }

    public static void commPlayer(obj_id source, obj_id target, prose_package prose)
    {
        commPlayer(source, target, prose, null);
    }

	public static void commPlayerQuest(obj_id source, obj_id target, prose_package prose, String appearanceOverrideServerTemplate)
	{
		if (isIdValid(target) && prose != null)
		{
			obj_id[] targets = new obj_id[1];
			targets[0] = target;
			String oob = null;
			oob = packOutOfBandProsePackage(oob, -1, prose);
			if (oob != null)
				_commPlayers(source, appearanceOverrideServerTemplate, targets, oob, true);
		}
	}

	public static void commPlayerQuest(obj_id source, obj_id target, prose_package prose)
	{
		commPlayerQuest(source, target, prose, null);
    }

    /** use commPlayers instead
    */
    public static void dogfightTauntPlayers(obj_id source, obj_id[] targets, prose_package prose, String appearanceOverrideServerTemplate)
    {
        commPlayers(source, targets, prose, appearanceOverrideServerTemplate);
    }

    /** use commPlayers instead
    */
    public static void dogfightTauntPlayers(obj_id source, obj_id[] targets, prose_package prose)
    {
        commPlayers(source, targets, prose);
    }

    /** use commPlayer instead
    */
    public static void dogfightTauntPlayer(obj_id source, obj_id target, prose_package prose, String appearanceOverrideServerTemplate)
    {
        commPlayer(source, target, prose, appearanceOverrideServerTemplate);
    }

    /** use commPlayer instead
    */
    public static void dogfightTauntPlayer(obj_id source, obj_id target, prose_package prose)
    {
        commPlayer(source, target, prose);
    }

    private static native boolean _editFormData(long player, long objectToEdit, String[] keys, String[] values);
    public static boolean editFormData(obj_id player, obj_id objectToEdit, String[] keys, String[] values)
    {
        return _editFormData(getLongWithNull(player), getLongWithNull(objectToEdit), keys, values);
    }

    /**
     * Notify the pilot of the ship that we have sustained some damage.
     *
     * @param victimId The id of the vicitim ship.
     *
     * @param attackerId The id of the attacking object (not necessarily a ship).
     *
     * @param totalDamage the total amount of damage (may need to be more specific in the future).
     */
    private static native void _notifyShipDamage(long victimId, long attackerId, float totalDamage);
    public static void notifyShipDamage(obj_id victimId, obj_id attackerId, float totalDamage)
    {
        _notifyShipDamage(getLongWithNull(victimId), getLongWithNull(attackerId), totalDamage);
    }

    /**
    * @param severity zero is the baseline and should be the common.  1.0 causes the ship to break into the most pieces
    */

    private static native void _handleShipDestruction(long shipId, float severity);
    public static void handleShipDestruction(obj_id shipId, float severity)
    {
        _handleShipDestruction(getLongWithNull(shipId), severity);
    }

    /**
    * @param severity zero is the baseline and should be the common.  1.0 causes all component to break into the most pieces
    */

    private static native void _handleShipComponentDestruction(long shipId, int chassisSlot, float severity);
    public static void handleShipComponentDestruction(obj_id shipId, int chassisSlot, float severity)
    {
        _handleShipComponentDestruction(getLongWithNull(shipId), chassisSlot, severity);
    }

    /**
    * Adds a Ship IDOT entry, or modifies an existing entry.
    * @param chassisSlot must be a valid installed slot on the ship, or ship_chassis_slot_type.SCST_num_types to IDOT the ship chassis itself
    * @return false on failure, invalid ship, chassisSlot, or other parameters
    * @throws internal_script_error if the ship is invalid, or the chassisSlot is not filled on the ship
    */

    private static native boolean _setShipInternalDamageOverTime(long shipId, int chassisSlot, float damageRate, float damageThreshold);
    public static boolean setShipInternalDamageOverTime(obj_id shipId, int chassisSlot, float damageRate, float damageThreshold)
    {
        return _setShipInternalDamageOverTime(getLongWithNull(shipId), chassisSlot, damageRate, damageThreshold);
    }

    /**
    * Removes a Ship IDOT entry
    * @param chassisSlot must be a valid installed slot on the ship, or ship_chassis_slot_type.SCST_num_types to IDOT the ship chassis itself
    * @return false on failure, the IDOT entry did not exist or some other internal error
    * @throws internal_script_error if the ship is invalid, or the chassisSlot is not filled on the ship
    */

    private static native boolean _removeShipInternalDamageOverTime(long shipId, int chassisSlot);
    public static boolean removeShipInternalDamageOverTime(obj_id shipId, int chassisSlot)
    {
        return _removeShipInternalDamageOverTime(getLongWithNull(shipId), chassisSlot);
    }

    /**
    * Queries a Ship IDOT entry value
    * @param chassisSlot must be a valid installed slot on the ship, or ship_chassis_slot_type.SCST_num_types to IDOT the ship chassis itself
    * @throws internal_script_error if the specified IDOT does not exist, use hasShipInternalDamageOverTime
    */

    private static native float _getShipInternalDamageOverTimeDamageRate(long shipId, int chassisSlot);
    public static float getShipInternalDamageOverTimeDamageRate(obj_id shipId, int chassisSlot)
    {
        return _getShipInternalDamageOverTimeDamageRate(getLongWithNull(shipId), chassisSlot);
    }

    /**
    * Queries a Ship IDOT entry value
    * @param chassisSlot must be a valid installed slot on the ship, or ship_chassis_slot_type.SCST_num_types to IDOT the ship chassis itself
    * @throws internal_script_error if the specified IDOT does not exist, use hasShipInternalDamageOverTime
    */
    private static native float _getShipInternalDamageOverTimeDamageThreshold(long shipId, int chassisSlot);
    public static float getShipInternalDamageOverTimeDamageThreshold(obj_id shipId, int chassisSlot)
    {
        return _getShipInternalDamageOverTimeDamageThreshold(getLongWithNull(shipId), chassisSlot);
    }

    /**
    * Queries a Ship IDOT entry value
    * @param chassisSlot must be a valid installed slot on the ship, or ship_chassis_slot_type.SCST_num_types to IDOT the ship chassis itself
    * @throws internal_script_error if the ship does not exist
    */

    private static native boolean _hasShipInternalDamageOverTime(long shipId, int chassisSlot);
    public static boolean hasShipInternalDamageOverTime(obj_id shipId, int chassisSlot)
    {
        return _hasShipInternalDamageOverTime(getLongWithNull(shipId), chassisSlot);
    }

    /**
     * Get the space faction for a ship
     * @param ship  the ship to get the faction of
     * @return  the crc of the space faction for the ship
     */
    private static native int _shipGetSpaceFaction(long ship);
    public static int shipGetSpaceFaction(obj_id ship)
    {
        return _shipGetSpaceFaction(getLongWithNull(ship));
    }
    /**
     * Get the space faction allies for a ship
     * @param ship  the ship to get the ally factions for
     * @return  the array of crcs for the ally factions
     */
    private static native int[] _shipGetSpaceFactionAllies(long ship);
    public static int[] shipGetSpaceFactionAllies(obj_id ship)
    {
        return _shipGetSpaceFactionAllies(getLongWithNull(ship));
    }
    /**
     * Get the space faction enemies for a ship
     * @param ship  the ship to get the enemy factions for
     * @return  the array of crcs for the enemy factions
     */
    private static native int[] _shipGetSpaceFactionEnemies(long ship);
    public static int[] shipGetSpaceFactionEnemies(obj_id ship)
    {
        return _shipGetSpaceFactionEnemies(getLongWithNull(ship));
    }
    /**
     * Get the whether an ai ship is flagged as aggressive to players
     * @param ship  the ship to get the aggro flag for
     * @return  whether the ship is flagged as aggro
     */
    private static native boolean _shipGetSpaceFactionIsAggro(long ship);
    public static boolean shipGetSpaceFactionIsAggro(obj_id ship)
    {
        return _shipGetSpaceFactionIsAggro(getLongWithNull(ship));
    }
    /**
     * Set the space faction for a ship
     * @param ship  the ship to set the space faction for
     * @param spaceFaction  the crc of the space faction to set
     */
    private static native void _shipSetSpaceFaction(long ship, int spaceFaction);
    public static void shipSetSpaceFaction(obj_id ship, int spaceFaction)
    {
        _shipSetSpaceFaction(getLongWithNull(ship), spaceFaction);
    }
    /**
     * Set the ally space factions for a ship
     * @param ship  the ship to set the ally space factions for
     * @param factionList  the crcs of the ally space factions to set
     */
    private static native void _shipSetSpaceFactionAllies(long ship, int[] factionList);
    public static void shipSetSpaceFactionAllies(obj_id ship, int[] factionList)
    {
        _shipSetSpaceFactionAllies(getLongWithNull(ship), factionList);
    }
    /**
     * Set the enemy space factions for a ship
     * @param ship  the ship to set the enemy space factions for
     * @param factionList  the crcs of the enemy space factions to set
     */
    private static native void _shipSetSpaceFactionEnemies(long ship, int[] factionList);
    public static void shipSetSpaceFactionEnemies(obj_id ship, int[] factionList)
    {
        _shipSetSpaceFactionEnemies(getLongWithNull(ship), factionList);
    }
    /**
     * Set whether a ship is always aggressive toward players
     * @param ship  the ship to set the aggro status for
     * @param isAggro  the new aggro flag for the ship
     */
    private static native void _shipSetSpaceFactionIsAggro(long ship, boolean isAggro);
    public static void shipSetSpaceFactionIsAggro(obj_id ship, boolean isAggro)
    {
        _shipSetSpaceFactionIsAggro(getLongWithNull(ship), isAggro);
    }

    /**
     * Hyperspace a player to a specified space scene and location.
     * @param player      the player to warp
     * @param sceneName   the scene to warp to
     * @param x_w         the world x coordinate to warp to
     * @param y_w         the world y coordinate to warp to
     * @param z_w         the world z coordinate to warp to
     * @param cell        the cell object to warp to
     * @param x_p         the parent x coordinate to warp to
     * @param y_p         the parent y coordinate to warp to
     * @param z_p         the parent z coordinate to warp to
     * @param callback    messageHandler function to call when the player arrives
     * @param forceLoadScreen  whether to require a loading screen regardless of scene change or distance
     */
    private static native void _hyperspacePlayerToLocation(long player, String sceneName, float x_w, float y_w, float z_w, long cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen);
    public static void hyperspacePlayerToLocation(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen)
    {
        _hyperspacePlayerToLocation(getLongWithNull(player), sceneName, x_w, y_w, z_w, getLongWithNull(cell), x_p, y_p, z_p, callback, forceLoadScreen);
    }

    /**
     * Hyperspace a player to a specified space scene and location.
     * @param player      the player to warp
     * @param sceneName   the scene to warp to
     * @param x_w         the world x coordinate to warp to
     * @param y_w         the world y coordinate to warp to
     * @param z_w         the world z coordinate to warp to
     * @param destination the cell object to warp to
     * @param cell        the name of the cell in the object to warp to
     * @param x_p         the parent x coordinate to warp to
     * @param y_p         the parent y coordinate to warp to
     * @param z_p         the parent z coordinate to warp to
     * @param callback    messageHandler function to call when the player arrives
     * @param forceLoadScreen  whether to require a loading screen regardless of scene change or distance
     */
    private static native void _hyperspacePlayerToLocation(long player, String sceneName, float x_w, float y_w, float z_w, long buildingId, String cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen);
    public static void hyperspacePlayerToLocation(obj_id player, String sceneName, float x_w, float y_w, float z_w, obj_id buildingId, String cell, float x_p, float y_p, float z_p, String callback, boolean forceLoadScreen)
    {
        _hyperspacePlayerToLocation(getLongWithNull(player), sceneName, x_w, y_w, z_w, getLongWithNull(buildingId), cell, x_p, y_p, z_p, callback, forceLoadScreen);
    }

    /**
     * Hyperspace a player to a specified hyperspace point.
     * @param player      the player to warp
     * @param hyperspacePoint Name the name of the hyperspace point to use
     * @param callback    messageHandler function to call when the player arrives
     * @param forceLoadScreen  whether to require a loading screen regardless of scene change or distance
     * @param ignoreTooFull if true, the zone population limits will be ignored
     */
    private static native void _hyperspacePlayerToHyperspacePoint(long player, String hyperspacePoint, String callback, boolean forceLoadScreen, boolean ignoreTooFull);
    public static void hyperspacePlayerToHyperspacePoint(obj_id player, String hyperspacePoint, String callback, boolean forceLoadScreen, boolean ignoreTooFull)
    {
        _hyperspacePlayerToHyperspacePoint(getLongWithNull(player), hyperspacePoint, callback, forceLoadScreen, ignoreTooFull);
    }

    /**
     * Check whether a hyperspace point is overpopulated.
     * @param hyperspacePoint the name of the point
     * @return true if the point is overpopulated
     */
    public static native boolean isHyperspacePointOverpopulated(String hyperspacePoint);

    /**
     * This will lock the control of the player's ship and orient it to the jump direction
     * It is VERY important that hyperspaceRestoreShipOnClientFromAbortedHyperspace be called
     * in the case of a hyperspace abort
     * @param player requesting to hyperspace
     * @param hyperspacePoint the name of the point
     */
    private static native void _hyperspacePrepareShipOnClient(long player, String hyperspacePoint);
    public static void hyperspacePrepareShipOnClient(obj_id player, String hyperspacePoint)
    {
        _hyperspacePrepareShipOnClient(getLongWithNull(player), hyperspacePoint);
    }

    /**
     * This will set the player's state back to normal if the hyperspace was aborted
     * most importantly this will unlock the control of the ship
     * @param player requesting to hyperspace
     */
    private static native void _hyperspaceRestoreShipOnClientFromAbortedHyperspace(long player);
    public static void hyperspaceRestoreShipOnClientFromAbortedHyperspace(obj_id player)
    {
        _hyperspaceRestoreShipOnClientFromAbortedHyperspace(getLongWithNull(player));
    }

    /**
     * Get the name of the scene which the hyperspace point is in.
     * @param hyperspacePoint the name of the point
     * @return the scene name for the hyperspace point, null if the point is invalid
     */
    public static native String getSceneForHyperspacePoint(String hyperspacePoint);

    /**
     * Test to see if a ship is inside the specified nebula
     * @param nebulaName if this is null, then the test is for any nebula, regardless of name
     */
    private static native boolean _shipIsInNebula(long shipId, String nebulaName);
    public static boolean shipIsInNebula(obj_id shipId, String nebulaName)
    {
        return _shipIsInNebula(getLongWithNull(shipId), nebulaName);
    }

    private static native boolean  _setShipWingName(long target, String str);
    public static boolean  setShipWingName(obj_id target, String str)
    {
        return _setShipWingName(getLongWithNull(target), str);
    }
    private static native String  _getShipWingName(long target);
    public static String  getShipWingName(obj_id target)
    {
        return _getShipWingName(getLongWithNull(target));
    }
    private static native boolean  _setShipTypeName(long target, String str);
    public static boolean  setShipTypeName(obj_id target, String str)
    {
        return _setShipTypeName(getLongWithNull(target), str);
    }
    private static native String  _getShipTypeName(long target);
    public static String  getShipTypeName(obj_id target)
    {
        return _getShipTypeName(getLongWithNull(target));
    }
    private static native boolean  _setShipDifficulty(long target, String str);
    public static boolean  setShipDifficulty(obj_id target, String str)
    {
        return _setShipDifficulty(getLongWithNull(target), str);
    }
    private static native String  _getShipDifficulty(long target);
    public static String  getShipDifficulty(obj_id target)
    {
        return _getShipDifficulty(getLongWithNull(target));
    }
    private static native boolean  _setShipFaction(long target, String str);
    public static boolean  setShipFaction(obj_id target, String str)
    {
        return _setShipFaction(getLongWithNull(target), str);
    }
    private static native String  _getShipFaction(long target);
    public static String  getShipFaction(obj_id target)
    {
        return _getShipFaction(getLongWithNull(target));
    }
    private static native boolean _addMissionCriticalObject(long playerObjectId, long missionCriticalObjectId);
    public static boolean addMissionCriticalObject(obj_id playerObjectId, obj_id missionCriticalObjectId)
    {
        return _addMissionCriticalObject(getLongWithNull(playerObjectId), getLongWithNull(missionCriticalObjectId));
    }
    private static native boolean _removeMissionCriticalObject(long playerObjectId, long missionCriticalObjectId);
    public static boolean removeMissionCriticalObject(obj_id playerObjectId, obj_id missionCriticalObjectId)
    {
        return _removeMissionCriticalObject(getLongWithNull(playerObjectId), getLongWithNull(missionCriticalObjectId));
    }
    private static native boolean _clearMissionCriticalObjects(long playerObjectId);
    public static boolean clearMissionCriticalObjects(obj_id playerObjectId)
    {
        return _clearMissionCriticalObjects(getLongWithNull(playerObjectId));
    }
    private static native boolean _isMissionCriticalObject(long playerObjectId, long missionCriticalObjectId);
    public static boolean isMissionCriticalObject(obj_id playerObjectId, obj_id missionCriticalObjectId)
    {
        return _isMissionCriticalObject(getLongWithNull(playerObjectId), getLongWithNull(missionCriticalObjectId));
    }

    /**
     * Set the range at which an AI ship will look for enemies.  The AI ship will
     * attack enemies that come within this range.
     * @param shipId the ship
     * @param aggroDistance the range
     */
    private static native void _setShipAggroDistance(long shipId, float aggroDistance);
    public static void setShipAggroDistance(obj_id shipId, float aggroDistance)
    {
        _setShipAggroDistance(getLongWithNull(shipId), aggroDistance);
    }
    private static native String _getShipComponentDebugString(long shipId, int chassisSlot);
    public static String getShipComponentDebugString(obj_id shipId, int chassisSlot)
    {
        return _getShipComponentDebugString(getLongWithNull(shipId), chassisSlot);
    }
    public static native boolean isSpaceBattlefieldZone();
    public static native boolean isSpaceScene();

    /**
    *
    */

    public static class ship_hit_type
    {
        // these must be kept in sync with sharedGame/ShipHitEffectsManager.h
        public static final int HT_shield = 0;
        public static final int HT_armor = 1;
        public static final int HT_component = 2;
        public static final int HT_chassis = 3;
        public static final int HT_numTypes = 4;
    };

    /**
    * Used to play effects on clients viewing the ship
    * @param type one of the values form base_clas.ship_hit_type
    */
    private static native void _notifyShipHit(long shipId, vector up_w, vector hitLocation_o, int type, float integrity, float previousIntegrity);
    public static void notifyShipHit(obj_id shipId, vector up_w, vector hitLocation_o, int type, float integrity, float previousIntegrity)
    {
        _notifyShipHit(getLongWithNull(shipId), up_w, hitLocation_o, type, integrity, previousIntegrity);
    }

    /**
    * set the moving velocity on a dynamic mining asteroid.
    * it can change in the future if it hits other objects
    */
    private static native void _setDynamicMiningAsteroidVelocity(long asteroidId, vector velocity_w);
    public static void setDynamicMiningAsteroidVelocity(obj_id asteroidId, vector velocity_w)
    {
        _setDynamicMiningAsteroidVelocity(getLongWithNull(asteroidId), velocity_w);
    }

    private static native vector _getDynamicMiningAsteroidVelocity(long asteroidId);
    public static vector getDynamicMiningAsteroidVelocity(obj_id asteroidId)
    {
        return _getDynamicMiningAsteroidVelocity(getLongWithNull(asteroidId));
    }


    /**
     *
     */
    private static native void _veteranWriteAccountDataToObjvars(long player);
    public static void veteranWriteAccountDataToObjvars(obj_id player)
    {
        _veteranWriteAccountDataToObjvars(getLongWithNull(player));
    }
    private static native String[] _veteranGetTriggeredEvents(long player);
    public static String[] veteranGetTriggeredEvents(obj_id player)
    {
        return _veteranGetTriggeredEvents(getLongWithNull(player));
    }
    private static native boolean _veteranAccountFeatureIdRequest(long player);
    public static boolean veteranAccountFeatureIdRequest(obj_id player)
    {
        return _veteranAccountFeatureIdRequest(getLongWithNull(player));
    }
    private static native String[] _veteranGetRewardChoicesDescriptions(long player, String event);
    public static String[] veteranGetRewardChoicesDescriptions(obj_id player, String event)
    {
        return _veteranGetRewardChoicesDescriptions(getLongWithNull(player), event);
    }
    private static native String[] _veteranGetRewardChoicesTags(long player, String event);
    public static String[] veteranGetRewardChoicesTags(obj_id player, String event)
    {
        return _veteranGetRewardChoicesTags(getLongWithNull(player), event);
    }
    private static native boolean _veteranClaimReward(long player, String event, String rewardTag);
    public static boolean veteranClaimReward(obj_id player, String event, String rewardTag)
    {
        return _veteranClaimReward(getLongWithNull(player), event, rewardTag);
    }
    private static native boolean _veteranCanTradeInReward(long player, long item);
    public static boolean veteranCanTradeInReward(obj_id player, obj_id item)
    {
        return _veteranCanTradeInReward(getLongWithNull(player), getLongWithNull(item));
    }
    private static native void _veteranTradeInReward(long player, long item);
    public static void veteranTradeInReward(obj_id player, obj_id item)
    {
        _veteranTradeInReward(getLongWithNull(player), getLongWithNull(item));
    }
    private static native void _adjustSwgTcgAccountFeatureId(long player, long item, int featureId, int adjustment);
    public static void adjustSwgTcgAccountFeatureId(obj_id player, obj_id item, int featureId, int adjustment)
    {
        _adjustSwgTcgAccountFeatureId(getLongWithNull(player), getLongWithNull(item), featureId, adjustment);
    }
    public static native String veteranGetEventAnnouncement(String event);
    public static native String veteranGetEventDescription(String event);
    public static native String veteranGetEventUrl(String event);
    public static native boolean veteranIsEventAccountUnique(String event);
    public static native boolean veteranIsItemAccountUnique(String event);
    public static native boolean veteranIsItemAccountUniqueFeatureId(String event);

    private static native void _launchClientWebBrowser(long player, String url);
    public static void launchClientWebBrowser(obj_id player, String url)
    {
        _launchClientWebBrowser(getLongWithNull(player), url);
    }

    private static native byte[] _getByteStreamFromAutoVariable(long target, String variableName);
    public static byte[] getByteStreamFromAutoVariable(obj_id target, String variableName)
    {
        return _getByteStreamFromAutoVariable(getLongWithNull(target), variableName);
    }
    private static native void _setAutoVariableFromByteStream(long target, String variableName, byte[] data);
    public static void setAutoVariableFromByteStream(obj_id target, String variableName, byte[] data)
    {
        _setAutoVariableFromByteStream(getLongWithNull(target), variableName, data);
    }

    private static native void _setClientUsesAnimationLocomotion(long player, boolean enabled);
    public static void setClientUsesAnimationLocomotion(obj_id player, boolean enabled)
    {
        _setClientUsesAnimationLocomotion(getLongWithNull(player), enabled);
    }

    private static native void _hideFromClient(long object, boolean hide);
    public static void hideFromClient(obj_id object, boolean hide)
    {
        _hideFromClient(getLongWithNull(object), hide);
    }

    /**
     * add target to object's passive reveal list; range *MUST BE* > 0
     */
    private static native void _addPassiveReveal(long object, long target, int range);
    public static void addPassiveReveal(obj_id object, obj_id target, int range)
    {
        _addPassiveReveal(getLongWithNull(object), getLongWithNull(target), range);
    }

    /**
     * remove target from object's passive reveal list
     */
    private static native void _removePassiveReveal(long object, long target);
    public static void removePassiveReveal(obj_id object, obj_id target)
    {
        _removePassiveReveal(getLongWithNull(object), getLongWithNull(target));
    }

    /**
     * clear object's passive reveal list
     */
    private static native void _clearPassiveRevealList(long object);
    public static void clearPassiveRevealList(obj_id object)
    {
        _clearPassiveRevealList(getLongWithNull(object));
    }

    /**
     * if target is in object's passive reveal list, return the range;
     * otherwise, return a negative value
     */
    private static native int _getPassiveRevealRange(long object, long target);
    public static int getPassiveRevealRange(obj_id object, obj_id target)
    {
        return _getPassiveRevealRange(getLongWithNull(object), getLongWithNull(target));
    }

    /**
     * return a dictionary containing object's passive reveal list
     *
     * the dictionary (which may be null) will contain the following
     * data (which are parallel arrays):
     *
     * obj_id[]   id
     * int[]      range
     */
    private static native dictionary _getPassiveRevealList(long object);
    public static dictionary getPassiveRevealList(obj_id object)
    {
        return _getPassiveRevealList(getLongWithNull(object));
    }


    /**
     * request that an update containing this object's position be sent
     * to the DB for persistence
     */
    private static native void _requestSendPositionUpdate(long object);
    public static void requestSendPositionUpdate(obj_id object)
    {
        _requestSendPositionUpdate(getLongWithNull(object));
    }

    /**
    * buff functions
    */
    private static native boolean __addBuff(long target, int nameCrc);
    public static boolean _addBuff(obj_id target, int nameCrc)
    {
        return __addBuff(getLongWithNull(target), nameCrc);
    }

    private static native boolean __addBuff(long target, long caster, int nameCrc);
    public static boolean _addBuff(obj_id target, obj_id caster,int nameCrc)
    {
        return __addBuff(getLongWithNull(target), getLongWithNull(caster), nameCrc);
    }
    // In the following call, if duration or customValue are zero, the default from the buff table is used
    // A negative duration (e.g. -1) indicates that the buff lives forever
    private static native boolean __addBuff(long target, int nameCrc, float duration, float customValue);
    public static boolean _addBuff(obj_id target, int nameCrc, float duration, float customValue)
    {
        return __addBuff(getLongWithNull(target), nameCrc, duration, customValue);
    }

    private static native boolean __addBuff(long target, long caster,int nameCrc, float duration, float customValue);
    public static boolean _addBuff(obj_id target, obj_id caster,int nameCrc, float duration, float customValue)
    {
        return __addBuff(getLongWithNull(target), getLongWithNull(caster), nameCrc, duration, customValue);
    }

    private static native boolean __addBuff(long target, long caster, int nameCrc, float duration, float customValue, int count);
    public static boolean _addBuff(obj_id target, obj_id  caster, int nameCrc, float duration, float customValue, int count)
    {
        return __addBuff(getLongWithNull(target), getLongWithNull(caster), nameCrc, duration, customValue, count);
    }

    private static native boolean __removeBuff(long target, int nameCrc);
    public static boolean _removeBuff(obj_id target, int nameCrc)
    {
        return __removeBuff(getLongWithNull(target), nameCrc);
    }
    private static native boolean __hasBuff(long target, int nameCrc);
    public static boolean _hasBuff(obj_id target, int nameCrc)
    {
        return __hasBuff(getLongWithNull(target), nameCrc);
    }
    private static native int[]   __getAllBuffs(long target);
    public static int[]   _getAllBuffs(obj_id target)  //Returns buff name Crcs
    {
        return __getAllBuffs(getLongWithNull(target));
    }
    private static native float   __getBuffTimeRemaining(long target, int nameCrc);
    public static float   _getBuffTimeRemaining(obj_id target, int nameCrc)  // 0 means they don't have this buff anymore
    {
        return __getBuffTimeRemaining(getLongWithNull(target), nameCrc);
    }
    private static native float   __getBuffCustomValue(long target, int nameCrc);
    public static float   _getBuffCustomValue(obj_id target, int nameCrc)    // if they don't have it it returns 0
    {
        return __getBuffCustomValue(getLongWithNull(target), nameCrc);
    }

    private static native long   __getBuffStackCount(long target, int nameCrc);
    public static long   _getBuffStackCount(obj_id target, int nameCrc)
    {
        return __getBuffStackCount(getLongWithNull(target), nameCrc);
    }

    private static native boolean   __decrementBuffStack(long target, int nameCrc, int stacksToRemove);
    public static boolean   _decrementBuffStack(obj_id target, int nameCrc, int stacksToRemove)
    {
        return __decrementBuffStack(getLongWithNull(target), nameCrc, stacksToRemove);
    }

    private static native long   __getBuffCaster(long target, int nameCrc);
    public static long   _getBuffCaster(obj_id target, int nameCrc)
    {
        return __getBuffCaster(getLongWithNull(target), nameCrc);
    }

    private static native boolean __decayBuff(long target, int nameCrc, float decayPercentage);
    public static boolean _decayBuff(obj_id target, int nameCrc, float decayPercentage)
    {
        return __decayBuff(getLongWithNull(target), nameCrc, decayPercentage);
    }

    private static native void   _showCyberneticsPage(long player, long npc, int openType);
    public static void   showCyberneticsPage(obj_id player, obj_id npc, int openType)
    {
        _showCyberneticsPage(getLongWithNull(player), getLongWithNull(npc), openType);
    }

    private static native float _getObjectCollisionRadius(long obj);
    public static float getObjectCollisionRadius(obj_id obj)
    {
        return _getObjectCollisionRadius(getLongWithNull(obj));
    }

    private static native void _openSpaceMiningUi(long player, long station, String stationName);
    public static void openSpaceMiningUi(obj_id player, obj_id station, String stationName)
    {
        _openSpaceMiningUi(getLongWithNull(player), getLongWithNull(station), stationName);
    }

    private static native void _sendCooldownGroupTimingOnly(long creature, int cooldownGroupCrc, float time);
    public static void sendCooldownGroupTimingOnly(obj_id creature, int cooldownGroupCrc, float time)
    {
        _sendCooldownGroupTimingOnly(getLongWithNull(creature), cooldownGroupCrc, time);
    }

    private static native int _addNotification(long player, String contents, boolean useNotificationIcon, int iconStyle, float timeout, int channel, String sound);
    public static int addNotification(obj_id player, String contents, boolean useNotificationIcon, int iconStyle, float timeout, int channel, String sound)
    {
        return _addNotification(getLongWithNull(player), contents, useNotificationIcon, iconStyle, timeout, channel, sound);
    }

    private static native void _cancelNotification(long player, int notification);
    public static void cancelNotification(obj_id player, int notification)
    {
        _cancelNotification(getLongWithNull(player), notification);
    }

    private static native void _cancelAllNotifications(long player);
    public static void cancelAllNotifications(obj_id player)
    {
        _cancelAllNotifications(getLongWithNull(player));
    }

	/**
	 * Returns true if the wearable is wearable by this player
	 */
	private static native boolean _canEquipWearable(long player, long wearable);
	public static boolean canEquipWearable(obj_id player, obj_id wearable)
	{
		return _canEquipWearable(getLongWithNull(player), getLongWithNull(wearable));
	}

	// Pass in -1 for any of the min or max values to ignore that parameter and use the full range
	private static native void _openCustomizationWindow(long player, long object, String customVarName1, int minVar1, int maxVar1,
														String customVarName2, int minVar2, int maxVar2,
														String customVarName3, int minVar3, int maxVar3,
														String customVarName4, int minVar4, int maxVar4);
	public static void openCustomizationWindow(obj_id player, obj_id object, String customVarName1, int minVar1, int maxVar1,
											   String customVarName2, int minVar2, int maxVar2,
											   String customVarName3, int minVar3, int maxVar3,
											   String customVarName4, int minVar4, int maxVar4)
	{
		_openCustomizationWindow(getLongWithNull(player), getLongWithNull(object), customVarName1, minVar1, maxVar1,
								 customVarName2, minVar2, maxVar2,
								 customVarName3, minVar3, maxVar3,
								 customVarName4, minVar4, maxVar4);
	}

	private static native void _incrementKillMeter(long player, int amount);
	public static void incrementKillMeter(obj_id player, int amount)
	{
		_incrementKillMeter(getLongWithNull(player), amount);
	}
	private static native int _getKillMeter(long player);
	public static int getKillMeter(obj_id player)
	{
		return _getKillMeter(getLongWithNull(player));
	}

	private static native long _getBeastmasterPet(long object);
	public static obj_id getBeastmasterPet (obj_id object)
	{
		return getObjIdWithNull(_getBeastmasterPet(getLongWithNull(object)));
	}
	/**
	 * Sets the beastmaster pet id
	 * @param object    the object
	 * @param pet    the new pet
	 * @return true on success, false on error
	 */
	private static native boolean _setBeastmasterPet(long object, long pet);
	public static boolean setBeastmasterPet(obj_id object, obj_id pet)
	{
		return _setBeastmasterPet(getLongWithNull(object), getLongWithNull(pet));
	}
    /**
     * Sets the beastmaster pet commands available for the current pet
     * @param object    the pet owner
     * @param data      the list of commands
     * @return true on success, false on fail
     */
    private static native boolean _setBeastmasterPetCommands(long object, String[] data);
    public static boolean setBeastmasterPetCommands(obj_id object, String[] data)
    {
        return _setBeastmasterPetCommands(getLongWithNull(object), data);
    }
	/**
	 * Sets the list of beastmaster pets that should appear as toggled on in the UI
	 * @param object    the pet owner
	 * @param data      the list of commands
	 * @return true on success, false on fail
	 */
	private static native boolean _setBeastmasterToggledPetCommands(long object, String[] data);
	public static boolean setBeastmasterToggledPetCommands(obj_id object, String[] data)
	{
		return _setBeastmasterToggledPetCommands(getLongWithNull(object), data);
	}

	/**
	* Sets the difficulty of an NPC
	* @param object     the NPC to change
	* @param difficulty the difficulty to set
	* @return true on success, false on fail
	 */
	private static native boolean _setNpcDifficulty(long object, long difficulty);

	public static boolean setNpcDifficulty(obj_id object, long difficulty)
	{
		return _setNpcDifficulty(getLongWithNull(object), difficulty);
	}
	/**
	* Sets the visual appearance of an object, this DOES NOT corrupt their original appearance.
	* @param object     			the Object to change
	* @param sharedTemplateName     the path to the shared object template to use for the new appearance (i.e. "object/mobile/shared_jawa_male.iff")
	 */
	private static native void _setObjectAppearance(long object, String sharedTemplateName);
	public static void setObjectAppearance(obj_id object, String sharedTemplateName)
	{
		_setObjectAppearance(getLongWithNull(object), sharedTemplateName);
	}
	/**
	* Reverts the appearance of an object to it's original(default) appearance.
	* @param object     			the Object to revert
	 */
	private static native void _revertObjectAppearance(long object);
	public static void revertObjectAppearance(obj_id object)
	{
		_revertObjectAppearance(getLongWithNull(object));
	}

	private static native boolean _isPlayerBackpackHidden(long object);
	public static boolean isPlayerBackpackHidden(obj_id object)
	{
		return _isPlayerBackpackHidden(getLongWithNull(object));
	}

	private static native boolean _isPlayerHelmetHidden(long object);
	public static boolean isPlayerHelmetHidden(obj_id object)
	{
		return _isPlayerHelmetHidden(getLongWithNull(object));
	}

	private static native boolean _startUniverseWideEvent(String eventName);
	public static boolean startUniverseWideEvent(String eventName)
	{
		return _startUniverseWideEvent(eventName);
	}

	private static native boolean _stopUniverseWideEvent(String eventName);
	public static boolean stopUniverseWideEvent(String eventName)
	{
		return _stopUniverseWideEvent(eventName);
	}

	private static native String _getCurrentUniverseWideEvents();
	public static String getCurrentUniverseWideEvents()
	{
		return _getCurrentUniverseWideEvents();
	}


	private static native boolean _isCreatureStatic(long object);
	public static boolean isCreatureStatic(obj_id object)
	{
		return _isCreatureStatic(getLongWithNull(object));
	}

	private static native boolean _overrideDefaultAttack(long player, String attack);
	public static boolean overrideDefaultAttack(obj_id player, String attack)
	{
		return _overrideDefaultAttack(getLongWithNull(player), attack);
	}

	private static native boolean _removeDefaultAttackOverride(long player);
	public static boolean removeDefaultAttackOverride(obj_id player)
	{
		return _removeDefaultAttackOverride(getLongWithNull(player));
	}

	private static native String _getDefaultAttackOverrideActionName(long player);
	public static String getDefaultAttackOverrideActionName(obj_id player)
	{
		return _getDefaultAttackOverrideActionName(getLongWithNull(player));
	}

	private static native boolean _updateNetworkTriggerVolume(long target, float radius);
	public static boolean updateNetworkTriggerVolume(obj_id target, float radius)
	{
		return _updateNetworkTriggerVolume(getLongWithNull(target), radius);
	}


	/**
	* Set an override color that an object will use when displayed on the
	* overhead map on all clients.
	*
	* This override is not persisted.
	*
	* @param target       the Object instance for which the color will be set
	* @param r            the red component of the desired color.  Must be in range 0..255, inclusive.
	* @param g            the green component of the desired color.  Must be in range 0..255, inclusive.
	* @param b            the blue component of the desired color.  Must be in range 0..255, inclusive.
	*
	* @see color
	*/
	private static native boolean _setOverrideMapColor(long target, int r, int g, int b);
	public static boolean setOverrideMapColor(obj_id target, int r, int g, int b)
	{
		return _setOverrideMapColor(getLongWithNull(target), r, g, b);
	}

	/**
	* Clears the overridden map color of an object. The object will return to
	* using the normal type-based coloring.
	*
	* @param target       the Object instance for which the color will be cleared
	*
	* @see color
	*/
	private static native boolean _clearOverrideMapColor(long target);
	public static boolean clearOverrideMapColor(obj_id target)
	{
		return _clearOverrideMapColor(getLongWithNull(target));
	}

	/**
	* Retrieve the color set to override the default map color.
	*
	* @param target       the Object instance for which the color will be retrieved.
	*
	* @return  the overridden color or null if not overridden
	*
	* @see color
	*/
	private static native color _getOverrideMapColor(long target);
	public static color getOverrideMapColor(obj_id target)
	{
		return _getOverrideMapColor(getLongWithNull(target));
	}


	/**
	* Set a creature to show the target (over head) ham page even if the player cannot attack it
	*
	* @param target  the creature object that will have the override set
	* @param show    true to turn force, false to clear the override
	*
	* @return  true if successful, false if failed
	*/
	private static native boolean _setForceShowHam(long target, boolean show);
	public static boolean setForceShowHam(obj_id target, boolean show)
	{
		return _setForceShowHam(getLongWithNull(target), show);
	}

	// IsAPlayerAppearanceInventoryContainer
	// This function simply tells you if the passed in container is a player appearance inventory.
	private static native boolean _isAPlayerAppearanceInventoryContainer(long container);
	public static boolean isAPlayerAppearanceInventoryContainer(obj_id container)
	{
		return _isAPlayerAppearanceInventoryContainer(getLongWithNull(container));
	}

	// IsContainedByPlayerAppearanceInventory
	// Simply checks to see if the passed in item is in the appearance inventory of the passed in player.
	private static native boolean _isContainedByPlayerAppearanceInventory(long player, long item);
	public static boolean isContainedByPlayerAppearanceInventory(obj_id player, obj_id item)
	{
		return _isContainedByPlayerAppearanceInventory(getLongWithNull(player), getLongWithNull(item));
	}

	// getAllItemsFromAppearanceInventory
	// Returns a list of OIDs of all the items contained by a the passed in player's appearance inventory.
	private static native long[] _getAllItemsFromAppearanceInventory(long player);
	public static obj_id[] getAllItemsFromAppearanceInventory(obj_id player)
	{
		long[] _ret_long = _getAllItemsFromAppearanceInventory(getLongWithNull(player));
		obj_id[] _ret_obj_id = null;
		if (_ret_long != null)
		{
			_ret_obj_id = new obj_id[_ret_long.length];
			for (int _i = 0; _i < _ret_long.length; ++_i)
			_ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
		}
		return _ret_obj_id;
	}

	// getAllWornItems
	// Returns a list of OIDs of all the items currently being worn by a player.
	// You can specify whether or not you want that list to include appearance inventory items.
	private static native long[] _getAllWornItems(long player, boolean ignoreAppearanceItems);
	public static obj_id[] getAllWornItems(obj_id player, boolean ignoreAppearanceItems)
	{
		long[] _ret_long = _getAllWornItems(getLongWithNull(player), ignoreAppearanceItems);
		obj_id[] _ret_obj_id = null;
		if (_ret_long != null)
		{
			_ret_obj_id = new obj_id[_ret_long.length];
			for (int _i = 0; _i < _ret_long.length; ++_i)
			_ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
		}
		return _ret_obj_id;
	}

	// Returns the obj_id of a character's appearance inventory.
	private static native long _getAppearanceInventory(long player);
	public static obj_id getAppearanceInventory(obj_id player)
	{
		return getObjIdWithNull(_getAppearanceInventory(getLongWithNull(player)));
	}

	// Sets the OID of the original creature we used for our Decoy. This allows the client to display it like a normal player.
	private static native boolean _setDecoyOrigin(long creature, long origin);
	public static boolean setDecoyOrigin(obj_id creature, obj_id origin)
	{
		return _setDecoyOrigin(getLongWithNull(creature), getLongWithNull(origin));
	}

	// Returns the OID of the origin creature for a decoy creature.
	private static native long _getDecoyOrigin(long creature);
	public static obj_id getDecoyOrigin(obj_id creature)
	{
		return getObjIdWithNull(_getDecoyOrigin(getLongWithNull(creature)));
	}

	// This forces the target on a creature's hate list to the top of the hate list.
	// This does not raise the targets hate and the creature will aquire a target of more
	// hate like normal whenever it deems appropriate (timer goes off or is forced).
	private static native void _forceHateTarget(long creature, long target);
	public static void forceHateTarget(obj_id creature, obj_id target)
	{
		_forceHateTarget(getLongWithNull(creature), getLongWithNull(target));
	}

	// Adds a user to the access list of a Tangible object.
	private static native boolean _addUserToAccessList(long object, long user);
	public static boolean addUserToAccessList(obj_id object, obj_id user)
	{
		return _addUserToAccessList(getLongWithNull(object), getLongWithNull(user));
	}

	// Removes a user from the access list of a Tangible object.
	private static native boolean _removeUserFromAccessList(long object, long user);
	public static boolean removeUserFromAccessList(obj_id object, obj_id user)
	{
		return _removeUserFromAccessList(getLongWithNull(object), getLongWithNull(user));
	}

	// Clears the access list of a Tangible object.
	private static native boolean _clearUserAccessList(long object);
	public static boolean clearUserAccessList(obj_id object)
	{
		return _clearUserAccessList(getLongWithNull(object));
	}


	// Adds a Guild to the access list of a Tangible object.
	private static native boolean _addGuildToAccessList(long object, int guild);
	public static boolean addGuildToAccessList(obj_id object, int guild)
	{
		return _addGuildToAccessList(getLongWithNull(object), guild);
	}

	// Removes a guild from the access list of a Tangible object.
	private static native boolean _removeGuildFromAccessList(long object, int guild);
	public static boolean removeGuildFromAccessList(obj_id object, int guild)
	{
		return _removeGuildFromAccessList(getLongWithNull(object), guild);
	}

	// Clears the guild access list of a Tangible object.
	private static native boolean _clearGuildAccessList(long object);
	public static boolean clearGuildAccessList(obj_id object)
	{
		return _clearGuildAccessList(getLongWithNull(object));
	}

	// Returns a list of User OIDs that are current only an items access list.
	private static native long[] _getUserAccessList(long object);
	public static obj_id[] getUserAccessList(obj_id object)
	{
		long[] _ret_long = _getUserAccessList(getLongWithNull(object));
		obj_id[] _ret_obj_id = null;
		if (_ret_long != null)
		{
			_ret_obj_id = new obj_id[_ret_long.length];
			for (int _i = 0; _i < _ret_long.length; ++_i)
			_ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
		}
		return _ret_obj_id;
	}

	// Returns a list of Guild IDs that are current only an items access list.
	private static native int[] _getGuildAccessList(long object);
	public static int[] getGuildAccessList(obj_id object)
	{
		int[] _ret_int = _getGuildAccessList(getLongWithNull(object));
		return _ret_int;
	}

	// Creates a new player quest object in a player's Inventory.
	private static native long _createPlayerQuestObjectInInventory(long creature);
	public static obj_id createPlayerQuestObjectInInventory(obj_id creature)
	{
		return getObjIdWithNull(_createPlayerQuestObjectInInventory(getLongWithNull(creature)));
	}

	// Adds a task to a player quest.
	private static native boolean _addPlayerQuestTask(long questObject, String title, String description, int taskCounterMax, location waypointLoc);
	public static boolean addPlayerQuestTask(obj_id questObject, String title, String description, int taskCounterMax, location waypointLoc)
	{
		return _addPlayerQuestTask(getLongWithNull(questObject), title, description, taskCounterMax, waypointLoc);
	}

	// Gets all the Tasks in a player quest.
	private static native String [] _getPlayerQuestTasks(long questObject);
	public static String [] getPlayerQuestTasks(obj_id questObject)
	{
		return _getPlayerQuestTasks(getLongWithNull(questObject));
	}

	// Gets the status of all tasks.
	private static native int[] _getAllPlayerQuestTaskStatus(long questObject);
	public static int[] getAllPlayerQuestTaskStatus(obj_id questObject)
	{
		return _getAllPlayerQuestTaskStatus(getLongWithNull(questObject));
	}

	// Gets the status of a single task.
	private static native int _getPlayerQuestTaskStatus(long questObject, int taskIndex);
	public static int getPlayerQuestTaskStatus(obj_id questObject, int taskIndex)
	{
		return _getPlayerQuestTaskStatus(getLongWithNull(questObject), taskIndex);
	}

	// Sets the status of a single task.
	// Current values:
	// 	TS_None = 0 <- Does nothing currently.
	//	TS_Current = 1 <- Does nothing currently.
	//	TS_Completed = 2 <- Removes waypoint and task from task helper.
	//	TS_Failed = 3 <- Does nothing currently.
	//  TS_Inactive = 4 <- Hides the task in the quest helper and quest journal.
	private static native void _setPlayerQuestTaskStatus(long questObject, int taskIndex, int status);
	public static void setPlayerQuestTaskStatus(obj_id questObject, int taskIndex, int status)
	{
		_setPlayerQuestTaskStatus(getLongWithNull(questObject), taskIndex, status);
	}

	// Sets the title of a Player Quest
	private static native boolean _setPlayerQuestTitle(long questObject, String title);
	public static boolean setPlayerQuestTitle(obj_id questObject, String title)
	{
		return _setPlayerQuestTitle(getLongWithNull(questObject), title);
	}

	// Sets the description of a Player Quest
	private static native boolean _setPlayerQuestDescription(long questObject, String desc);
	public static boolean setPlayerQuestDescription(obj_id questObject, String desc)
	{
		return _setPlayerQuestDescription(getLongWithNull(questObject), desc);
	}

	//Sets the difficult of a quest. This changes the con color in the quest journal.
	private static native void _setPlayerQuestDifficulty(long questObject, int difficulty);
	public static void setPlayerQuestDifficulty(obj_id questObject, int difficulty)
	{
		_setPlayerQuestDifficulty(getLongWithNull(questObject), difficulty);
	}

	// Gets the difficulty of a player quest.
	private static native int _getPlayerQuestDifficulty(long questObject);
	public static int getPlayerQuestDifficulty(obj_id questObject)
	{
		return _getPlayerQuestDifficulty(getLongWithNull(questObject));
	}

	// Gets the current value of a counter (not max value) of a player quest task.
	private static native int _getPlayerQuestTaskCounter(long questObject, int index);
	public static int getPlayerQuestTaskCounter(obj_id questObject, int index)
	{
		return _getPlayerQuestTaskCounter(getLongWithNull(questObject), index);
	}

	// Sets the current value of a counter of a player task.
	private static native void _setPlayerQuestTaskCounter(long questObject, int index, int value);
	public static void setPlayerQuestTaskCounter(obj_id questObject, int index, int value)
	{
		_setPlayerQuestTaskCounter(getLongWithNull(questObject), index, value);
	}

	private static native String _getPlayerQuestWaypoint(long questObject, int index);
	public static String getPlayerQuestWaypoint(obj_id questObject, int index)
	{
		return _getPlayerQuestWaypoint(getLongWithNull(questObject), index);
	}

	//private static native void _setPlayerQuestWaypoint(long questObject, int index, location loc);
	//public static void setPlayerQuestWaypoint(obj_id questObject, int index, location loc)
	//{
	//	_setPlayerQuestWaypoint(getLongWithNull(questObject), index, loc);
	//}

	private static native boolean _isPlayerQuestTaskComplete(long questObject, int index);
	public static boolean isPlayerQuestTaskComplete(obj_id questObject, int index)
	{
		return _isPlayerQuestTaskComplete(getLongWithNull(questObject), index);
	}

	private static native boolean _isPlayerQuestComplete(long questObject);
	public static boolean isPlayerQuestComplete(obj_id questObject)
	{
		return _isPlayerQuestComplete(getLongWithNull(questObject));
	}

	private static native String _getPlayerQuestTitle(long questObject);
	public static String getPlayerQuestTitle(obj_id questObject)
	{
		return _getPlayerQuestTitle(getLongWithNull(questObject));
	}

	private static native String _getPlayerQuestDescription(long questObject);
	public static String getPlayerQuestDescription(obj_id questObject)
	{
		return _getPlayerQuestDescription(getLongWithNull(questObject));
	}

	private static native String _getPlayerQuestTaskTitle(long questObject, int index);
	public static String getPlayerQuestTaskTitle(obj_id questObject, int index)
	{
		return _getPlayerQuestTaskTitle(getLongWithNull(questObject), index);
	}

	private static native String _getPlayerQuestTaskDescription(long questObject, int index);
	public static String getPlayerQuestTaskDescription(obj_id questObject, int index)
	{
		return _getPlayerQuestTaskDescription(getLongWithNull(questObject), index);
	}

	private static native void _setPlayerQuestRecipe(long questObject, boolean recipe);
	public static void setPlayerQuestRecipe(obj_id questObject, boolean recipe)
	{
		_setPlayerQuestRecipe(getLongWithNull(questObject), recipe);
	}

	private static native boolean _isPlayerQuestRecipe(long questObject);
	public static boolean isPlayerQuestRecipe(obj_id questObject)
	{
		return _isPlayerQuestRecipe(getLongWithNull(questObject));
	}

	private static native void _addPlayerQuestTaskRecipeData(long questObject, String data);
	public static void addPlayerQuestTaskRecipeData(obj_id questObject, String data)
	{
		_addPlayerQuestTaskRecipeData(getLongWithNull(questObject), data);
	}

	private static native void _addPlayerQuestTaskRecipeDataWithIndex(long questObject, int index, String data);
	public static void addPlayerQuestTaskRecipeData(obj_id questObject, int index, String data)
	{
		_addPlayerQuestTaskRecipeDataWithIndex(getLongWithNull(questObject), index, data);
	}

	private static native void _setPlayerQuestRewardData(long questObject, String data);
	public static void setPlayerQuestRewardData(obj_id questObject, String data)
	{
		_setPlayerQuestRewardData(getLongWithNull(questObject), data);
	}

	private static native void _setPlayerQuestCreator(long questObject, long creator);
	public static void setPlayerQuestCreator(obj_id questObject, obj_id creator)
	{
		_setPlayerQuestCreator(getLongWithNull(questObject), getLongWithNull(creator));
	}

	private static native boolean _openRatingWindow(long player, String title, String description);
	public static boolean openRatingWindow(obj_id player, String title, String description)
	{
		return _openRatingWindow(getLongWithNull(player), title, description);
	}

	private static native void _openPlayerQuestRecipe(long player, long recipe);
	public static void openPlayerQuestRecipe(obj_id player, obj_id recipe)
	{
		_openPlayerQuestRecipe(getLongWithNull(player), getLongWithNull(recipe));
	}

	private static native long[] _pgcGetChroniclerId(String chroniclerName);
	public static obj_id[] pgcGetChroniclerId(String chroniclerName)
	{
		long[] _ret_long = _pgcGetChroniclerId(chroniclerName);
		obj_id[] _ret_obj_id = null;
	        if (_ret_long != null)
	        {
	            _ret_obj_id = new obj_id[_ret_long.length];
	            for (int _i = 0; _i < _ret_long.length; ++_i)
	                _ret_obj_id[_i] = getObjIdWithNull(_ret_long[_i]);
	        }
	        return _ret_obj_id;
	}

	private static native String _pgcGetChroniclerName(long chroniclerId);
	public static String pgcGetChroniclerName(obj_id chroniclerId)
	{
		return _pgcGetChroniclerName(getLongWithNull(chroniclerId));
	}

	// returns NULL or int[] of length 3
	public static final int PGC_INFO_INDEX_TOTAL_RATING_COUNT = 0;
	public static final int PGC_INFO_INDEX_TOTAL_RATING_VALUE = 1;
	public static final int PGC_INFO_INDEX_MOST_RECENT_RATING_TIME = 2;
	private static native int[] _pgcGetRating(long chroniclerId);
	public static int[] pgcGetRating(obj_id chroniclerId)
	{
		return _pgcGetRating(getLongWithNull(chroniclerId));
	}

	private static native void _pgcAdjustRating(long chroniclerId, String chroniclerName, int adjustment);
	public static void pgcAdjustRating(obj_id chroniclerId, String chroniclerName, int adjustment)
	{
		_pgcAdjustRating(getLongWithNull(chroniclerId), chroniclerName, adjustment);
	}

	// returns NULL or int[] of length 20
	private static native int[] _pgcGetRatingData(long chroniclerId);
	public static int[] pgcGetRatingData(obj_id chroniclerId)
	{
		return _pgcGetRatingData(getLongWithNull(chroniclerId));
	}

	// index must be 0 - 19 inclusive
	private static native void _pgcAdjustRatingData(long chroniclerId,  String chroniclerName, int index, int adjustment);
	public static void pgcAdjustRatingData(obj_id chroniclerId,  String chroniclerName, int index, int adjustment)
	{
		_pgcAdjustRatingData(getLongWithNull(chroniclerId), chroniclerName, index, adjustment);
	}

	private static native void _pgcSetRatingData(long chroniclerId,  String chroniclerName, int index, int value);
	public static void pgcSetRatingData(obj_id chroniclerId,  String chroniclerName, int index, int value)
	{
		_pgcSetRatingData(getLongWithNull(chroniclerId), chroniclerName, index, value);
	}

	public static native String filterText(String text);

	private static native void _resetAllPlayerQuestData(long questID);
	public static void resetAllPlayerQuestData(obj_id questID)
	{
		_resetAllPlayerQuestData(getLongWithNull(questID));
	}

	private static native void _openExamineWindow(long player, long item);
	public static void openExamineWindow(obj_id player, obj_id item)
	{
		_openExamineWindow(getLongWithNull(player), getLongWithNull(item));
	}

	private static native void _addObjectEffect(long obj, String effectFile, String hardpoint, vector offset, float scale, String label);
	public static void addObjectEffect(obj_id obj, String effectFile, String hardpoint, vector offset, float scale, String label)
	{
		_addObjectEffect(getLongWithNull(obj), effectFile, hardpoint, offset, scale, label);
	}

	private static native void _removeObjectEffect(long obj, String label);
	public static void removeObjectEffect(obj_id obj, String label)
	{
		_removeObjectEffect(getLongWithNull(obj), label);
	}

	private static native void _removeAllObjectEffects(long obj);
	public static void removeAllObjectEffects(obj_id obj)
	{
		_removeAllObjectEffects(getLongWithNull(obj));
	}

	private static native boolean _hasObjectEffect(long obj, String label);
	public static boolean hasObjectEffect(obj_id obj, String label)
	{
		return _hasObjectEffect(getLongWithNull(obj), label);
	}
}   // class base_class
